{"ast":null,"code":"import _slicedToArray from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _taggedTemplateLiteral from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js\";\nimport _defineEnumerableProperties from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/defineEnumerableProperties.js\";\nimport _defineProperty from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6;\nvar tableSymbol = Symbol(\"table\");\nvar table = function table(name, dependsOnTables) {\n  var _ref, _mutatorMap;\n  return _ref = {\n    name: name,\n    dependsOnTables: dependsOnTables || [],\n    get allDependingTables() {\n      var tableDefs = [];\n      this.dependsOnTables.forEach(function (def) {\n        tableDefs.push.apply(tableDefs, _toConsumableArray(def.allDependingTables));\n      });\n      return tableDefs;\n    }\n  }, _mutatorMap = {}, _mutatorMap[tableSymbol] = _mutatorMap[tableSymbol] || {}, _mutatorMap[tableSymbol].get = function () {\n    return this;\n  }, _defineProperty(_ref, \"__discriminator\", \"ITableDef\"), _defineEnumerableProperties(_ref, _mutatorMap), _ref;\n};\nfunction isTable(x) {\n  if (x === null) return false;\n  if (typeof x !== \"object\") return false;\n  return Boolean(x[tableSymbol]);\n}\nvar isPrimitiveValue = function isPrimitiveValue(t) {\n  return t === null || typeof t === \"string\" || typeof t === \"number\" || t instanceof Uint8Array;\n};\nvar insertRegex = /insert\\s+(or\\s+\\w+\\s+)?into\\s+/gim;\nvar deleteRegex = /delete\\s+from\\s+/gim;\nvar updateRegex = /update\\s+(or\\s+\\w+\\s+)?/gim;\nvar strip = function strip(str) {\n  return str.replace(/\"/g, \"\").split(\".\").map(function (v) {\n    return '\"' + v + '\"';\n  }).join(\".\");\n};\nfunction isSql(x) {\n  if (x === null) return false;\n  if (typeof x !== \"object\") return false;\n  return \"toSql\" in x;\n}\nfunction internalSql(_rawStrings, _rawValues) {\n  if (_rawStrings.length - 1 !== _rawValues.length) {\n    if (_rawStrings.length === 0) {\n      throw new TypeError(\"Expected at least 1 string\");\n    }\n    throw new TypeError(\"Expected \".concat(_rawStrings.length, \" strings to have \").concat(_rawStrings.length - 1, \" values\"));\n  }\n  var valuesLength = _rawValues.reduce(function (len, value) {\n    return len + (isSql(value) ? value.toSql()._values.length : isTable(value) ? 0 : 1);\n  }, 0);\n  var tablesLength = _rawValues.reduce(function (len, value) {\n    return len + (isSql(value) ? value.toSql().tables.length : isTable(value) ? 1 : 0);\n  }, 0);\n  var values = new Array(valuesLength);\n  var strings = new Array(valuesLength + 1);\n  var tables = new Array(tablesLength);\n  strings[0] = _rawStrings[0];\n  var pos = 0,\n    tableI = 0;\n  _rawValues.forEach(function (val, i) {\n    var child = _rawValues[i];\n    var rawString = _rawStrings[i + 1];\n    if (isSql(child)) {\n      var sql2 = child.toSql();\n      strings[pos] += sql2._strings[0];\n      sql2._values.forEach(function (childVal, childI) {\n        values[pos++] = sql2._values[childI];\n        strings[pos] = sql2._strings[childI + 1];\n      });\n      sql2.tables.forEach(function (t, childTableI) {\n        tables[tableI++] = sql2.tables[childTableI++];\n      });\n      strings[pos] += rawString;\n    } else if (isTable(child)) {\n      strings[pos] += strip(child[tableSymbol].name) + rawString;\n      tables[tableI++] = child[tableSymbol];\n    } else {\n      values[pos++] = child;\n      strings[pos] = rawString;\n    }\n  });\n  return {\n    _values: values,\n    _strings: strings,\n    tables: tables,\n    get isModifyQuery() {\n      var query = this.preparedQuery.text;\n      return query.match(insertRegex) !== null || query.match(deleteRegex) !== null || query.match(updateRegex) !== null;\n    },\n    get isReadQuery() {\n      return !this.isModifyQuery;\n    },\n    get isEmpty() {\n      return this.preparedQuery.text.trim().length === 0;\n    },\n    get hash() {\n      if (!this._hash) {\n        this._hash = this._strings.join() + this._values.join();\n      }\n      return this._hash;\n    },\n    get raw() {\n      var _this = this;\n      return this._strings[0] + this._strings.slice(1).map(function (val, i) {\n        return (typeof _this._values[i] === \"string\" ? \"'\" + _this._values[i] + \"'\" : _this._values[i]) + val;\n      }).join(\"\");\n    },\n    get preparedQuery() {\n      if (!this._cachedText) {\n        this._cachedText = (this._strings[0] + this._strings.slice(1).map(function (val, i) {\n          return \"?\".concat(val);\n        }).join(\"\")).trim();\n      }\n      return {\n        values: this._values,\n        text: this._cachedText\n      };\n    },\n    inspect: function inspect() {\n      return {\n        preparedQuery: this.preparedQuery,\n        tables: this.tables\n      };\n    },\n    toSql: function toSql() {\n      return this;\n    },\n    toString: function toString() {\n      var _this$preparedQuery = this.preparedQuery,\n        values2 = _this$preparedQuery.values,\n        text = _this$preparedQuery.text;\n      return \"\".concat(text, \" - [\").concat(values2.join(\", \"), \"]\");\n    }\n  };\n}\nfunction sql(rawStrings) {\n  for (var _len = arguments.length, rawValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    rawValues[_key - 1] = arguments[_key];\n  }\n  return internalSql(rawStrings, rawValues);\n}\nsql.raw = function (value) {\n  return sql([value]);\n};\nsql.liter = function (str) {\n  return sql.raw(strip(str));\n};\nsql.table = table;\nsql.isTable = isTable;\nsql.isSql = isSql;\nsql.empty = sql.raw(\"\");\nsql.join = function (values) {\n  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \", \";\n  var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  var suffix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n  values = values.filter(function (v) {\n    return isSql(v) ? !v.toSql().isEmpty : true;\n  });\n  if (values.length === 0) {\n    throw new TypeError(\"Expected `join([])` to be called with an array of multiple elements, but got an empty array\");\n  }\n  return internalSql([prefix].concat(_toConsumableArray(Array(values.length - 1).fill(separator)), [suffix]), values);\n};\nvar generateInsert = function generateInsert(tableName, objs) {\n  var replace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var returning = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (objs.length === 0) throw new Error(\"Can't insert empty objects\");\n  var keys = Object.keys(objs[0]);\n  var values = sql.join(objs.map(function (obj) {\n    return sql(_templateObject || (_templateObject = _taggedTemplateLiteral([\"(\", \")\"])), sql.join(keys.map(function (k) {\n      return obj[k];\n    })));\n  }));\n  return sql(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"INSERT \", \" INTO \", \" (\", \") VALUES \", \" \", \"\"])), replace ? sql(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"OR REPLACE\"]))) : sql.empty, sql.table(tableName), sql.join(keys.map(function (k) {\n    return sql.raw(k);\n  })), values, returning ? sql(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"returning *\"]))) : sql.empty);\n};\nvar generateUpdate = function generateUpdate(tableName, obj) {\n  var values = sql.join(Object.entries(obj).map(function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n      k = _ref3[0],\n      v = _ref3[1];\n    return sql(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \" = \", \"\"])), sql.raw(k), v);\n  }));\n  return sql(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"UPDATE \", \" SET \", \"\"])), sql.table(tableName), values);\n};\nexport { generateInsert, generateUpdate, isPrimitiveValue, isTable, sql, tableSymbol };","map":{"version":3,"mappings":"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","names":["Symbol","table","name","dependsOnTables","allDependingTables","tableDefs","forEach","def","tableSymbol","x","isPrimitiveValue","t","Uint8Array","insertRegex","deleteRegex","updateRegex","strip","str","replace","split","map","v","join","_rawStrings","_rawValues","length","TypeError","reduce","len","value","toSql","_values","isTable","tables","Array","valuesLength","strings","tablesLength","tableI","val","i","child","sql2","_strings","childVal","childI","values","childTableI","pos","rawString","isModifyQuery","preparedQuery","text","query","match","isReadQuery","isEmpty","trim","hash","_hash","raw","slice","_cachedText","inspect","toString","values2","rawStrings","rawValues","sql","liter","isSql","empty","separator","prefix","suffix","filter","internalSql","fill","generateInsert","tableName","objs","returning","Error","keys","Object","obj","k","generateUpdate","entries"],"sources":["../src/table.ts","../src/sql.ts","../src/helpers.ts"],"sourcesContent":["export const tableSymbol: unique symbol = Symbol(\"table\");\n\nexport interface ITableDef {\n  name: string;\n  dependsOnTables: ITableDef[];\n  __discriminator: \"ITableDef\";\n  allDependingTables: ITableDef[];\n}\n\nexport interface IContainsTable {\n  [tableSymbol]: ITableDef;\n}\n\nexport const table = (\n  name: string,\n  dependsOnTables?: ITableDef[]\n): ITableDef & IContainsTable => {\n  return {\n    name,\n    dependsOnTables: dependsOnTables || [],\n    get allDependingTables() {\n      const tableDefs: ITableDef[] = [];\n\n      this.dependsOnTables.forEach((def) => {\n        tableDefs.push(...def.allDependingTables);\n      });\n\n      return tableDefs;\n    },\n    get [tableSymbol]() {\n      return this;\n    },\n    __discriminator: \"ITableDef\",\n  };\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isTable(x: any): x is IContainsTable {\n  if (x === null) return false;\n  if (typeof x !== \"object\") return false;\n\n  return Boolean(x[tableSymbol]);\n}\n","import {\n  IContainsTable,\n  isTable,\n  ITableDef,\n  table,\n  tableSymbol,\n} from \"./table\";\n\n// Code is taken and adopted from https://github.com/blakeembrey/sql-template-tag\n\nexport type IPrimitiveValue = string | number | null | Uint8Array;\nexport const isPrimitiveValue = (t: unknown): t is IPrimitiveValue => {\n  return (\n    t === null ||\n    typeof t === \"string\" ||\n    typeof t === \"number\" ||\n    t instanceof Uint8Array\n  );\n};\n\nexport type IRawValue = IPrimitiveValue | ISql | IContainsTable | ISqlAdapter;\n\nconst insertRegex = /insert\\s+(or\\s+\\w+\\s+)?into\\s+/gim;\nconst deleteRegex = /delete\\s+from\\s+/gim;\nconst updateRegex = /update\\s+(or\\s+\\w+\\s+)?/gim;\n\nconst strip = (str: string) => {\n  return str\n    .replace(/\"/g, \"\")\n    .split(\".\")\n    .map((v) => '\"' + v + '\"')\n    .join(\".\");\n};\n\nexport interface ISqlAdapter {\n  toSql(): ISql;\n}\n\nfunction isSql(x: unknown): x is ISqlAdapter {\n  if (x === null) return false;\n  if (typeof x !== \"object\") return false;\n\n  return \"toSql\" in x;\n}\n\nexport interface ISql extends ISqlAdapter {\n  readonly _values: IPrimitiveValue[];\n  readonly _strings: string[];\n  readonly tables: ITableDef[];\n\n  _cachedText?: string;\n  _hash?: string;\n\n  get isModifyQuery(): boolean;\n  get isReadQuery(): boolean;\n  get isEmpty(): boolean;\n  get raw(): string;\n\n  get hash(): string;\n\n  get preparedQuery(): {\n    values: IPrimitiveValue[];\n    text: string;\n  };\n\n  inspect(): {\n    preparedQuery: ISql[\"preparedQuery\"];\n    tables: ISql[\"tables\"];\n  };\n\n  toString(): string;\n}\n\nfunction internalSql(\n  _rawStrings: ReadonlyArray<string>,\n  _rawValues: IRawValue[]\n\n): ISql {\n\n\n  if (_rawStrings.length - 1 !== _rawValues.length) {\n    if (_rawStrings.length === 0) {\n      throw new TypeError(\"Expected at least 1 string\");\n    }\n\n    throw new TypeError(\n      `Expected ${_rawStrings.length} strings to have ${\n        _rawStrings.length - 1\n      } values`\n    );\n  }\n\n  const valuesLength = _rawValues.reduce<number>(\n    (len, value) =>\n      len +\n      (isSql(value) ? value.toSql()._values.length : isTable(value) ? 0 : 1),\n    0\n  );\n  const tablesLength = _rawValues.reduce<number>(\n    (len, value) =>\n      len +\n      (isSql(value) ? value.toSql().tables.length : isTable(value) ? 1 : 0),\n    0\n  );\n\n  const values: IPrimitiveValue[] = new Array(valuesLength);\n  const strings: string[] = new Array(valuesLength + 1);\n  const tables: ITableDef[] = new Array(tablesLength);\n\n  strings[0] = _rawStrings[0];\n\n  // Iterate over rw values, strings, and children. The value is always\n  // positioned between two strings, e.g. `index + 1`.\n  let pos = 0,\n    tableI = 0;\n\n  _rawValues.forEach((val, i) => {\n    const child = _rawValues[i];\n    const rawString = _rawStrings[i + 1];\n\n    // Check for nested `sql` queries.\n    if (isSql(child)) {\n      const sql = child.toSql();\n      // Append child prefix text to current string.\n      strings[pos] += sql._strings[0];\n\n      sql._values.forEach((childVal, childI) => {\n        values[pos++] = sql._values[childI];\n        strings[pos] = sql._strings[childI + 1];\n      });\n\n      sql.tables.forEach((t, childTableI) => {\n        tables[tableI++] = sql.tables[childTableI++];\n      });\n\n      // Append raw string to current string.\n      strings[pos] += rawString;\n    } else if (isTable(child)) {\n      strings[pos] += strip(child[tableSymbol].name) + rawString;\n\n      tables[tableI++] = child[tableSymbol];\n    } else {\n      values[pos++] = child;\n      strings[pos] = rawString;\n    }\n  });\n\n  return {\n    _values: values,\n    _strings: strings,\n    tables: tables,\n\n    get isModifyQuery() {\n      const query = this.preparedQuery.text;\n\n      // There some edge cases could happen here, so better regex could be introduced\n      // I don't want put AST parser to frontend lib\n      return (\n        query.match(insertRegex) !== null ||\n        query.match(deleteRegex) !== null ||\n        query.match(updateRegex) !== null\n      );\n    },\n    get isReadQuery() {\n      return !this.isModifyQuery;\n    },\n    get isEmpty() {\n      return this.preparedQuery.text.trim().length === 0;\n    },\n\n    get hash() {\n      if (!this._hash) {\n        this._hash = this._strings.join() + this._values.join();\n      }\n\n      return this._hash;\n    },\n\n    get raw() {\n      return (\n        this._strings[0] +\n        this._strings\n          .slice(1)\n          .map(\n            (val, i) =>\n              (typeof this._values[i] === \"string\"\n                ? \"'\" + this._values[i] + \"'\"\n                : this._values[i]) + val\n          )\n          .join(\"\")\n      );\n    },\n\n    get preparedQuery() {\n      if (!this._cachedText) {\n        this._cachedText = (\n          this._strings[0] +\n          this._strings\n            .slice(1)\n            .map((val, i) => `?${val}`)\n            .join(\"\")\n        ).trim();\n      }\n\n      return {\n        values: this._values,\n        text: this._cachedText,\n      };\n    },\n\n    inspect() {\n      return {\n        preparedQuery: this.preparedQuery,\n        tables: this.tables,\n      };\n    },\n\n    toSql() {\n      return this;\n    },\n\n    toString() {\n      const { values, text } = this.preparedQuery;\n\n      return `${text} - [${values.join(\", \")}]`;\n    },\n  };\n}\n\nexport function sql(\n  rawStrings: ReadonlyArray<string>,\n  ...rawValues: IRawValue[]\n): ISql {\n  return internalSql(rawStrings, rawValues)\n}\n\nsql.raw = (value: string) => {\n  return sql([value]);\n};\nsql.liter = (str: string) => {\n  return sql.raw(strip(str));\n};\nsql.table = table;\nsql.isTable = isTable;\nsql.isSql = isSql;\nsql.empty = sql.raw(\"\");\nsql.join = (\n  values: IRawValue[],\n  separator = \", \",\n  prefix = \"\",\n  suffix = \"\"\n) => {\n  values = values.filter((v) => (isSql(v) ? !v.toSql().isEmpty : true));\n\n  if (values.length === 0) {\n    throw new TypeError(\n      \"Expected `join([])` to be called with an array of multiple elements, but got an empty array\"\n    );\n  }\n\n  return internalSql(\n    [prefix, ...Array(values.length - 1).fill(separator), suffix],\n    values\n  );\n};\n","import { sql } from \"./sql\";\n\nexport const generateInsert = (\n  tableName: string,\n  objs: Record<string, unknown>[],\n  replace = false,\n  returning = false\n) => {\n  if (objs.length === 0) throw new Error(\"Can't insert empty objects\");\n\n  const keys = Object.keys(objs[0]);\n\n  const values = sql.join(\n    objs.map((obj) => sql`(${sql.join(keys.map((k) => obj[k] as string))})`)\n  );\n\n  return sql`INSERT ${replace ? sql`OR REPLACE` : sql.empty} INTO ${sql.table(\n    tableName\n  )} (${sql.join(keys.map((k) => sql.raw(k)))}) VALUES ${values} ${\n    returning ? sql`returning *` : sql.empty\n  }`;\n};\n\nexport const generateUpdate = (\n  tableName: string,\n  obj: Record<string, unknown>\n) => {\n  const values = sql.join(\n    Object.entries(obj).map(([k, v]) => sql`${sql.raw(k)} = ${v as string}`)\n  );\n\n  return sql`UPDATE ${sql.table(tableName)} SET ${values}`;\n};\n"]},"metadata":{},"sourceType":"module"}