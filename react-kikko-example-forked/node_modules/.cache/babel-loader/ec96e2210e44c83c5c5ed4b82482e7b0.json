{"ast":null,"code":"import _taggedTemplateLiteral from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js\";\nimport _toConsumableArray from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar _templateObject, _templateObject2, _templateObject3;\nimport { firstValueFrom, filter, BehaviorSubject, map, take, pipe, switchMap, of } from \"rxjs\";\nimport { sql } from \"@kikko-land/sql\";\nvar runAfterTransaction = function runAfterTransaction(db, func) {\n  if (!db.localState.transactionsState) {\n    throw new Error(\"Not in transaction.\");\n  }\n  var unsubscribes = [];\n  var listener = function listener(event) {\n    return function (db2, transaction) {\n      func(event, db2, transaction);\n      var _iterator = _createForOfIteratorHelper(unsubscribes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var unsubscribe = _step.value;\n          unsubscribe();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    };\n  };\n  unsubscribes.push(db.sharedState.eventsEmitter.on(\"transactionCommitted\", listener(\"committed\")));\n  unsubscribes.push(db.sharedState.eventsEmitter.on(\"transactionRollbacked\", listener(\"rollbacked\")));\n};\nvar runAfterTransactionCommitted = function runAfterTransactionCommitted(db, func) {\n  runAfterTransaction(db, function (ev, db2, transaction) {\n    if (ev === \"committed\") {\n      func(db2, transaction);\n    }\n  });\n};\nvar runAfterTransactionRollbacked = function runAfterTransactionRollbacked(db, func) {\n  runAfterTransaction(db, function (ev, db2, transaction) {\n    if (ev === \"rollbacked\") {\n      func(db2, transaction);\n    }\n  });\n};\nfunction createNanoEvents() {\n  var events = {};\n  return {\n    emit: function emit(event) {\n      var _arguments = arguments;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var all, _len, args, _key, _iterator2, _step2, toCall;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                all = events[event] || [];\n                for (_len = _arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                  args[_key - 1] = _arguments[_key];\n                }\n                _iterator2 = _createForOfIteratorHelper(all);\n                _context.prev = 3;\n                _iterator2.s();\n              case 5:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context.next = 11;\n                  break;\n                }\n                toCall = _step2.value;\n                _context.next = 9;\n                return toCall.apply(void 0, args);\n              case 9:\n                _context.next = 5;\n                break;\n              case 11:\n                _context.next = 16;\n                break;\n              case 13:\n                _context.prev = 13;\n                _context.t0 = _context[\"catch\"](3);\n                _iterator2.e(_context.t0);\n              case 16:\n                _context.prev = 16;\n                _iterator2.f();\n                return _context.finish(16);\n              case 19:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[3, 13, 16, 19]]);\n      }))();\n    },\n    on: function on(event, cb) {\n      (events[event] = events[event] || []).push(cb);\n      return function () {\n        events[event] = (events[event] || []).filter(function (i) {\n          return i !== cb;\n        });\n      };\n    }\n  };\n}\nvar assureDbIsRunning = function assureDbIsRunning(state, toStart) {\n  var _state$sharedState = state.sharedState,\n    runningState$ = _state$sharedState.runningState$,\n    dbName = _state$sharedState.dbName;\n  if (runningState$.value !== \"running\") {\n    throw new Error(\"Failed to start \".concat(toStart(), \", db \").concat(dbName, \" is stopping\"));\n  }\n};\nvar unwrapQueries = function unwrapQueries(queries) {\n  return queries.map(function (q) {\n    return q.preparedQuery;\n  });\n};\nfunction makeId() {\n  var result = \"\";\n  var characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  var charactersLength = characters.length;\n  for (var i = 0; i < 32; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n}\nvar acquireJob = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(jobsState$, _job) {\n    var id, job, _jobsState$$value, current, queue, promise;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            id = makeId();\n            job = _objectSpread(_objectSpread({}, _job), {}, {\n              id: id\n            });\n            _jobsState$$value = jobsState$.value, current = _jobsState$$value.current, queue = _jobsState$$value.queue;\n            if (!(current || queue.length > 0)) {\n              _context2.next = 10;\n              break;\n            }\n            promise = firstValueFrom(jobsState$.pipe(filter(function (_ref2) {\n              var current2 = _ref2.current;\n              return (current2 == null ? void 0 : current2.id) === id;\n            })));\n            jobsState$.next({\n              queue: [].concat(_toConsumableArray(queue), [job]),\n              current: current\n            });\n            _context2.next = 8;\n            return promise;\n          case 8:\n            _context2.next = 11;\n            break;\n          case 10:\n            jobsState$.next({\n              queue: [],\n              current: job\n            });\n          case 11:\n            return _context2.abrupt(\"return\", job);\n          case 12:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return function acquireJob(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\nvar releaseJob = function releaseJob(jobsState$, job) {\n  var _jobsState$$value2 = jobsState$.value,\n    current = _jobsState$$value2.current,\n    queue = _jobsState$$value2.queue;\n  if ((current == null ? void 0 : current.id) !== job.id) {\n    throw new Error(\"Can't release job that is not currently running, current: \".concat(JSON.stringify(current), \", queue: \").concat(JSON.stringify(queue), \", toRelease: \").concat(JSON.stringify(job)));\n  }\n  jobsState$.next({\n    queue: queue.slice(1),\n    current: queue[0]\n  });\n};\nvar whenAllJobsDone = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(jobsState$) {\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.abrupt(\"return\", firstValueFrom(jobsState$.pipe(filter(function (_ref4) {\n              var queue = _ref4.queue;\n              return queue.length === 0;\n            }))));\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return function whenAllJobsDone(_x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nvar initDbClient = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref5) {\n    var dbName, plugins, queriesMiddlewares, dbBackend, runningState$, dbBackendCalled, jobsState$, state, job, initializerPipe;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            dbName = _ref5.dbName, plugins = _ref5.plugins, queriesMiddlewares = _ref5.queriesMiddlewares, dbBackend = _ref5.dbBackend;\n            runningState$ = new BehaviorSubject(\"running\");\n            _context6.next = 4;\n            return dbBackend;\n          case 4:\n            _context6.t0 = _context6.sent;\n            dbBackendCalled = (0, _context6.t0)({\n              dbName: dbName,\n              stopped$: runningState$.pipe(filter(function (e) {\n                return e === \"stopped\";\n              }), map(function () {\n                return void 0;\n              }), take(1))\n            });\n            jobsState$ = new BehaviorSubject({\n              queue: [],\n              current: void 0\n            });\n            state = {\n              sharedState: {\n                clientId: makeId(),\n                dbBackend: dbBackendCalled,\n                dbName: dbName,\n                runningState$: runningState$,\n                stopStarted$: runningState$.pipe(filter(function (e) {\n                  return e === \"stopping\";\n                }), map(function () {\n                  return void 0;\n                }), take(1)),\n                eventsEmitter: createNanoEvents(),\n                jobsState$: jobsState$,\n                transactionsState: {}\n              },\n              localState: {\n                queriesMiddlewares: queriesMiddlewares || [],\n                transactionsState: {}\n              }\n            };\n            _context6.next = 10;\n            return acquireJob(state.sharedState.jobsState$, {\n              type: \"initDb\",\n              name: dbName\n            });\n          case 10:\n            job = _context6.sent;\n            initializerPipe = pipe(switchMap( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n              return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                while (1) {\n                  switch (_context4.prev = _context4.next) {\n                    case 0:\n                      _context4.next = 2;\n                      return dbBackendCalled.initialize();\n                    case 2:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }\n              }, _callee4);\n            }))), map(function () {\n              var currentState = state;\n              var _iterator3 = _createForOfIteratorHelper(plugins || []),\n                _step3;\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var plugin = _step3.value;\n                  currentState = plugin(state);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n              return currentState;\n            }), switchMap( /*#__PURE__*/function () {\n              var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(currentState) {\n                return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                  while (1) {\n                    switch (_context5.prev = _context5.next) {\n                      case 0:\n                        releaseJob(jobsState$, job);\n                        _context5.next = 3;\n                        return state.sharedState.eventsEmitter.emit(\"initialized\", state);\n                      case 3:\n                        return _context5.abrupt(\"return\", currentState);\n                      case 4:\n                      case \"end\":\n                        return _context5.stop();\n                    }\n                  }\n                }, _callee5);\n              }));\n              return function (_x5) {\n                return _ref8.apply(this, arguments);\n              };\n            }()));\n            return _context6.abrupt(\"return\", firstValueFrom(state.sharedState.runningState$.pipe(switchMap(function (runningState) {\n              return runningState === \"running\" ? of(void 0).pipe(initializerPipe) : of(state);\n            }))));\n          case 13:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return function initDbClient(_x4) {\n    return _ref6.apply(this, arguments);\n  };\n}();\nvar stopDb = /*#__PURE__*/function () {\n  var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(state) {\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            state.sharedState.runningState$.next(\"stopping\");\n            _context7.next = 3;\n            return whenAllJobsDone(state.sharedState.jobsState$);\n          case 3:\n            console.log(\"stopped db\");\n            state.sharedState.runningState$.next(\"stopped\");\n          case 5:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return function stopDb(_x6) {\n    return _ref9.apply(this, arguments);\n  };\n}();\nvar runQueriesMiddleware = /*#__PURE__*/function () {\n  var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_ref10) {\n    var dbState, queries, _a, _dbState$localState, transactionsLocalState, suppressLog2, _dbState$sharedState, transactionsSharedState, jobsState$, dbBackend, job, execOpts, result;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            dbState = _ref10.dbState, queries = _ref10.queries;\n            _dbState$localState = dbState.localState, transactionsLocalState = _dbState$localState.transactionsState, suppressLog2 = _dbState$localState.suppressLog, _dbState$sharedState = dbState.sharedState, transactionsSharedState = _dbState$sharedState.transactionsState, jobsState$ = _dbState$sharedState.jobsState$, dbBackend = _dbState$sharedState.dbBackend;\n            if (!transactionsLocalState.current) {\n              assureDbIsRunning(dbState, function () {\n                return JSON.stringify(queries);\n              });\n            }\n            if (!(transactionsLocalState.current && transactionsSharedState.current)) {\n              _context8.next = 6;\n              break;\n            }\n            if (!(transactionsLocalState.current.id !== transactionsSharedState.current.id)) {\n              _context8.next = 6;\n              break;\n            }\n            throw new Error(\"Internal error: local running transaction is not the same as shared state transaction\");\n          case 6:\n            if (transactionsLocalState.current) {\n              _context8.next = 10;\n              break;\n            }\n            _context8.next = 9;\n            return acquireJob(jobsState$, {\n              type: \"runQueries\",\n              queries: queries.map(function (q) {\n                return q.toSql();\n              })\n            });\n          case 9:\n            job = _context8.sent;\n          case 10:\n            execOpts = {\n              log: {\n                suppress: Boolean(suppressLog2),\n                transactionId: (_a = transactionsLocalState.current) == null ? void 0 : _a.id\n              }\n            };\n            _context8.prev = 11;\n            _context8.next = 14;\n            return dbBackend.execQueries(unwrapQueries(queries.map(function (q) {\n              return q.toSql();\n            })), execOpts);\n          case 14:\n            result = _context8.sent;\n            return _context8.abrupt(\"return\", {\n              dbState: dbState,\n              result: result,\n              queries: queries\n            });\n          case 16:\n            _context8.prev = 16;\n            if (job) {\n              releaseJob(jobsState$, job);\n            }\n            return _context8.finish(16);\n          case 19:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8, null, [[11,, 16, 19]]);\n  }));\n  return function runQueriesMiddleware(_x7) {\n    return _ref11.apply(this, arguments);\n  };\n}();\nvar runQueries = /*#__PURE__*/function () {\n  var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(state, queries) {\n    var middlewares, toCall, _iterator4, _step4, _loop;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            middlewares = [].concat(_toConsumableArray(state.localState.queriesMiddlewares), [runQueriesMiddleware]).reverse();\n            toCall = function toCall(args) {\n              return Promise.resolve(args);\n            };\n            _iterator4 = _createForOfIteratorHelper(middlewares);\n            try {\n              _loop = function _loop() {\n                var middleware = _step4.value;\n                var currentCall = toCall;\n                toCall = function toCall(args) {\n                  return middleware(_objectSpread(_objectSpread({}, args), {}, {\n                    next: currentCall\n                  }));\n                };\n              };\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                _loop();\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n            _context9.next = 6;\n            return toCall({\n              dbState: state,\n              result: [],\n              queries: queries.map(function (q) {\n                return q.toSql();\n              })\n            });\n          case 6:\n            return _context9.abrupt(\"return\", _context9.sent.result);\n          case 7:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  return function runQueries(_x8, _x9) {\n    return _ref12.apply(this, arguments);\n  };\n}();\nvar runQuery = /*#__PURE__*/function () {\n  var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(state, query) {\n    return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            _context10.next = 2;\n            return runQueries(state, [query]);\n          case 2:\n            _context10.t0 = _context10.sent[0];\n            if (_context10.t0) {\n              _context10.next = 5;\n              break;\n            }\n            _context10.t0 = [];\n          case 5:\n            return _context10.abrupt(\"return\", _context10.t0);\n          case 6:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10);\n  }));\n  return function runQuery(_x10, _x11) {\n    return _ref13.apply(this, arguments);\n  };\n}();\nvar suppressLog = function suppressLog(state, func) {\n  return func(_objectSpread(_objectSpread({}, state), {}, {\n    localState: _objectSpread(_objectSpread({}, state.localState), {}, {\n      suppressLog: true\n    })\n  }));\n};\nvar withSuppressedLog = function withSuppressedLog(state) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    localState: _objectSpread(_objectSpread({}, state.localState), {}, {\n      suppressLog: true\n    })\n  });\n};\nvar runInTransactionFunc = /*#__PURE__*/function () {\n  var _ref14 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(state, transactionType, func) {\n    var _state, transactionsLocalState, _state$sharedState2, transactionsSharedState, eventsEmitter, dbBackend, transaction, job, execOpts, res;\n    return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            _state = state, transactionsLocalState = _state.localState.transactionsState, _state$sharedState2 = _state.sharedState, transactionsSharedState = _state$sharedState2.transactionsState, eventsEmitter = _state$sharedState2.eventsEmitter, dbBackend = _state$sharedState2.dbBackend;\n            if (!(transactionsLocalState.current && transactionsSharedState.current)) {\n              _context11.next = 7;\n              break;\n            }\n            if (!(transactionsLocalState.current.id !== transactionsSharedState.current.id)) {\n              _context11.next = 4;\n              break;\n            }\n            throw new Error(\"Internal error: local running transaction is not the same as shared state transaction\");\n          case 4:\n            _context11.next = 6;\n            return func(state);\n          case 6:\n            return _context11.abrupt(\"return\", _context11.sent);\n          case 7:\n            assureDbIsRunning(state, function () {\n              return \"transaction\";\n            });\n            transaction = {\n              id: makeId()\n            };\n            state = _objectSpread(_objectSpread({}, state), {}, {\n              localState: _objectSpread(_objectSpread({}, state.localState), {}, {\n                transactionsState: {\n                  current: transaction\n                }\n              })\n            });\n            _context11.next = 12;\n            return acquireJob(state.sharedState.jobsState$, {\n              type: \"runTransaction\",\n              transaction: transaction\n            });\n          case 12:\n            job = _context11.sent;\n            execOpts = {\n              log: {\n                suppress: Boolean(state.localState.suppressLog),\n                transactionId: transaction.id\n              }\n            };\n            _context11.prev = 14;\n            transactionsSharedState.current = transaction;\n            _context11.next = 18;\n            return eventsEmitter.emit(\"transactionWillStart\", state, transaction);\n          case 18:\n            _context11.next = 20;\n            return dbBackend.execQueries(unwrapQueries([sql(_templateObject || (_templateObject = _taggedTemplateLiteral([\"BEGIN \", \" TRANSACTION;\"])), sql.raw(transactionType))]), execOpts);\n          case 20:\n            _context11.next = 22;\n            return eventsEmitter.emit(\"transactionStarted\", state, transaction);\n          case 22:\n            _context11.prev = 22;\n            _context11.next = 25;\n            return func(state);\n          case 25:\n            res = _context11.sent;\n            _context11.next = 28;\n            return eventsEmitter.emit(\"transactionWillCommit\", state, transaction);\n          case 28:\n            _context11.next = 30;\n            return dbBackend.execQueries(unwrapQueries([sql(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"COMMIT\"])))]), execOpts);\n          case 30:\n            _context11.next = 32;\n            return eventsEmitter.emit(\"transactionCommitted\", state, transaction);\n          case 32:\n            return _context11.abrupt(\"return\", res);\n          case 35:\n            _context11.prev = 35;\n            _context11.t0 = _context11[\"catch\"](22);\n            console.error(\"Rollback transaction\", _context11.t0);\n            _context11.next = 40;\n            return eventsEmitter.emit(\"transactionWillRollback\", state, transaction);\n          case 40:\n            _context11.next = 42;\n            return dbBackend.execQueries(unwrapQueries([sql(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"ROLLBACK\"])))]), execOpts);\n          case 42:\n            _context11.next = 44;\n            return eventsEmitter.emit(\"transactionRollbacked\", state, transaction);\n          case 44:\n            throw _context11.t0;\n          case 45:\n            _context11.prev = 45;\n            releaseJob(state.sharedState.jobsState$, job);\n            return _context11.finish(45);\n          case 48:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, _callee11, null, [[14,, 45, 48], [22, 35]]);\n  }));\n  return function runInTransactionFunc(_x12, _x13, _x14) {\n    return _ref14.apply(this, arguments);\n  };\n}();\nvar runInDeferredTransaction = function runInDeferredTransaction(state, func) {\n  return runInTransactionFunc(state, \"DEFERRED\", func);\n};\nvar runInImmediateTransaction = function runInImmediateTransaction(state, func) {\n  return runInTransactionFunc(state, \"IMMEDIATE\", func);\n};\nvar runInExclusiveTransaction = function runInExclusiveTransaction(state, func) {\n  return runInTransactionFunc(state, \"EXCLUSIVE\", func);\n};\nvar runInTransaction = function runInTransaction(state, func) {\n  return runInDeferredTransaction(state, func);\n};\nexport { initDbClient, makeId, runAfterTransactionCommitted, runAfterTransactionRollbacked, runInDeferredTransaction, runInExclusiveTransaction, runInImmediateTransaction, runInTransaction, runQueries, runQuery, stopDb, suppressLog, withSuppressedLog };","map":{"version":3,"mappings":";;;;;;;;;AAEA,IAAMA,sBAAsB,SAAtBA,oBACJC,IACAC,MAKG;EACC,KAACD,GAAGE,WAAWC,mBAAmB;IAC9B,UAAIC,MAAM,qBAAqB;EACvC;EAEA,IAAMC,eAA+B;EAErC,IAAMC,WACJ,SADIA,SACHC;IAAA,OACD,UAACC,KAAcC,aAA8B;MACtCR,YAAOO,KAAIC,WAAW;MAAA,2CAEDJ;QAAA;MAAA;QAA1B,oDAAwC;UAAA,IAA7BK;UACGA;QACd;MAAA;QAAA;MAAA;QAAA;MAAA;IAAA;EAAA;EAGSL,kBACXL,GAAGW,YAAYC,cAAcC,GAC3B,wBACAP,SAAS,WAAW,CACtB,CACF;EAEaD,kBACXL,GAAGW,YAAYC,cAAcC,GAC3B,yBACAP,SAAS,YAAY,CACvB,CACF;AACF;AAEa,mCAA+B,SAA/BQ,6BACXd,IACAC,MACG;EACHF,oBAAoBC,IAAI,UAACe,IAAIP,KAAIC,aAAgB;IAC/C,IAAIM,OAAO,aAAa;MACtBd,KAAKO,KAAIC,WAAW;IACtB;EAAA,CACD;AACH;AAEa,oCAAgC,SAAhCO,8BACXhB,IACAC,MACG;EACHF,oBAAoBC,IAAI,UAACe,IAAIP,KAAIC,aAAgB;IAC/C,IAAIM,OAAO,cAAc;MACvBd,KAAKO,KAAIC,WAAW;IACtB;EAAA,CACD;AACH;AClD2E;EACzE,IAAMQ,SAAwD;EAEvD;IACCC,oBACJX,OAEA;MAAA;MAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBAEMY,MAAOF,OAAOV,UAAU;gBAAA,+BAH3Ba;kBAAAA;gBAAA;gBAAA,wCAIkBD;gBAAA;gBAAA;cAAA;gBAAA;kBAAA;kBAAA;gBAAA;gBAAVE;gBAAA;gBAAA,OACHA,qBAAUD,IAAI;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAAA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IAExB;IACAP,gBAA2BN,OAAUe,IAA2B;MAC5D,QAAOf,SAASU,OAAOV,UAAU,EAAC,EAAmBgB,KAAKD,EAAE;MAE9D,OAAO,YAAM;QAEJL,wBAAkBV,UAAU,IAAoBiB,OACrD,UAACC;UAAA,OAAeA,MAAMH,EACxB;QAAA;MAAA;IAEJ;EAAA;AAEJ;AChCa,wBAAoB,SAApBI,kBAAqBC,OAAiBC,SAA0B;EACrE,yBAEFD,MADFhB;IAAekB;IAAeC;EAG5B,kBAAcC,UAAU,WAAW;IACrC,MAAM,IAAI3B,gCAAyBwB,2BAAiBE,wBAAoB;EAC1E;AACF;AAEa,oBAAgB,SAAhBE,cAAiBC,SAA8B;EAC1D,OAAOA,QAAQC,IAAI,UAACC;IAAA,OAAMA,EAAEC,aAAa;EAAA;AAC3C;AAEyB;EACvB,IAAIC,SAAS;EACb,IAAMC,aACJ;EACF,IAAMC,mBAAmBD,WAAWE;EACpC,SAASf,IAAI,GAAGA,IAAI,IAAIA,KAAK;IACjBY,qBAAWI,OAAOC,KAAKC,MAAMD,KAAKE,QAAO,GAAIL,gBAAgB,CAAC;EAC1E;EAEO;AACT;ACLa;EAAA,sEAAa,kBACxBM,YACAC;IAAA;IAAA;MAAA;QAAA;UAAA;YAEMC,KAAKC;YACLC,sCAAWH;cAAMC;YAAA;YAAA,oBAEIF,WAAWd,OAA9BmB,qCAASC;YAAA,MAEbD,WAAWC,MAAMX,SAAS;cAAA;cAAA;YAAA;YACtBY,UAAUC,eACdR,WAAWS,KAAK9B,OAAO;cAAA,IAAG+B;cAAA,OAAc,sCAASR,QAAOA,EAAE;YAAA,EAAC,CAC7D;YAEWF,gBAAK;cAAEM,oCAAWA,SAAOF,GAAG;cAAGC;YAAA,CAAS;YAAA;YAAA,OAE7CE;UAAA;YAAA;YAAA;UAAA;YAENP,WAAWW,KAAK;cAAEL,OAAO,EAAI;cAAAD,SAASD;YAAA,CAAK;UAAA;YAAA,kCAGtCA;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACT;EAAA,gBAtBaQ;IAAA;EAAA;AAAA,GAsBb;AAEa,iBAAa,SAAbC,WACXb,YACAI,KACG;EACG,yBAAqBJ,WAAWd;IAA9BmB;IAASC;EAEb,wCAASJ,QAAOE,IAAIF,IAAI;IAC1B,MAAM,IAAI3C,0EACqDuD,KAAKC,UAChEV,OACF,uBAAaS,KAAKC,UAAUT,KAAK,2BAAiBQ,KAAKC,UAAUX,GAAG,GACtE;EACF;EAEWJ,gBAAK;IAAEM,OAAOA,MAAMU,MAAM,CAAC;IAAGX,SAASC,MAAM;EAAI;AAC9D;AAEa;EAAA,uEAAkB,kBAC7BN;IAAA;MAAA;QAAA;UAAA;YAAA,kCAEOQ,eACLR,WAAWS,KAAK9B,OAAO;cAAA,IAAG2B;cAAA,OAAYA,MAAMX,WAAW,CAAC;YAAA,EAAC,CAC3D;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACF;EAAA,gBANasB;IAAA;EAAA;AAAA,GAMb;ACxCO,IAAMC;EAAA,uEAAe;IAAA;IAAA;MAAA;QAAA;UAAA;YAC1BjC,uBACAkC,yBACAC,+CACAC;YAEMrC,gBAAgB,IAAIsC,gBACxB,SACF;YAAA;YAAA,OAE+BD;UAAA;YAAA;YAAzBE,oCAAoC;cACxCtC;cACAuC,UAAUxC,cAAcyB,KACtB9B,OAAO,UAAC8C;gBAAA,OAAMA,MAAM,SAAS;cAAA,IAC7BpC,IAAI;gBAAA,OAAM,MAAiB;cAAA,IAC3BqC,KAAK,CAAC,CACR;YAAA,CACD;YAEK1B,aAAa,IAAIsB,gBAA4B;cACjDhB,OAAO,EAAC;cACRD,SAAS;YAAA,CACV;YAEKvB,QAAkB;cACtBhB,aAAa;gBACX6D,UAAUxB,QAAO;gBACjBkB,WAAWE;gBACXtC;gBAEAD;gBACA4C,cAAc5C,cAAcyB,KAC1B9B,OAAO,UAAC8C;kBAAA,OAAMA,MAAM,UAAU;gBAAA,IAC9BpC,IAAI;kBAAA,OAAM,MAAiB;gBAAA,IAC3BqC,KAAK,CAAC,CACR;gBAEA3D,eAAe8D,kBAA+B;gBAE9C7B;gBACA1C,mBAAmB,CAAC;cACtB;cACAD,YAAY;gBACV+D,oBAAoBA,sBAAsB,EAAC;gBAC3C9D,mBAAmB,CAAC;cACtB;YAAA;YAAA;YAAA,OAGgBsD,WAAW9B,MAAMhB,YAAYkC,YAAY;cACzD8B,MAAM;cACNC,MAAM9C;YAAA,CACP;UAAA;YAHKmB;YAKA4B,kBAAkBvB,KACtBwB,mFAAU;cAAA;gBAAA;kBAAA;oBAAA;sBAAA;sBAAA,OACFV,gBAAgBW;oBAAA;oBAAA;sBAAA;kBAAA;gBAAA;cAAA;YAAA,CACvB,KACD7C,IAAI,YAAM;cACR,IAAI8C,eAAerD;cAAA,4CAEEqC,WAAW;gBAAA;cAAA;gBAArB,uDAAyB;kBAAA,IAAzBiB;kBACTD,eAAeC,OAAOtD,KAAK;gBAC7B;cAAA;gBAAA;cAAA;gBAAA;cAAA;cAEO;YAAA,CACR,GACDmD;cAAA,uEAAU,kBAAOE;gBAAA;kBAAA;oBAAA;sBAAA;wBACftB,WAAWb,YAAYI,GAAG;wBAAA;wBAAA,OAEpBtB,MAAMhB,YAAYC,cAAcM,KAAK,eAAeS,KAAK;sBAAA;wBAAA,kCACxDqD;sBAAA;sBAAA;wBAAA;oBAAA;kBAAA;gBAAA;cAAA,CACR;cAAA;gBAAA;cAAA;YAAA,IACH;YAAA,kCAEO3B,eACL1B,MAAMhB,YAAYkB,cAAcyB,KAC9BwB,UAAU,UAACI;cAAA,OACTA,iBAAiB,YACbC,GAAG,MAAS,EAAE7B,KAAKuB,eAAe,IAClCM,GAAGxD,KAAK,CACd;YAAA,EACF,CACF;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACF;EAAA,gBAnFaoC;IAAA;EAAA;AAAA,GAmFb;AAEa;EAAA,uEAAS,kBAAOpC;IAAA;MAAA;QAAA;UAAA;YACrBA,kBAAYE,cAAc2B,KAAK,UAAU;YAAA;YAAA,OAEzCM,gBAAgBnC,MAAMhB,YAAYkC,UAAU;UAAA;YAElDuC,QAAQC,IAAI,YAAY;YAElB1D,kBAAYE,cAAc2B,KAAK,SAAS;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAChD;EAAA,gBARa8B;IAAA;EAAA;AAAA,GAQb;AChHA,IAAMC;EAAA,wEAA2C;IAAA;IAAA;MAAA;QAAA;UAAA;YAC/CC,0BACAvD;YAAA,sBASIuD,QANFtF,YAAiCuF,6CAAnBtF,mBAA2CuF,uEAMvDF,QALF7E,aACqBgF,+CAAnBxF,mBACA0C,8CACAqB;YAIA,KAACuB,uBAAuBvC,SAAS;cACnCxB,kBAAkB8D,SAAS;gBAAA,OAAM7B,KAAKC,UAAU3B,OAAO,CAAC;cAAA;YAC1D;YAAA,MAEIwD,uBAAuBvC,WAAWyC,wBAAwBzC;cAAA;cAAA;YAAA;YAAA,MAE1DuC,uBAAuBvC,QAAQH,OAAO4C,wBAAwBzC,QAAQH;cAAA;cAAA;YAAA;YAAA,MAGhE,IAAI3C,MACR,uFACF;UAAA;YAAA,IAMCqF,uBAAuBvC;cAAA;cAAA;YAAA;YAAA;YAAA,OACdO,WAAWZ,YAAY;cACjC8B,MAAM;cACN1C,SAASA,QAAQC,IAAI,UAACC;gBAAA,OAAMA,EAAEyD,OAAO;cAAA;YAAA,CACtC;UAAA;YAHK3C;UAAA;YAMF4C,WAAW;cACfR,KAAK;gBACHS,UAAUC,QAAQL,YAAW;gBAC7BM,eAAe,6BAAuB9C,YAAvB,mBAAgCH;cACjD;YAAA;YAAA;YAAA;YAAA,OAIqBmB,UAAU+B,YAC7BjE,cAAcC,QAAQC,IAAI,UAACC;cAAA,OAAMA,EAAEyD,OAAO;YAAA,EAAC,GAC3CC,QACF;UAAA;YAHMxD;YAAA,kCAKC;cAAEmD;cAASnD;cAAQJ;YAAA;UAAA;YAAA;YAE1B,IAAIgB,KAAK;cACPS,WAAWb,YAAYI,GAAG;YAC5B;YAAA;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAEJ;EAAA,gBAxDMsC;IAAA;EAAA;AAAA,GAwDN;AAEa;EAAA,wEAAa,kBACxB5D,OACAM;IAAA;IAAA;MAAA;QAAA;UAAA;YAEMiE,cAAoC,6BACrCvE,MAAMzB,WAAW+D,sBACpBsB,uBACAY,SAAQ;YAEN9E,SAAiC,gBAACD;cAAA,OAASgF,QAAQC,QAAQjF,IAAI;YAAA;YAAA,wCAE1C8E;YAAA;cAAA;gBAAA,IAAdI;gBACT,IAAMC,cAAclF;gBAEXA,yBAACD;kBAAA,OACRkF,2CAAgBlF;oBAAMoC,MAAM+C;kBAAA,GAAa;gBAAA;cAAA;cAJ7C,uDAAsC;gBAAA;cAKtC;YAAA;cAAA;YAAA;cAAA;YAAA;YAAA;YAAA,OAGQlF,OAAO;cACXmE,SAAS7D;cACTU,QAAQ,EAAC;cACTJ,SAASA,QAAQC,IAAI,UAACC;gBAAA,OAAMA,EAAEyD,OAAO;cAAA;YACtC;UAAA;YAAA,iDACDvD;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACJ;EAAA,gBAzBamE;IAAA;EAAA;AAAA,GAyBb;AAEa;EAAA,wEAAW,mBACtB7E,OACA8E;IAAA;MAAA;QAAA;UAAA;YAAA;YAAA,OAEcD,WAAc7E,OAAO,CAAC8E,KAAK,CAAC;UAAA;YAAA,gCAAG;YAAA;cAAA;cAAA;YAAA;YAAA,gBAAM;UAAA;YAAA;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACrD;EAAA,gBALaC;IAAA;EAAA;AAAA,GAKb;ACnGa,kBAAc,SAAdC,YACXhF,OACA1B,MACM;EACN,OAAOA,qCACF0B;IACHzB,4CAAiByB,MAAMzB;MAAYyG,aAAa;IAAA;EAAK,GACtD;AACH;AAEa,wBAAoB,SAApBC,kBAAqBjF,OAA8B;EACvD,uCAAKA;IAAOzB,4CAAiByB,MAAMzB;MAAYyG,aAAa;IAAA;EAAA;AACrE;ACRA,IAAME;EAAA,wEAAuB,mBAC3BlF,OACAmF,iBACA7G;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA,SASI0B,OAN+B8D,gCAAjCvF,WAAcC,gDACdQ,aACqBgF,8CAAnBxF,mBACAS,mDACAsD;YAAA,MAMAuB,uBAAuBvC,WAAWyC,wBAAwBzC;cAAA;cAAA;YAAA;YAAA,MAE1DuC,uBAAuBvC,QAAQH,OAAO4C,wBAAwBzC,QAAQH;cAAA;cAAA;YAAA;YAAA,MAGhE,IAAI3C,MACR,uFACF;UAAA;YAAA;YAAA,OAIWH,KAAK0B,KAAK;UAAA;YAAA;UAAA;YAGPD,yBAAO;cAAA,OAAM,aAAa;YAAA;YAEtCjB,cAA4B;cAChCsC,IAAIC;YAAO;YAGLrB,wCACHA;cACHzB,4CACKyB,MAAMzB;gBACTC,mBAAmB;kBAAE+C,SAASzC;gBAAY;cAAA;YAC5C;YAAA;YAAA,OAGgBgD,WAAW9B,MAAMhB,YAAYkC,YAAY;cACzD8B,MAAM;cACNlE;YAAA,CACD;UAAA;YAHKwC;YAKA4C,WAAW;cACfR,KAAK;gBACHS,UAAUC,QAAQpE,MAAMzB,WAAWyG,WAAW;gBAC9CX,eAAevF,YAAYsC;cAC7B;YAAA;YAAA;YAIA4C,wBAAwBzC,UAAUzC;YAAA;YAAA,OAE5BG,cAAcM,KAAK,wBAAwBS,OAAOlB,WAAW;UAAA;YAAA;YAAA,OAE7DyD,UAAU+B,YACdjE,cAAc,CAAC+E,gGAAYA,IAAIC,IAAIF,eAAe,GAAiB,GACnEjB,QACF;UAAA;YAAA;YAAA,OAEMjF,cAAcM,KAAK,sBAAsBS,OAAOlB,WAAW;UAAA;YAAA;YAAA;YAAA,OAG7CR,KAAK0B,KAAK;UAAA;YAAtBsF;YAAA;YAAA,OAEArG,cAAcM,KAAK,yBAAyBS,OAAOlB,WAAW;UAAA;YAAA;YAAA,OAE9DyD,UAAU+B,YAAYjE,cAAc,CAAC+E,iFAAY,GAAGlB,QAAQ;UAAA;YAAA;YAAA,OAE5DjF,cAAcM,KAAK,wBAAwBS,OAAOlB,WAAW;UAAA;YAAA,mCAE5DwG;UAAA;YAAA;YAAA;YAEC7B,cAAM,sCAAyB;YAAA;YAAA,OAEjCxE,cAAcM,KAAK,2BAA2BS,OAAOlB,WAAW;UAAA;YAAA;YAAA,OAEhEyD,UAAU+B,YAAYjE,cAAc,CAAC+E,mFAAc,GAAGlB,QAAQ;UAAA;YAAA;YAAA,OAE9DjF,cAAcM,KAAK,yBAAyBS,OAAOlB,WAAW;UAAA;YAAA;UAAA;YAAA;YAK3DiD,iBAAM/C,YAAYkC,YAAYI,GAAG;YAAA;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAEhD;EAAA,gBA5FM4D;IAAA;EAAA;AAAA,GA4FN;AAGO,IAAMK,2BAA2B,SAA3BA,yBACXvF,OACA1B;EAAA,OACG4G,qBAAqBlF,OAAO,YAAY1B,IAAI;AAAA;AAC1C,IAAMkH,4BAA4B,SAA5BA,0BACXxF,OACA1B;EAAA,OACG4G,qBAAqBlF,OAAO,aAAa1B,IAAI;AAAA;AAC3C,IAAMmH,4BAA4B,SAA5BA,0BACXzF,OACA1B;EAAA,OACG4G,qBAAqBlF,OAAO,aAAa1B,IAAI;AAAA;AAE3C,IAAMoH,mBAAmB,SAAnBA,iBACX1F,OACA1B;EAAA,OACGiH,yBAAyBvF,OAAO1B,IAAI;AAAA","names":["runAfterTransaction","db","func","localState","transactionsState","Error","unsubscribes","listener","event","db2","transaction","unsubscribe","sharedState","eventsEmitter","on","runAfterTransactionCommitted","ev","runAfterTransactionRollbacked","events","emit","all","args","toCall","cb","push","filter","i","assureDbIsRunning","state","toStart","runningState$","dbName","value","unwrapQueries","queries","map","q","preparedQuery","result","characters","charactersLength","length","charAt","Math","floor","random","jobsState$","_job","id","makeId","job","current","queue","promise","firstValueFrom","pipe","current2","next","acquireJob","releaseJob","JSON","stringify","slice","whenAllJobsDone","initDbClient","plugins","queriesMiddlewares","dbBackend","BehaviorSubject","dbBackendCalled","stopped$","e","take","clientId","stopStarted$","createNanoEvents","type","name","initializerPipe","switchMap","initialize","currentState","plugin","runningState","of","console","log","stopDb","runQueriesMiddleware","dbState","transactionsLocalState","suppressLog2","transactionsSharedState","toSql","execOpts","suppress","Boolean","transactionId","execQueries","middlewares","reverse","Promise","resolve","middleware","currentCall","runQueries","query","runQuery","suppressLog","withSuppressedLog","runInTransactionFunc","transactionType","sql","raw","res","runInDeferredTransaction","runInImmediateTransaction","runInExclusiveTransaction","runInTransaction"],"sources":["../src/afterTransaction.ts","../src/createNanoEvents.ts","../src/utils.ts","../src/job.ts","../src/initDb.ts","../src/runQueries.ts","../src/suppressLog.ts","../src/transaction.ts"],"sourcesContent":["import { IDbState, ITransaction } from \"./types\";\n\nconst runAfterTransaction = (\n  db: IDbState,\n  func: (\n    event: \"committed\" | \"rollbacked\",\n    db: IDbState,\n    transaction: ITransaction\n  ) => void\n) => {\n  if (!db.localState.transactionsState) {\n    throw new Error(\"Not in transaction.\");\n  }\n\n  const unsubscribes: (() => void)[] = [];\n\n  const listener =\n    (event: \"committed\" | \"rollbacked\") =>\n    (db: IDbState, transaction: ITransaction) => {\n      func(event, db, transaction);\n\n      for (const unsubscribe of unsubscribes) {\n        unsubscribe();\n      }\n    };\n\n  unsubscribes.push(\n    db.sharedState.eventsEmitter.on(\n      \"transactionCommitted\",\n      listener(\"committed\")\n    )\n  );\n\n  unsubscribes.push(\n    db.sharedState.eventsEmitter.on(\n      \"transactionRollbacked\",\n      listener(\"rollbacked\")\n    )\n  );\n};\n\nexport const runAfterTransactionCommitted = (\n  db: IDbState,\n  func: (db: IDbState, transaction: ITransaction) => void\n) => {\n  runAfterTransaction(db, (ev, db, transaction) => {\n    if (ev === \"committed\") {\n      func(db, transaction);\n    }\n  });\n};\n\nexport const runAfterTransactionRollbacked = (\n  db: IDbState,\n  func: (db: IDbState, transaction: ITransaction) => void\n) => {\n  runAfterTransaction(db, (ev, db, transaction) => {\n    if (ev === \"rollbacked\") {\n      func(db, transaction);\n    }\n  });\n};\n","// Adopted from https://github.com/ai/nanoevents/blob/main/index.js\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type EventsMap<K extends keyof any> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [P in K]: (...args: any[]) => Promise<void> | void;\n};\n\n// Adopted from https://github.com/ai/nanoevents\n// I didn't use original due to lack of cjs support\n\nexport function createNanoEvents<Events extends EventsMap<keyof Events>>() {\n  const events: Partial<{ [E in keyof Events]: Events[E][] }> = {};\n\n  return {\n    async emit<K extends keyof Events>(\n      event: K,\n      ...args: Parameters<Events[K]>\n    ) {\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n      const all = (events[event] || []) as Events[K][];\n      for (const toCall of all) {\n        await toCall(...args);\n      }\n    },\n    on<K extends keyof Events>(event: K, cb: Events[K]): () => void {\n      ((events[event] = events[event] || []) as Events[K][]).push(cb);\n\n      return () => {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        events[event] = ((events[event] || []) as Events[K][]).filter(\n          (i: unknown) => i !== cb\n        ) as Events[K][];\n      };\n    },\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type INanoEmitter<T extends EventsMap<keyof T>> = ReturnType<\n  typeof createNanoEvents\n>;\n","import { ISql } from \"@kikko-land/sql\";\n\nimport { IDbState, IQuery } from \"./types\";\n\nexport const assureDbIsRunning = (state: IDbState, toStart: () => string) => {\n  const {\n    sharedState: { runningState$, dbName },\n  } = state;\n\n  if (runningState$.value !== \"running\") {\n    throw new Error(`Failed to start ${toStart()}, db ${dbName} is stopping`);\n  }\n};\n\nexport const unwrapQueries = (queries: ISql[]): IQuery[] => {\n  return queries.map((q) => q.preparedQuery);\n};\n\nexport function makeId() {\n  let result = \"\";\n  const characters =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  const charactersLength = characters.length;\n  for (let i = 0; i < 32; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n\n  return result;\n}\n","import { ISql } from \"@kikko-land/sql\";\nimport { BehaviorSubject, filter, firstValueFrom } from \"rxjs\";\nimport { DeepReadonly } from \"ts-essentials\";\n\nimport { ITransaction } from \"./types\";\nimport { makeId } from \"./utils\";\n\nexport type DistributiveOmit<\n  T,\n  K extends keyof Record<string, unknown>\n> = T extends unknown ? Omit<T, K> : never;\n\nexport type IJob =\n  | { type: \"runTransaction\"; id: string; transaction: ITransaction }\n  | { type: \"runQueries\"; queries: ISql[]; id: string }\n  | { type: \"initDb\"; name: string; id: string };\n\nexport type IJobsState = DeepReadonly<{\n  queue: IJob[];\n  current?: IJob;\n}>;\n\n// Actually it works like locking mechanism\nexport const acquireJob = async (\n  jobsState$: BehaviorSubject<IJobsState>,\n  _job: DistributiveOmit<IJob, \"id\">\n): Promise<IJob> => {\n  const id = makeId();\n  const job = { ..._job, id };\n\n  const { current, queue } = jobsState$.value;\n\n  if (current || queue.length > 0) {\n    const promise = firstValueFrom(\n      jobsState$.pipe(filter(({ current }) => current?.id === id))\n    );\n\n    jobsState$.next({ queue: [...queue, job], current });\n\n    await promise;\n  } else {\n    jobsState$.next({ queue: [], current: job });\n  }\n\n  return job;\n};\n\nexport const releaseJob = (\n  jobsState$: BehaviorSubject<IJobsState>,\n  job: IJob\n) => {\n  const { current, queue } = jobsState$.value;\n\n  if (current?.id !== job.id) {\n    throw new Error(\n      `Can't release job that is not currently running, current: ${JSON.stringify(\n        current\n      )}, queue: ${JSON.stringify(queue)}, toRelease: ${JSON.stringify(job)}`\n    );\n  }\n\n  jobsState$.next({ queue: queue.slice(1), current: queue[0] });\n};\n\nexport const whenAllJobsDone = async (\n  jobsState$: BehaviorSubject<IJobsState>\n) => {\n  return firstValueFrom(\n    jobsState$.pipe(filter(({ queue }) => queue.length === 0))\n  );\n};\n","import {\n  BehaviorSubject,\n  filter,\n  firstValueFrom,\n  map,\n  of,\n  pipe,\n  switchMap,\n  take,\n} from \"rxjs\";\n\nimport { createNanoEvents } from \"./createNanoEvents\";\nimport { acquireJob, IJobsState, releaseJob, whenAllJobsDone } from \"./job\";\nimport {\n  IDbBackend,\n  IDbState,\n  IKikkoEvents,\n  IQueriesMiddleware,\n} from \"./types\";\nimport { makeId } from \"./utils\";\n\nexport type IDbClientPlugin = (state: IDbState) => IDbState;\n\nexport type IInitDbClientConfig = {\n  dbName: string;\n  dbBackend: Promise<IDbBackend> | IDbBackend;\n  plugins?: IDbClientPlugin[];\n  queriesMiddlewares?: IQueriesMiddleware[];\n};\n\nexport const initDbClient = async ({\n  dbName,\n  plugins,\n  queriesMiddlewares,\n  dbBackend,\n}: IInitDbClientConfig): Promise<IDbState> => {\n  const runningState$ = new BehaviorSubject<\"running\" | \"stopping\" | \"stopped\">(\n    \"running\"\n  );\n\n  const dbBackendCalled = (await dbBackend)({\n    dbName,\n    stopped$: runningState$.pipe(\n      filter((e) => e === \"stopped\"),\n      map(() => undefined as void),\n      take(1)\n    ),\n  });\n\n  const jobsState$ = new BehaviorSubject<IJobsState>({\n    queue: [],\n    current: undefined,\n  });\n\n  const state: IDbState = {\n    sharedState: {\n      clientId: makeId(),\n      dbBackend: dbBackendCalled,\n      dbName,\n\n      runningState$,\n      stopStarted$: runningState$.pipe(\n        filter((e) => e === \"stopping\"),\n        map(() => undefined as void),\n        take(1)\n      ),\n\n      eventsEmitter: createNanoEvents<IKikkoEvents>(),\n\n      jobsState$,\n      transactionsState: {},\n    },\n    localState: {\n      queriesMiddlewares: queriesMiddlewares || [],\n      transactionsState: {},\n    },\n  };\n\n  const job = await acquireJob(state.sharedState.jobsState$, {\n    type: \"initDb\",\n    name: dbName,\n  });\n\n  const initializerPipe = pipe(\n    switchMap(async () => {\n      await dbBackendCalled.initialize();\n    }),\n    map(() => {\n      let currentState = state;\n\n      for (const plugin of plugins || []) {\n        currentState = plugin(state);\n      }\n\n      return currentState;\n    }),\n    switchMap(async (currentState) => {\n      releaseJob(jobsState$, job);\n\n      await state.sharedState.eventsEmitter.emit(\"initialized\", state);\n      return currentState;\n    })\n  );\n\n  return firstValueFrom(\n    state.sharedState.runningState$.pipe(\n      switchMap((runningState) =>\n        runningState === \"running\"\n          ? of(undefined).pipe(initializerPipe)\n          : of(state)\n      )\n    )\n  );\n};\n\nexport const stopDb = async (state: IDbState) => {\n  state.sharedState.runningState$.next(\"stopping\");\n\n  await whenAllJobsDone(state.sharedState.jobsState$);\n\n  console.log(\"stopped db\");\n\n  state.sharedState.runningState$.next(\"stopped\");\n};\n","import { ISqlAdapter } from \"@kikko-land/sql\";\n\nimport { acquireJob, IJob, releaseJob } from \"./job\";\nimport {\n  IDbState,\n  INextQueriesMiddleware,\n  IQueriesMiddleware,\n  IQueriesMiddlewareState,\n} from \"./types\";\nimport { assureDbIsRunning, unwrapQueries } from \"./utils\";\n\nconst runQueriesMiddleware: IQueriesMiddleware = async ({\n  dbState,\n  queries,\n}) => {\n  const {\n    localState: { transactionsState: transactionsLocalState, suppressLog },\n    sharedState: {\n      transactionsState: transactionsSharedState,\n      jobsState$,\n      dbBackend,\n    },\n  } = dbState;\n\n  if (!transactionsLocalState.current) {\n    assureDbIsRunning(dbState, () => JSON.stringify(queries));\n  }\n\n  if (transactionsLocalState.current && transactionsSharedState.current) {\n    if (\n      transactionsLocalState.current.id !== transactionsSharedState.current.id\n    ) {\n      // Is it possible?\n      throw new Error(\n        \"Internal error: local running transaction is not the same as shared state transaction\"\n      );\n    }\n  }\n\n  let job: IJob | undefined;\n\n  if (!transactionsLocalState.current) {\n    job = await acquireJob(jobsState$, {\n      type: \"runQueries\",\n      queries: queries.map((q) => q.toSql()),\n    });\n  }\n\n  const execOpts = {\n    log: {\n      suppress: Boolean(suppressLog),\n      transactionId: transactionsLocalState.current?.id,\n    },\n  };\n\n  try {\n    const result = await dbBackend.execQueries(\n      unwrapQueries(queries.map((q) => q.toSql())),\n      execOpts\n    );\n\n    return { dbState, result, queries };\n  } finally {\n    if (job) {\n      releaseJob(jobsState$, job);\n    }\n  }\n};\n\nexport const runQueries = async <D extends Record<string, unknown>>(\n  state: IDbState,\n  queries: ISqlAdapter[]\n): Promise<D[][]> => {\n  const middlewares: IQueriesMiddleware[] = [\n    ...state.localState.queriesMiddlewares,\n    runQueriesMiddleware,\n  ].reverse();\n\n  let toCall: INextQueriesMiddleware = (args) => Promise.resolve(args);\n\n  for (const middleware of middlewares) {\n    const currentCall = toCall;\n\n    toCall = (args: IQueriesMiddlewareState) =>\n      middleware({ ...args, next: currentCall });\n  }\n\n  return (\n    await toCall({\n      dbState: state,\n      result: [],\n      queries: queries.map((q) => q.toSql()),\n    })\n  ).result as D[][];\n};\n\nexport const runQuery = async <D extends Record<string, unknown>>(\n  state: IDbState,\n  query: ISqlAdapter\n) => {\n  return (await runQueries<D>(state, [query]))[0] || [];\n};\n","import { IDbState } from \"./types\";\n\nexport const suppressLog = <T>(\n  state: IDbState,\n  func: (state: IDbState) => T\n): T => {\n  return func({\n    ...state,\n    localState: { ...state.localState, suppressLog: true },\n  });\n};\n\nexport const withSuppressedLog = (state: IDbState): IDbState => {\n  return { ...state, localState: { ...state.localState, suppressLog: true } };\n};\n","import { sql } from \"@kikko-land/sql\";\n\nimport { acquireJob, releaseJob } from \"./job\";\nimport { IDbState, ITransaction } from \"./types\";\nimport { assureDbIsRunning, makeId, unwrapQueries } from \"./utils\";\n\nconst runInTransactionFunc = async <T>(\n  state: IDbState,\n  transactionType: \"DEFERRED\" | \"IMMEDIATE\" | \"EXCLUSIVE\",\n  func: (state: IDbState) => Promise<T>\n) => {\n  const {\n    localState: { transactionsState: transactionsLocalState },\n    sharedState: {\n      transactionsState: transactionsSharedState,\n      eventsEmitter,\n      dbBackend,\n    },\n  } = state;\n\n  // It's indeed that function in same transaction don't need to check db is running\n  // Cause all transaction will await to execute on DB before stop\n  if (transactionsLocalState.current && transactionsSharedState.current) {\n    if (\n      transactionsLocalState.current.id !== transactionsSharedState.current.id\n    ) {\n      // Is it possible?\n      throw new Error(\n        \"Internal error: local running transaction is not the same as shared state transaction\"\n      );\n    }\n\n    // we already in same transaction\n    return await func(state);\n  }\n\n  assureDbIsRunning(state, () => \"transaction\");\n\n  const transaction: ITransaction = {\n    id: makeId(),\n  };\n\n  state = {\n    ...state,\n    localState: {\n      ...state.localState,\n      transactionsState: { current: transaction },\n    },\n  };\n\n  const job = await acquireJob(state.sharedState.jobsState$, {\n    type: \"runTransaction\",\n    transaction,\n  });\n\n  const execOpts = {\n    log: {\n      suppress: Boolean(state.localState.suppressLog),\n      transactionId: transaction.id,\n    },\n  };\n\n  try {\n    transactionsSharedState.current = transaction;\n\n    await eventsEmitter.emit(\"transactionWillStart\", state, transaction);\n\n    await dbBackend.execQueries(\n      unwrapQueries([sql`BEGIN ${sql.raw(transactionType)} TRANSACTION;`]),\n      execOpts\n    );\n\n    await eventsEmitter.emit(\"transactionStarted\", state, transaction);\n\n    try {\n      const res = await func(state);\n\n      await eventsEmitter.emit(\"transactionWillCommit\", state, transaction);\n\n      await dbBackend.execQueries(unwrapQueries([sql`COMMIT`]), execOpts);\n\n      await eventsEmitter.emit(\"transactionCommitted\", state, transaction);\n\n      return res;\n    } catch (e) {\n      console.error(\"Rollback transaction\", e);\n\n      await eventsEmitter.emit(\"transactionWillRollback\", state, transaction);\n\n      await dbBackend.execQueries(unwrapQueries([sql`ROLLBACK`]), execOpts);\n\n      await eventsEmitter.emit(\"transactionRollbacked\", state, transaction);\n\n      throw e;\n    }\n  } finally {\n    releaseJob(state.sharedState.jobsState$, job);\n  }\n};\n\n// By default it is deferred\nexport const runInDeferredTransaction = <T>(\n  state: IDbState,\n  func: (state: IDbState) => Promise<T>\n) => runInTransactionFunc(state, \"DEFERRED\", func);\nexport const runInImmediateTransaction = <T>(\n  state: IDbState,\n  func: (state: IDbState) => Promise<T>\n) => runInTransactionFunc(state, \"IMMEDIATE\", func);\nexport const runInExclusiveTransaction = <T>(\n  state: IDbState,\n  func: (state: IDbState) => Promise<T>\n) => runInTransactionFunc(state, \"EXCLUSIVE\", func);\n\nexport const runInTransaction = <T>(\n  state: IDbState,\n  func: (state: IDbState) => Promise<T>\n) => runInDeferredTransaction(state, func);\n"]},"metadata":{},"sourceType":"module"}