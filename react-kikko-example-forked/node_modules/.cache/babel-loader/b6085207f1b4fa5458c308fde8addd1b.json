{"ast":null,"code":"import _objectSpread from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { runQueries } from \"@kikko-land/kikko\";\nimport { switchMap, Observable, filter, startWith, takeUntil, share, ReplaySubject, firstValueFrom } from \"rxjs\";\nvar getReactiveState = function getReactiveState(state) {\n  var reactiveState = state.sharedState.reactiveQueriesState;\n  if (!reactiveState) {\n    throw new Error(\"Internal error, maybe you forget to connect the 'reactiveQueries' plugin?\");\n  }\n  return reactiveState;\n};\nvar listenQueries = function listenQueries(db, queries) {\n  var _getReactiveState = getReactiveState(db),\n    eventsCh$ = _getReactiveState.eventsCh$;\n  var readingTables = new Set(queries.map(function (q) {\n    return q.toSql();\n  }).flatMap(function (q) {\n    return q.tables;\n  }).map(function (t) {\n    return t.name;\n  }));\n  return eventsCh$.pipe(switchMap(function (ch) {\n    return new Observable(function (subscriber) {\n      var func = function func(data) {\n        subscriber.next(data);\n      };\n      ch.addEventListener(func);\n      return function () {\n        ch.removeEventListener(func);\n      };\n    });\n  }), filter(function (_ref) {\n    var changesInTables = _ref.changesInTables;\n    return changesInTables.some(function (table) {\n      return readingTables.has(table);\n    });\n  }), startWith(void 0), switchMap( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", runQueries(db, queries));\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }))), takeUntil(db.sharedState.stopStarted$));\n};\nvar createMultiTabChannel = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(name, webMultiTabSupport) {\n    var webChannel, listeners;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n              return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                while (1) {\n                  switch (_context2.prev = _context2.next) {\n                    case 0:\n                      if (webMultiTabSupport) {\n                        _context2.next = 2;\n                        break;\n                      }\n                      return _context2.abrupt(\"return\", void 0);\n                    case 2:\n                      _context2.next = 4;\n                      return import(\"broadcast-channel\");\n                    case 4:\n                      _context2.t0 = _context2.sent.BroadcastChannel;\n                      _context2.t1 = name;\n                      _context2.t2 = {\n                        type: \"localstorage\",\n                        webWorkerSupport: false\n                      };\n                      return _context2.abrupt(\"return\", new _context2.t0(_context2.t1, _context2.t2));\n                    case 8:\n                    case \"end\":\n                      return _context2.stop();\n                  }\n                }\n              }, _callee2);\n            }))();\n          case 2:\n            webChannel = _context5.sent;\n            listeners = [];\n            return _context5.abrupt(\"return\", {\n              postMessage: function postMessage(data) {\n                return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          listeners.forEach(function (l) {\n                            l(data);\n                          });\n                          if (!webChannel) {\n                            _context3.next = 4;\n                            break;\n                          }\n                          _context3.next = 4;\n                          return webChannel.postMessage(data);\n                        case 4:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _callee3);\n                }))();\n              },\n              addEventListener: function addEventListener(cb) {\n                listeners.push(cb);\n                webChannel == null ? void 0 : webChannel.addEventListener(\"message\", cb);\n              },\n              removeEventListener: function removeEventListener(cb) {\n                listeners = listeners.filter(function (l) {\n                  return l !== cb;\n                });\n                webChannel == null ? void 0 : webChannel.removeEventListener(\"message\", cb);\n              },\n              close: function close() {\n                return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          listeners = [];\n                          if (!webChannel) {\n                            _context4.next = 4;\n                            break;\n                          }\n                          _context4.next = 4;\n                          return webChannel.close();\n                        case 4:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _callee4);\n                }))();\n              }\n            });\n          case 5:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return function createMultiTabChannel(_x, _x2) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nvar getBroadcastCh = function getBroadcastCh(name, webMultiTabSupport, stop$) {\n  return new Observable(function (sub) {\n    var isClosed = false;\n    var currentChannel;\n    var init = /*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var ch;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return createMultiTabChannel(name, webMultiTabSupport);\n              case 2:\n                ch = _context6.sent;\n                if (!isClosed) {\n                  _context6.next = 5;\n                  break;\n                }\n                return _context6.abrupt(\"return\");\n              case 5:\n                sub.next(ch);\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n      return function init() {\n        return _ref5.apply(this, arguments);\n      };\n    }();\n    void init();\n    return function () {\n      isClosed = true;\n      void (currentChannel == null ? void 0 : currentChannel.close());\n    };\n  }).pipe(share({\n    connector: function connector() {\n      return new ReplaySubject(1);\n    }\n  }), takeUntil(stop$));\n};\nvar notifyTablesContentChanged = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(state, tables) {\n    var reactiveState;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            if (!(tables.length === 0)) {\n              _context8.next = 2;\n              break;\n            }\n            return _context8.abrupt(\"return\");\n          case 2:\n            reactiveState = getReactiveState(state);\n            return _context8.abrupt(\"return\", firstValueFrom(reactiveState.eventsCh$.pipe(switchMap( /*#__PURE__*/function () {\n              var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(ch) {\n                return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n                  while (1) {\n                    switch (_context7.prev = _context7.next) {\n                      case 0:\n                        _context7.next = 2;\n                        return ch.postMessage({\n                          changesInTables: tables\n                        });\n                      case 2:\n                      case \"end\":\n                        return _context7.stop();\n                    }\n                  }\n                }, _callee7);\n              }));\n              return function (_x5) {\n                return _ref7.apply(this, arguments);\n              };\n            }()))));\n          case 4:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return function notifyTablesContentChanged(_x3, _x4) {\n    return _ref6.apply(this, arguments);\n  };\n}();\nvar reactiveQueriesPlugin = function reactiveQueriesPlugin(opts) {\n  return function (db) {\n    var transactionTables = {};\n    var _db$sharedState = db.sharedState,\n      dbName = _db$sharedState.dbName,\n      eventsEmitter = _db$sharedState.eventsEmitter,\n      stopStarted$ = _db$sharedState.stopStarted$;\n    var webMultiTabSupport = (opts == null ? void 0 : opts.webMultiTabSupport) !== void 0 ? opts.webMultiTabSupport : true;\n    var reactiveQueriesMiddleware = function reactiveQueriesMiddleware(state) {\n      var transaction = state.dbState.localState.transactionsState.current;\n      var writeTables = state.queries.map(function (q) {\n        return q.toSql();\n      }).filter(function (q) {\n        return q.isModifyQuery;\n      }).flatMap(function (q) {\n        return q.tables;\n      }).flatMap(function (def) {\n        return [def.name].concat(_toConsumableArray(def.dependsOnTables.map(function (_ref8) {\n          var name = _ref8.name;\n          return name;\n        })));\n      });\n      if (writeTables.length !== 0) {\n        if (transaction) {\n          if (!transactionTables[transaction.id]) {\n            throw new Error(\"Internal error: records with transactionId key was not created\");\n          }\n          var _iterator = _createForOfIteratorHelper(writeTables),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var t = _step.value;\n              transactionTables[transaction.id].writeTables.add(t);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } else {\n          void notifyTablesContentChanged(state.dbState, writeTables);\n        }\n      }\n      return state.next(state);\n    };\n    eventsEmitter.on(\"transactionWillStart\", function (_db, transaction) {\n      transactionTables[transaction.id] = {\n        writeTables: /* @__PURE__ */new Set()\n      };\n    });\n    eventsEmitter.on(\"transactionRollbacked\", function (_db, transaction) {\n      delete transactionTables[transaction.id];\n    });\n    eventsEmitter.on(\"transactionCommitted\", function (db2, transaction) {\n      if (!transactionTables[transaction.id]) {\n        throw new Error(\"Internal error: records with transactionId key was not created\");\n      }\n      void notifyTablesContentChanged(db2, _toConsumableArray(Array.from(transactionTables[transaction.id].writeTables)));\n      delete transactionTables[transaction.id];\n    });\n    db.sharedState.reactiveQueriesState = {\n      eventsCh$: getBroadcastCh(dbName + \"-reactiveQueriesPlugin\", webMultiTabSupport, stopStarted$)\n    };\n    return _objectSpread(_objectSpread({}, db), {}, {\n      localState: _objectSpread(_objectSpread({}, db.localState), {}, {\n        queriesMiddlewares: [].concat(_toConsumableArray(db.localState.queriesMiddlewares), [reactiveQueriesMiddleware])\n      })\n    });\n  };\n};\nexport { listenQueries, reactiveQueriesPlugin };","map":{"version":3,"mappings":"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","names":["getReactiveState","state","sharedState","reactiveQueriesState","reactiveState","Error","listenQueries","db","queries","eventsCh$","Set","map","q","toSql","flatMap","tables","t","name","pipe","switchMap","ch","Observable","subscriber","func","data","next","addEventListener","removeEventListener","filter","changesInTables","some","table","readingTables","has","startWith","runQueries","takeUntil","stopStarted$","createMultiTabChannel","webMultiTabSupport","BroadcastChannel","type","webWorkerSupport","webChannel","listeners","postMessage","l","cb","push","close","getBroadcastCh","stop$","sub","isClosed","init","currentChannel","share","connector","ReplaySubject","notifyTablesContentChanged","length","firstValueFrom","reactiveQueriesPlugin","opts","transactionTables","dbName","eventsEmitter","reactiveQueriesMiddleware","transaction","dbState","localState","transactionsState","current","isModifyQuery","def","dependsOnTables","id","writeTables","add","on","_db","db2","Array","from","queriesMiddlewares"],"sources":["../src/utils.ts","../src/listenQueries.ts","../src/getBroadcastCh.ts","../src/reactivePlugin.ts"],"sourcesContent":["import { IDbState } from \"@kikko-land/kikko\";\n\nexport const getReactiveState = (state: IDbState) => {\n  const reactiveState = state.sharedState.reactiveQueriesState;\n\n  if (!reactiveState) {\n    throw new Error(\n      \"Internal error, maybe you forget to connect the 'reactiveQueries' plugin?\"\n    );\n  }\n\n  return reactiveState;\n};\n","import { IDbState, runQueries } from \"@kikko-land/kikko\";\nimport { ISqlAdapter } from \"@kikko-land/sql\";\nimport { filter, Observable, startWith, switchMap, takeUntil } from \"rxjs\";\n\nimport { IMessage } from \"./getBroadcastCh\";\nimport { getReactiveState } from \"./utils\";\n\nexport const listenQueries = <D extends Record<string, unknown>>(\n  db: IDbState,\n  queries: ISqlAdapter[]\n): Observable<D[][]> => {\n  const { eventsCh$ } = getReactiveState(db);\n\n  const readingTables = new Set(\n    queries\n      .map((q) => q.toSql())\n      .flatMap((q) => q.tables)\n      .map((t) => t.name)\n  );\n\n  return eventsCh$.pipe(\n    switchMap((ch) => {\n      return new Observable<IMessage>((subscriber) => {\n        const func = (data: IMessage) => {\n          subscriber.next(data);\n        };\n\n        ch.addEventListener(func);\n\n        return () => {\n          ch.removeEventListener(func);\n        };\n      });\n    }),\n    filter(({ changesInTables }) =>\n      changesInTables.some((table) => readingTables.has(table))\n    ),\n    startWith(undefined), // to exec query at start\n    switchMap(async () => {\n      return runQueries<D>(db, queries);\n    }),\n    takeUntil(db.sharedState.stopStarted$)\n  );\n};\n","import { Observable, ReplaySubject, share, takeUntil } from \"rxjs\";\n\nexport type IMessage = { changesInTables: string[] };\nexport type IListener = (msg: IMessage) => void;\nexport interface INotifyChannel {\n  postMessage(msg: IMessage): Promise<void>;\n  addEventListener(cb: IListener): void;\n  removeEventListener(cb: IListener): void;\n  close(): Promise<void>;\n}\n\nconst createMultiTabChannel = async (\n  name: string,\n  webMultiTabSupport: boolean\n): Promise<INotifyChannel> => {\n  const webChannel = await (async () => {\n    if (!webMultiTabSupport) return undefined;\n\n    return new (await import(\"broadcast-channel\")).BroadcastChannel(name, {\n      type: \"localstorage\",\n      webWorkerSupport: false,\n      // idb: {\n      //   onclose: () => {\n      //     // the onclose event is just the IndexedDB closing.\n      //     // you should also close the channel before creating\n      //     // a new one.\n      //     void currentChannel?.close();\n      //     createChannel();\n      //   },\n      // },\n    });\n  })();\n\n  let listeners: IListener[] = [];\n\n  return {\n    async postMessage(data) {\n      listeners.forEach((l) => {\n        l(data);\n      });\n\n      if (webChannel) {\n        await webChannel.postMessage(data);\n      }\n    },\n    addEventListener(cb) {\n      listeners.push(cb);\n\n      webChannel?.addEventListener(\"message\", cb);\n    },\n    removeEventListener(cb) {\n      listeners = listeners.filter((l) => l !== cb);\n\n      webChannel?.removeEventListener(\"message\", cb);\n    },\n    async close() {\n      listeners = [];\n\n      if (webChannel) {\n        await webChannel.close();\n      }\n    },\n  };\n};\n\nexport const getBroadcastCh = (\n  name: string,\n  webMultiTabSupport: boolean,\n  stop$: Observable<void>\n) => {\n  return new Observable<INotifyChannel>((sub) => {\n    let isClosed = false;\n    let currentChannel: INotifyChannel | undefined;\n\n    const init = async () => {\n      const ch = await createMultiTabChannel(name, webMultiTabSupport);\n\n      if (isClosed) return;\n\n      sub.next(ch);\n    };\n\n    void init();\n\n    return () => {\n      isClosed = true;\n      void currentChannel?.close();\n    };\n  }).pipe(\n    share({\n      connector: () => new ReplaySubject(1),\n    }),\n    takeUntil(stop$)\n  );\n};\n","import {\n  IDbClientPlugin,\n  IDbState,\n  IQueriesMiddleware,\n} from \"@kikko-land/kikko\";\nimport { firstValueFrom, switchMap } from \"rxjs\";\n\nimport { getBroadcastCh } from \"./getBroadcastCh\";\nimport { getReactiveState } from \"./utils\";\n\nconst notifyTablesContentChanged = async (\n  state: IDbState,\n  tables: string[]\n) => {\n  if (tables.length === 0) return;\n\n  const reactiveState = getReactiveState(state);\n\n  return firstValueFrom(\n    reactiveState.eventsCh$.pipe(\n      switchMap(async (ch) => {\n        await ch.postMessage({ changesInTables: tables });\n      })\n    )\n  );\n};\n\nexport const reactiveQueriesPlugin: (opts?: {\n  webMultiTabSupport?: boolean;\n}) => IDbClientPlugin = (opts) => (db) => {\n  const transactionTables: Record<string, { writeTables: Set<string> }> = {};\n  const { dbName, eventsEmitter, stopStarted$ } = db.sharedState;\n\n  const webMultiTabSupport =\n    opts?.webMultiTabSupport !== undefined ? opts.webMultiTabSupport : true;\n\n  const reactiveQueriesMiddleware: IQueriesMiddleware = (state) => {\n    const transaction = state.dbState.localState.transactionsState.current;\n\n    const writeTables = state.queries\n      .map((q) => q.toSql())\n      .filter((q) => q.isModifyQuery)\n      .flatMap((q) => q.tables)\n      .flatMap((def) => [\n        def.name,\n        ...def.dependsOnTables.map(({ name }) => name),\n      ]);\n\n    if (writeTables.length !== 0) {\n      if (transaction) {\n        if (!transactionTables[transaction.id]) {\n          throw new Error(\n            \"Internal error: records with transactionId key was not created\"\n          );\n        }\n\n        for (const t of writeTables) {\n          transactionTables[transaction.id].writeTables.add(t);\n        }\n      } else {\n        // dont await so notification happens after function return\n        void notifyTablesContentChanged(state.dbState, writeTables);\n      }\n    }\n\n    return state.next(state);\n  };\n\n  eventsEmitter.on(\"transactionWillStart\", (_db, transaction) => {\n    transactionTables[transaction.id] = { writeTables: new Set() };\n  });\n\n  eventsEmitter.on(\"transactionRollbacked\", (_db, transaction) => {\n    delete transactionTables[transaction.id];\n  });\n\n  eventsEmitter.on(\"transactionCommitted\", (db, transaction) => {\n    if (!transactionTables[transaction.id]) {\n      throw new Error(\n        \"Internal error: records with transactionId key was not created\"\n      );\n    }\n\n    void notifyTablesContentChanged(db, [\n      ...Array.from(transactionTables[transaction.id].writeTables),\n    ]);\n\n    delete transactionTables[transaction.id];\n  });\n\n  db.sharedState.reactiveQueriesState = {\n    eventsCh$: getBroadcastCh(\n      dbName + \"-reactiveQueriesPlugin\",\n      webMultiTabSupport,\n      stopStarted$\n    ),\n  };\n\n  return {\n    ...db,\n    localState: {\n      ...db.localState,\n      queriesMiddlewares: [\n        ...db.localState.queriesMiddlewares,\n        reactiveQueriesMiddleware,\n      ],\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"module"}