{"ast":null,"code":"import _objectSpread from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _taggedTemplateLiteral from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js\";\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20, _templateObject21, _templateObject22, _templateObject23, _templateObject24, _templateObject25, _templateObject26, _templateObject27, _templateObject28, _templateObject29, _templateObject30, _templateObject31, _templateObject32, _templateObject33, _templateObject34, _templateObject35, _templateObject36, _templateObject37, _templateObject38, _templateObject39, _templateObject40, _templateObject41, _templateObject42, _templateObject43, _templateObject44, _templateObject45, _templateObject46, _templateObject47;\nimport { sql as sql$1, isTable } from \"@kikko-land/sql\";\nexport * from \"@kikko-land/sql\";\nvar TokenType = /* @__PURE__ */function (TokenType2) {\n  TokenType2[\"Binary\"] = \"Binary\";\n  TokenType2[\"Unary\"] = \"Unary\";\n  TokenType2[\"Alias\"] = \"Alias\";\n  TokenType2[\"Compound\"] = \"Compound\";\n  TokenType2[\"Select\"] = \"Select\";\n  TokenType2[\"Update\"] = \"Update\";\n  TokenType2[\"Delete\"] = \"Delete\";\n  TokenType2[\"Insert\"] = \"Insert\";\n  TokenType2[\"Values\"] = \"Values\";\n  TokenType2[\"OrderTerm\"] = \"OrderTerm\";\n  TokenType2[\"LimitOffsetTerm\"] = \"LimitOffsetTerm\";\n  TokenType2[\"RawSql\"] = \"RawSql\";\n  TokenType2[\"CompoundOperator\"] = \"CompoundOperator\";\n  TokenType2[\"CTE\"] = \"CTE\";\n  TokenType2[\"Join\"] = \"Join\";\n  TokenType2[\"Returning\"] = \"Returning\";\n  return TokenType2;\n}(TokenType || {});\nvar isToken = function isToken(t) {\n  return t !== null && typeof t === \"object\" && \"type\" in t && \"toSql\" in t && Object.values(TokenType).includes(t.type);\n};\nvar buildRawSql = function buildRawSql(t) {\n  return {\n    type: TokenType.RawSql,\n    toSql: function toSql() {\n      return sql$1(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \"\"])), t);\n    }\n  };\n};\nvar toToken = function toToken(t) {\n  if (isToken(t)) return t;\n  if (sql$1.isSql(t)) {\n    return buildRawSql(t);\n  }\n  return buildRawSql(t);\n};\nvar isBinaryOperator = function isBinaryOperator(t) {\n  return t !== null && typeof t === \"object\" && \"type\" in t && t.type === TokenType.Binary;\n};\nvar binaryOperator = function binaryOperator(operator, left, right) {\n  return {\n    type: TokenType.Binary,\n    _left: toToken(left),\n    _right: Array.isArray(right) ? right.map(toToken) : toToken(right),\n    _operator: operator,\n    toSql: function toSql() {\n      return sql$1(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \" \", \" \", \"\"])), wrapParentheses(this._left), sql$1.raw(this._operator), Array.isArray(this._right) ? sql$1(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"(\", \")\"])), sql$1.join(this._right)) : wrapParentheses(this._right));\n    }\n  };\n};\nvar notEq$ = function notEq$(right) {\n  return function (left) {\n    return notEq(left, right);\n  };\n};\nvar notEq = function notEq(left, right) {\n  return binaryOperator(\"<>\", left, right);\n};\nvar eq$ = function eq$(right) {\n  return function (left) {\n    return eq(left, right);\n  };\n};\nvar eq = function eq(left, right) {\n  return binaryOperator(\"=\", left, right);\n};\nvar gt$ = function gt$(right) {\n  return function (left) {\n    return gt(left, right);\n  };\n};\nvar gt = function gt(left, right) {\n  return binaryOperator(\">\", left, right);\n};\nvar gtEq$ = function gtEq$(right) {\n  return function (left) {\n    return gtEq(left, right);\n  };\n};\nvar gtEq = function gtEq(left, right) {\n  return binaryOperator(\">=\", left, right);\n};\nvar lt$ = function lt$(right) {\n  return function (left) {\n    return lt(left, right);\n  };\n};\nvar lt = function lt(left, right) {\n  return binaryOperator(\"<\", left, right);\n};\nvar ltEq$ = function ltEq$(right) {\n  return function (left) {\n    return ltEq(left, right);\n  };\n};\nvar ltEq = function ltEq(left, right) {\n  return binaryOperator(\"<=\", left, right);\n};\nvar like = function like(left, right) {\n  return binaryOperator(\"LIKE\", left, right);\n};\nvar like$ = function like$(right) {\n  return function (left) {\n    return like(left, right);\n  };\n};\nvar notLike = function notLike(left, right) {\n  return binaryOperator(\"NOT LIKE\", left, right);\n};\nvar notLike$ = function notLike$(right) {\n  return function (left) {\n    return notLike(left, right);\n  };\n};\nvar In = function In(left) {\n  for (var _len = arguments.length, right = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    right[_key - 1] = arguments[_key];\n  }\n  return binaryOperator(\"IN\", left, right);\n};\nvar notIn = function notIn(left) {\n  for (var _len2 = arguments.length, right = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    right[_key2 - 1] = arguments[_key2];\n  }\n  return binaryOperator(\"NOT IN\", left, right);\n};\nvar in$ = function in$() {\n  for (var _len3 = arguments.length, values2 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    values2[_key3] = arguments[_key3];\n  }\n  return function (left) {\n    return In.apply(void 0, [left].concat(values2));\n  };\n};\nvar notIn$ = function notIn$() {\n  for (var _len4 = arguments.length, values2 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    values2[_key4] = arguments[_key4];\n  }\n  return function (left) {\n    return notIn.apply(void 0, [left].concat(values2));\n  };\n};\nvar conditionValuesToToken = function conditionValuesToToken(values2) {\n  return values2.flatMap(function (v) {\n    return isToken(v) || sql$1.isSql(v) ? toToken(v) : Object.entries(v).map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        k = _ref2[0],\n        expr = _ref2[1];\n      return toToken(typeof expr === \"function\" ? expr(sql$1.liter(k)) : eq(sql$1.liter(k), expr));\n    });\n  }).filter(function (v) {\n    return !v.toSql().isEmpty;\n  });\n};\nvar conditionOperator = function conditionOperator(type) {\n  for (var _len5 = arguments.length, values2 = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    values2[_key5 - 1] = arguments[_key5];\n  }\n  var exprs = conditionValuesToToken(values2);\n  if (exprs.length <= 1) {\n    throw new Error(\"Must at least two arguments present\");\n  }\n  var current = binaryOperator(type, exprs[0], exprs[1]);\n  var _iterator = _createForOfIteratorHelper(exprs.slice(2)),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var next = _step.value;\n      current = binaryOperator(type, current, next);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return current;\n};\nvar and = function and() {\n  for (var _len6 = arguments.length, values2 = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    values2[_key6] = arguments[_key6];\n  }\n  return conditionOperator.apply(void 0, [\"AND\"].concat(values2));\n};\nvar or = function or() {\n  for (var _len7 = arguments.length, values2 = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    values2[_key7] = arguments[_key7];\n  }\n  return conditionOperator.apply(void 0, [\"OR\"].concat(values2));\n};\nvar wrapParentheses = function wrapParentheses(val) {\n  return isBinaryOperator(val) && val._operator === \"OR\" || isToken(val) && (val.type === TokenType.Select || val.type === TokenType.Values) ? sql$1(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"(\", \")\"])), val) : val;\n};\nvar alias = function alias(left, right) {\n  return {\n    type: TokenType.Alias,\n    _left: toToken(left),\n    _right: right,\n    toSql: function toSql() {\n      return sql$1(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \" AS \", \"\"])), wrapParentheses(this._left), sql$1.liter(this._right));\n    }\n  };\n};\nvar baseJoin = function baseJoin(operator, toJoin, on) {\n  return {\n    type: TokenType.Join,\n    _operator: operator,\n    _toJoin: function () {\n      if (typeof toJoin === \"string\") {\n        return sql$1.table(toJoin);\n      } else if (isTable(toJoin)) {\n        return toJoin;\n      } else if (isToken(toJoin) || sql$1.isSql(toJoin)) {\n        return toToken(toJoin);\n      } else {\n        var entries = Object.entries(toJoin);\n        if (entries.length === 0) {\n          throw new Error(\"No alias select present for join\");\n        }\n        if (entries.length > 1) {\n          throw new Error(\"Only one select could be specified at join\");\n        }\n        return {\n          toSelect: toToken(entries[0][1]),\n          alias: entries[0][0]\n        };\n      }\n    }(),\n    _on: on,\n    toSql: function toSql() {\n      var _this = this;\n      var operatorSql = function () {\n        if (!_this._operator) return [sql$1(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"JOIN\"])))];\n        if (\"joinType\" in _this._operator) {\n          if (_this._operator.joinType === \"CROSS\") {\n            return [sql$1(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"CROSS JOIN\"])))];\n          } else {\n            return [_this._operator.isNatural ? sql$1(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"NATURAL\"]))) : void 0, sql$1.raw(_this._operator.joinType), \"isOuter\" in _this._operator && _this._operator.isOuter ? sql$1(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"OUTER\"]))) : void 0, sql$1(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"JOIN\"])))];\n          }\n        } else {\n          return [_this._operator.isNatural ? sql$1(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"NATURAL\"]))) : void 0, sql$1(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"JOIN\"])))];\n        }\n      }().flatMap(function (v) {\n        return v === void 0 ? [] : v;\n      });\n      return sql$1.join([].concat(_toConsumableArray(operatorSql), [\"toSelect\" in this._toJoin ? alias(this._toJoin.toSelect, this._toJoin.alias) : wrapParentheses(this._toJoin)], _toConsumableArray(this._on ? [sql$1(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"ON\"])))].concat(_toConsumableArray(conditionValuesToToken([this._on]))) : [])), \" \");\n    }\n  };\n};\nfunction join(toJoin, on) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: [].concat(_toConsumableArray(this._joinValues), [baseJoin(void 0, toJoin, on)])\n  });\n}\nfunction joinCross(toJoin, on) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: [].concat(_toConsumableArray(this._joinValues), [baseJoin({\n      joinType: \"CROSS\"\n    }, toJoin, on)])\n  });\n}\nfunction joinNatural(toJoin, on) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: [].concat(_toConsumableArray(this._joinValues), [baseJoin({\n      isNatural: true\n    }, toJoin, on)])\n  });\n}\nfunction joinLeftNatural(toJoin, on) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: [].concat(_toConsumableArray(this._joinValues), [baseJoin({\n      isNatural: true,\n      isOuter: false,\n      joinType: \"LEFT\"\n    }, toJoin, on)])\n  });\n}\nfunction joinRightNatural(toJoin, on) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: [].concat(_toConsumableArray(this._joinValues), [baseJoin({\n      isNatural: true,\n      isOuter: false,\n      joinType: \"RIGHT\"\n    }, toJoin, on)])\n  });\n}\nfunction joinFullNatural(toJoin, on) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: [].concat(_toConsumableArray(this._joinValues), [baseJoin({\n      isNatural: true,\n      isOuter: false,\n      joinType: \"FULL\"\n    }, toJoin, on)])\n  });\n}\nfunction joinLeftNaturalOuter(toJoin, on) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: [].concat(_toConsumableArray(this._joinValues), [baseJoin({\n      isNatural: true,\n      isOuter: true,\n      joinType: \"LEFT\"\n    }, toJoin, on)])\n  });\n}\nfunction joinRightNaturalOuter(toJoin, on) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: [].concat(_toConsumableArray(this._joinValues), [baseJoin({\n      isNatural: true,\n      isOuter: true,\n      joinType: \"RIGHT\"\n    }, toJoin, on)])\n  });\n}\nfunction joinFullNaturalOuter(toJoin, on) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: [].concat(_toConsumableArray(this._joinValues), [baseJoin({\n      isNatural: true,\n      isOuter: true,\n      joinType: \"FULL\"\n    }, toJoin, on)])\n  });\n}\nfunction joinInnerNatural(toJoin, on) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: [].concat(_toConsumableArray(this._joinValues), [baseJoin({\n      isNatural: true,\n      joinType: \"INNER\"\n    }, toJoin, on)])\n  });\n}\nfunction joinLeft(toJoin, on) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: [].concat(_toConsumableArray(this._joinValues), [baseJoin({\n      isNatural: false,\n      joinType: \"LEFT\"\n    }, toJoin, on)])\n  });\n}\nfunction joinRight(toJoin, on) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: [].concat(_toConsumableArray(this._joinValues), [baseJoin({\n      isNatural: false,\n      joinType: \"RIGHT\"\n    }, toJoin, on)])\n  });\n}\nfunction joinFull(toJoin, on) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: [].concat(_toConsumableArray(this._joinValues), [baseJoin({\n      isNatural: false,\n      joinType: \"FULL\"\n    }, toJoin, on)])\n  });\n}\nfunction joinLeftOuter(toJoin, on) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: [].concat(_toConsumableArray(this._joinValues), [baseJoin({\n      isNatural: false,\n      isOuter: true,\n      joinType: \"LEFT\"\n    }, toJoin, on)])\n  });\n}\nfunction joinRightOuter(toJoin, on) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: [].concat(_toConsumableArray(this._joinValues), [baseJoin({\n      isNatural: false,\n      isOuter: true,\n      joinType: \"RIGHT\"\n    }, toJoin, on)])\n  });\n}\nfunction joinFullOuter(toJoin, on) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: [].concat(_toConsumableArray(this._joinValues), [baseJoin({\n      isNatural: false,\n      isOuter: true,\n      joinType: \"FULL\"\n    }, toJoin, on)])\n  });\n}\nfunction joinInner(toJoin, on) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: [].concat(_toConsumableArray(this._joinValues), [baseJoin({\n      isNatural: false,\n      joinType: \"INNER\"\n    }, toJoin), on])\n  });\n}\nfunction withoutJoin() {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _joinValues: []\n  });\n}\nvar orderTerm = function orderTerm(type, val, nullOrder) {\n  return {\n    type: TokenType.OrderTerm,\n    _orderType: type,\n    _val: typeof val === \"string\" ? val : toToken(val),\n    _nullOrder: nullOrder,\n    toSql: function toSql() {\n      return sql$1.join([typeof this._val === \"string\" ? sql$1.liter(this._val) : this._val, sql$1.raw(this._orderType), nullOrder ? sql$1.raw(nullOrder) : sql$1.empty], \" \");\n    }\n  };\n};\nvar desc = function desc(val, nullOrder) {\n  return orderTerm(\"DESC\", val, nullOrder);\n};\nvar asc = function asc(val, nullOrder) {\n  return orderTerm(\"ASC\", val, nullOrder);\n};\nfunction orderBy() {\n  for (var _len8 = arguments.length, orderTerm2 = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    orderTerm2[_key8] = arguments[_key8];\n  }\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _orderByValues: [].concat(_toConsumableArray(this._orderByValues), orderTerm2)\n  });\n}\nfunction withoutOrder() {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _orderByValue: void 0\n  });\n}\nvar cteTerm = function cteTerm(args) {\n  return {\n    type: TokenType.CTE,\n    _recursive: args.recursive,\n    _values: [{\n      table: args.table,\n      columns: args.columns,\n      select: args.select\n    }],\n    toSql: function toSql() {\n      return sql$1.join([sql$1(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"WITH\"]))), this._recursive ? sql$1(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\"RECURSIVE\"]))) : null, sql$1.join(this._values.map(function (v) {\n        return sql$1(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral([\"\", \"(\", \") AS (\", \")\"])), sql$1.liter(v.table), sql$1.join(v.columns.map(sql$1.liter)), v.select);\n      }))].filter(function (b) {\n        return b;\n      }), \" \");\n    }\n  };\n};\nvar cteTermState = function cteTermState(state, args) {\n  var _a, _b;\n  if (((_a = state._cteValue) == null ? void 0 : _a._recursive) === true && args.recursive === false) {\n    throw new Error(\"WITH is already recursive\");\n  }\n  if (((_b = state._cteValue) == null ? void 0 : _b._recursive) === false && args.recursive === true) {\n    throw new Error(\"WITH is not recursive\");\n  }\n  return _objectSpread(_objectSpread({}, state), {}, {\n    _cteValue: state._cteValue ? _objectSpread(_objectSpread({}, state._cteValue), {}, {\n      values: [].concat(_toConsumableArray(state._cteValue._values), [{}])\n    }) : cteTerm({\n      table: args.table,\n      columns: args.columns,\n      recursive: args.recursive,\n      select: sql$1.isSql(args.select) ? buildRawSql(args.select) : args.select\n    })\n  });\n};\nfunction With(args) {\n  return cteTermState(this, _objectSpread(_objectSpread({}, args), {}, {\n    recursive: false\n  }));\n}\nfunction withRecursive(args) {\n  return cteTermState(this, _objectSpread(_objectSpread({}, args), {}, {\n    recursive: true\n  }));\n}\nfunction withoutWith() {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    cteValue: void 0\n  });\n}\nvar returning = function returning() {\n  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n    args[_key9] = arguments[_key9];\n  }\n  return {\n    type: TokenType.Returning,\n    _values: args.flatMap(function (arg) {\n      if (sql$1.isSql(arg) || isToken(arg)) {\n        return {\n          _toSelect: toToken(arg)\n        };\n      } else if (typeof arg === \"string\") {\n        return {\n          _toSelect: arg\n        };\n      } else {\n        return Object.entries(arg).map(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n            columnOrAs = _ref4[0],\n            aliasOrQuery = _ref4[1];\n          return typeof aliasOrQuery === \"string\" ? {\n            _toSelect: columnOrAs,\n            _alias: aliasOrQuery\n          } : {\n            _toSelect: toToken(aliasOrQuery),\n            _alias: columnOrAs\n          };\n        });\n      }\n    }),\n    toSql: function toSql() {\n      return this._values.length > 0 ? sql$1(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral([\"RETURNING \", \"\"])), sql$1.join(this._values.map(function (val) {\n        if (val._toSelect === \"*\") {\n          return sql$1(_templateObject18 || (_templateObject18 = _taggedTemplateLiteral([\"*\"])));\n        } else {\n          return val._alias ? alias(val._toSelect, val._alias) : val._toSelect;\n        }\n      }))) : sql$1.empty;\n    }\n  };\n};\nfunction returningForState() {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _returningValue: _objectSpread(_objectSpread({}, this._returningValue), {}, {\n      _values: [].concat(_toConsumableArray(this._returningValue._values), _toConsumableArray(returning.apply(void 0, arguments)._values))\n    })\n  });\n}\nfunction withoutReturningForState() {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _returningValue: returning()\n  });\n}\nvar constructWhere = function constructWhere(state, andOrOr, values2) {\n  var finalValues = state._whereValue ? [state._whereValue].concat(_toConsumableArray(conditionValuesToToken(values2))) : conditionValuesToToken(values2);\n  if (finalValues.length > 1) {\n    return _objectSpread(_objectSpread({}, state), {}, {\n      _whereValue: andOrOr === \"and\" ? and.apply(void 0, _toConsumableArray(finalValues)) : or.apply(void 0, _toConsumableArray(finalValues))\n    });\n  } else {\n    return _objectSpread(_objectSpread({}, state), {}, {\n      _whereValue: finalValues[0]\n    });\n  }\n};\nfunction where() {\n  for (var _len10 = arguments.length, values2 = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n    values2[_key10] = arguments[_key10];\n  }\n  return constructWhere(this, \"and\", values2);\n}\nfunction orWhere() {\n  for (var _len11 = arguments.length, values2 = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n    values2[_key11] = arguments[_key11];\n  }\n  return constructWhere(this, \"or\", values2);\n}\nvar deleteFrom = function deleteFrom(tbl) {\n  return {\n    type: TokenType.Delete,\n    _deleteTable: typeof tbl === \"string\" ? sql$1.table(tbl) : tbl,\n    _returningValue: returning(),\n    with: With,\n    withoutWith: withoutWith,\n    withRecursive: withRecursive,\n    where: where,\n    orWhere: orWhere,\n    returning: returningForState,\n    withoutReturning: withoutReturningForState,\n    toSql: function toSql() {\n      return sql$1.join([this._cteValue ? this._cteValue : null, sql$1(_templateObject19 || (_templateObject19 = _taggedTemplateLiteral([\"DELETE FROM \", \"\"])), this._deleteTable), this._whereValue ? sql$1(_templateObject20 || (_templateObject20 = _taggedTemplateLiteral([\"WHERE \", \"\"])), this._whereValue) : null, this._returningValue].filter(function (v) {\n        return v;\n      }), \" \");\n    }\n  };\n};\nfunction orAbort() {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _orReplaceValue: \"ABORT\"\n  });\n}\nfunction orFail() {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _orReplaceValue: \"FAIL\"\n  });\n}\nfunction orIgnore() {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _orReplaceValue: \"IGNORE\"\n  });\n}\nfunction orReplace() {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _orReplaceValue: \"REPLACE\"\n  });\n}\nfunction orRollback() {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _orReplaceValue: \"ROLLBACK\"\n  });\n}\nvar buildInitialLimitOffsetState = function buildInitialLimitOffsetState() {\n  return {\n    type: TokenType.LimitOffsetTerm,\n    toSql: function toSql() {\n      return this._limitValue ? sql$1.join([this._limitValue ? sql$1(_templateObject21 || (_templateObject21 = _taggedTemplateLiteral([\"LIMIT \", \"\"])), wrapParentheses(this._limitValue)) : null, this._offsetValue && this._limitValue ? sql$1(_templateObject22 || (_templateObject22 = _taggedTemplateLiteral([\"OFFSET \", \"\"])), wrapParentheses(this._offsetValue)) : null].filter(function (v) {\n        return v;\n      }), \" \") : sql$1.empty;\n    }\n  };\n};\nfunction limit(val) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _limitOffsetValue: _objectSpread(_objectSpread({}, this._limitOffsetValue), {}, {\n      _limitValue: toToken(val)\n    })\n  });\n}\nfunction withoutLimit() {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _limitOffsetValue: _objectSpread(_objectSpread({}, this._limitOffsetValue), {}, {\n      _limitValue: void 0\n    })\n  });\n}\nfunction offset(val) {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _limitOffsetValue: _objectSpread(_objectSpread({}, this._limitOffsetValue), {}, {\n      _offsetValue: toToken(val)\n    })\n  });\n}\nfunction withoutOffset() {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _limitOffsetValue: _objectSpread(_objectSpread({}, this._limitOffsetValue), {}, {\n      _offsetValue: void 0\n    })\n  });\n}\nvar values = function values() {\n  for (var _len12 = arguments.length, vals = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n    vals[_key12] = arguments[_key12];\n  }\n  return {\n    type: TokenType.Values,\n    _values: vals,\n    _compoundValues: [],\n    _orderByValues: [],\n    _limitOffsetValue: buildInitialLimitOffsetState(),\n    orderBy: orderBy,\n    withoutOrder: withoutOrder,\n    union: union,\n    unionAll: unionAll,\n    intersect: intersect,\n    except: except,\n    withoutCompound: withoutCompound,\n    limit: limit,\n    withoutLimit: withoutLimit,\n    offset: offset,\n    withoutOffset: withoutOffset,\n    withoutWith: withoutWith,\n    withRecursive: withRecursive,\n    with: With,\n    toSql: function toSql() {\n      return sql$1.join([this._cteValue ? this._cteValue : null, sql$1(_templateObject23 || (_templateObject23 = _taggedTemplateLiteral([\"VALUES \", \"\"])), sql$1.join(this._values.map(function (val) {\n        return sql$1(_templateObject24 || (_templateObject24 = _taggedTemplateLiteral([\"(\", \")\"])), sql$1.join(val));\n      }))), this._compoundValues.length > 0 ? sql$1.join(this._compoundValues, \" \") : null, this._orderByValues.length > 0 ? sql$1.join([sql$1(_templateObject25 || (_templateObject25 = _taggedTemplateLiteral([\"ORDER BY\"]))), sql$1.join(this._orderByValues)], \" \") : null, this._limitOffsetValue.toSql().isEmpty ? null : this._limitOffsetValue].filter(function (v) {\n        return v;\n      }), \" \");\n    }\n  };\n};\nvar isValues = function isValues(val) {\n  return val !== null && typeof val === \"object\" && val.type === TokenType.Values;\n};\nvar makeCompounds = function makeCompounds(state, type, values2) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    _compoundValues: [].concat(_toConsumableArray(state._compoundValues), _toConsumableArray(values2.map(function (val) {\n      var token = toToken(val);\n      return {\n        type: TokenType.OrderTerm,\n        _compoundType: type,\n        _value: isSelect(token) ? token.withoutWith().withoutLimit().withoutOrder().withoutOffset() : isValues(token) ? token.withoutWith().withoutLimit().withoutOrder().withoutOffset() : token,\n        toSql: function toSql() {\n          return sql$1(_templateObject26 || (_templateObject26 = _taggedTemplateLiteral([\"\", \" \", \"\"])), sql$1.raw(this._compoundType), this._value);\n        }\n      };\n    })))\n  });\n};\nfunction union() {\n  for (var _len13 = arguments.length, values2 = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n    values2[_key13] = arguments[_key13];\n  }\n  return makeCompounds(this, \"UNION\", values2);\n}\nfunction unionAll() {\n  for (var _len14 = arguments.length, values2 = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n    values2[_key14] = arguments[_key14];\n  }\n  return makeCompounds(this, \"UNION ALL\", values2);\n}\nfunction intersect() {\n  for (var _len15 = arguments.length, values2 = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n    values2[_key15] = arguments[_key15];\n  }\n  return makeCompounds(this, \"INTERSECT\", values2);\n}\nfunction except() {\n  for (var _len16 = arguments.length, values2 = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n    values2[_key16] = arguments[_key16];\n  }\n  return makeCompounds(this, \"EXCEPT\", values2);\n}\nfunction withoutCompound() {\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _compoundValues: []\n  });\n}\nfunction from() {\n  for (var _len17 = arguments.length, values2 = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n    values2[_key17] = arguments[_key17];\n  }\n  return _objectSpread(_objectSpread({}, this), {}, {\n    _fromValues: [].concat(_toConsumableArray(this._fromValues), _toConsumableArray(values2.map(function (v) {\n      if (typeof v === \"string\") {\n        return sql$1.table(v);\n      } else if (isToken(v) || sql$1.isSql(v) || sql$1.isTable(v)) {\n        return toToken(wrapParentheses(v));\n      } else {\n        return Object.entries(v).map(function (_ref5) {\n          var _ref6 = _slicedToArray(_ref5, 2),\n            k = _ref6[0],\n            v2 = _ref6[1];\n          return {\n            select: typeof v2 === \"string\" ? sql$1.table(v2) : toToken(wrapParentheses(v2)),\n            alias: k\n          };\n        });\n      }\n    }).flat()))\n  });\n}\nvar fromToSql = function fromToSql(state) {\n  return state._fromValues.length > 0 ? sql$1.join(state._fromValues.map(function (v) {\n    return isToken(v) || sql$1.isTable(v) ? v : alias(v.select, v.alias);\n  })) : null;\n};\nvar isSelect = function isSelect(val) {\n  return val !== null && typeof val === \"object\" && val.type === TokenType.Select;\n};\nvar selectArgsToValues = function selectArgsToValues(args) {\n  if (args === null || args === void 0 || args.length === 0) return [{\n    toSelect: \"*\"\n  }];\n  return args.flatMap(function (arg, i) {\n    if (arg === \"*\" && i === 0) return {\n      toSelect: \"*\"\n    };\n    if (typeof arg === \"string\") return {\n      toSelect: arg\n    };\n    if (isToken(arg) || sql$1.isSql(arg)) return {\n      toSelect: toToken(arg)\n    };\n    return Object.entries(arg).map(function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 2),\n        columnOrAs = _ref8[0],\n        aliasOrQuery = _ref8[1];\n      return typeof aliasOrQuery === \"string\" ? {\n        toSelect: columnOrAs,\n        alias: aliasOrQuery\n      } : {\n        toSelect: toToken(aliasOrQuery),\n        alias: columnOrAs\n      };\n    });\n  });\n};\nvar select = function select() {\n  for (var _len18 = arguments.length, selectArgs = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n    selectArgs[_key18] = arguments[_key18];\n  }\n  return {\n    type: TokenType.Select,\n    _fromValues: [],\n    _selectValues: selectArgsToValues(selectArgs),\n    _distinctValue: false,\n    _groupByValues: [],\n    _compoundValues: [],\n    _orderByValues: [],\n    _joinValues: [],\n    _limitOffsetValue: buildInitialLimitOffsetState(),\n    select: function select() {\n      for (var _len19 = arguments.length, selectArgs2 = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n        selectArgs2[_key19] = arguments[_key19];\n      }\n      return _objectSpread(_objectSpread({}, this), {}, {\n        _selectValues: [].concat(_toConsumableArray(this._selectValues), _toConsumableArray(selectArgsToValues(selectArgs2)))\n      });\n    },\n    distinct: function distinct(val) {\n      return _objectSpread(_objectSpread({}, this), {}, {\n        _distinctValue: val\n      });\n    },\n    from: from,\n    where: where,\n    orWhere: orWhere,\n    limit: limit,\n    offset: offset,\n    withoutLimit: withoutLimit,\n    withoutOffset: withoutOffset,\n    groupBy: function groupBy() {\n      for (var _len20 = arguments.length, values2 = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n        values2[_key20] = arguments[_key20];\n      }\n      return _objectSpread(_objectSpread({}, this), {}, {\n        _groupByValues: values2.map(function (val) {\n          return typeof val === \"string\" ? val : toToken(val);\n        })\n      });\n    },\n    having: function having(val) {\n      return _objectSpread(_objectSpread({}, this), {}, {\n        _havingValue: toToken(val)\n      });\n    },\n    orderBy: orderBy,\n    withoutOrder: withoutOrder,\n    with: With,\n    withoutWith: withoutWith,\n    withRecursive: withRecursive,\n    union: union,\n    unionAll: unionAll,\n    intersect: intersect,\n    except: except,\n    withoutCompound: withoutCompound,\n    withoutJoin: withoutJoin,\n    join: join,\n    joinCross: joinCross,\n    joinNatural: joinNatural,\n    joinLeft: joinLeft,\n    joinLeftOuter: joinLeftOuter,\n    joinLeftNatural: joinLeftNatural,\n    joinLeftNaturalOuter: joinLeftNaturalOuter,\n    joinRight: joinRight,\n    joinRightOuter: joinRightOuter,\n    joinRightNatural: joinRightNatural,\n    joinRightNaturalOuter: joinRightNaturalOuter,\n    joinFull: joinFull,\n    joinFullOuter: joinFullOuter,\n    joinFullNatural: joinFullNatural,\n    joinFullNaturalOuter: joinFullNaturalOuter,\n    joinInner: joinInner,\n    joinInnerNatural: joinInnerNatural,\n    toSql: function toSql() {\n      return sql$1.join([this._cteValue ? this._cteValue : null, sql$1(_templateObject27 || (_templateObject27 = _taggedTemplateLiteral([\"SELECT\"]))), this._distinctValue ? sql$1(_templateObject28 || (_templateObject28 = _taggedTemplateLiteral([\"DISTINCT\"]))) : null, sql$1.join(this._selectValues.map(function (val) {\n        if (val.toSelect === \"*\") {\n          return sql$1(_templateObject29 || (_templateObject29 = _taggedTemplateLiteral([\"*\"])));\n        } else if (typeof val.toSelect === \"string\") {\n          return sql$1.liter(val.toSelect);\n        } else {\n          return val.alias ? alias(val.toSelect, val.alias) : val.toSelect;\n        }\n      })), this._fromValues.length > 0 || this._joinValues.length > 0 ? sql$1(_templateObject30 || (_templateObject30 = _taggedTemplateLiteral([\"FROM\"]))) : null, fromToSql(this), this._joinValues.length > 0 ? sql$1.join(this._joinValues.map(function (expr) {\n        return expr.toSql();\n      }), \" \") : null, this._whereValue ? sql$1(_templateObject31 || (_templateObject31 = _taggedTemplateLiteral([\"WHERE \", \"\"])), this._whereValue) : null, this._groupByValues.length > 0 ? sql$1(_templateObject32 || (_templateObject32 = _taggedTemplateLiteral([\"GROUP BY \", \"\"])), sql$1.join(this._groupByValues.map(function (val) {\n        return typeof val === \"string\" ? sql$1.liter(val) : val;\n      }))) : null, this._groupByValues.length > 0 && this._havingValue ? sql$1(_templateObject33 || (_templateObject33 = _taggedTemplateLiteral([\"HAVING \", \"\"])), this._havingValue) : null, this._compoundValues.length > 0 ? sql$1.join(this._compoundValues, \" \") : null, this._orderByValues.length > 0 ? sql$1.join([sql$1(_templateObject34 || (_templateObject34 = _taggedTemplateLiteral([\"ORDER BY\"]))), sql$1.join(this._orderByValues)], \" \") : null, this._limitOffsetValue.toSql().isEmpty ? null : this._limitOffsetValue].filter(function (v) {\n        return v;\n      }), \" \");\n    }\n  };\n};\nvar mapRecordArg = function mapRecordArg(arg) {\n  return (Array.isArray(arg) ? arg : [arg]).map(function (it) {\n    return Object.entries(it).map(function (_ref9) {\n      var _ref10 = _slicedToArray(_ref9, 2),\n        columnName = _ref10[0],\n        value = _ref10[1];\n      return {\n        columnName: columnName,\n        value: sql$1.isSql(value) && !isToken(value) ? buildRawSql(value) : value\n      };\n    });\n  });\n};\nvar applyInsertArg = function applyInsertArg(state, arg) {\n  if (state._toInsertValue && (isSelect(state._toInsertValue) || isValues(state._toInsertValue))) {\n    throw new Error(\"Insert value is already state. If you want to change insert values user resetInsert() before.\");\n  }\n  if (isSelect(arg) || isValues(arg)) {\n    return _objectSpread(_objectSpread({}, state), {}, {\n      _toInsertValue: arg\n    });\n  }\n  return _objectSpread(_objectSpread({}, state), {}, {\n    _toInsertValue: Array.isArray(state._toInsertValue) ? [].concat(_toConsumableArray(state._toInsertValue), _toConsumableArray(mapRecordArg(arg))) : mapRecordArg(arg)\n  });\n};\nvar insert = function insert(insertArg) {\n  return {\n    type: TokenType.Insert,\n    _returningValue: returning(),\n    _columnNames: [],\n    _toInsertValue: isSelect(insertArg) || isValues(insertArg) ? insertArg : mapRecordArg(insertArg),\n    with: With,\n    withRecursive: withRecursive,\n    withoutWith: withoutWith,\n    orAbort: orAbort,\n    orFail: orFail,\n    orIgnore: orIgnore,\n    orReplace: orReplace,\n    orRollback: orRollback,\n    returning: returningForState,\n    withoutReturning: withoutReturningForState,\n    setColumnNames: function setColumnNames(names) {\n      return _objectSpread(_objectSpread({}, this), {}, {\n        _columnNames: names\n      });\n    },\n    withoutColumnNames: function withoutColumnNames() {\n      return _objectSpread(_objectSpread({}, this), {}, {\n        _columnNames: []\n      });\n    },\n    insert: function insert(arg) {\n      return applyInsertArg(this, arg);\n    },\n    withoutInsert: function withoutInsert() {\n      return _objectSpread(_objectSpread({}, this), {}, {\n        _toInsertValue: void 0\n      });\n    },\n    into: function into(val) {\n      return _objectSpread(_objectSpread({}, this), {}, {\n        _intoTable: typeof val === \"string\" ? sql$1.table(val) : val\n      });\n    },\n    withoutInto: function withoutInto() {\n      return _objectSpread(_objectSpread({}, this), {}, {\n        _intoTable: void 0\n      });\n    },\n    toSql: function toSql() {\n      if (!this._toInsertValue) {\n        throw new Error(\"Insert values are not set\");\n      }\n      if (!this._intoTable) {\n        throw new Error(\"Into table is not set\");\n      }\n      var columns = this._columnNames.length > 0 ? this._columnNames : Array.isArray(this._toInsertValue) ? this._toInsertValue[0].map(function (_ref11) {\n        var columnName = _ref11.columnName;\n        return columnName;\n      }) : [];\n      return sql$1.join([this._cteValue ? this._cteValue : null, sql$1(_templateObject35 || (_templateObject35 = _taggedTemplateLiteral([\"INSERT\"]))), this._orReplaceValue ? sql$1(_templateObject36 || (_templateObject36 = _taggedTemplateLiteral([\"OR \", \"\"])), sql$1.raw(this._orReplaceValue)) : null, sql$1(_templateObject37 || (_templateObject37 = _taggedTemplateLiteral([\"INTO\"]))), this._intoTable, columns.length > 0 ? sql$1(_templateObject38 || (_templateObject38 = _taggedTemplateLiteral([\"(\", \")\"])), sql$1.join(columns.map(function (c) {\n        return sql$1.liter(c);\n      }))) : null, isValues(this._toInsertValue) || isSelect(this._toInsertValue) ? this._toInsertValue : sql$1(_templateObject39 || (_templateObject39 = _taggedTemplateLiteral([\"VALUES \", \"\"])), sql$1.join(this._toInsertValue.map(function (toInsertColumns) {\n        var toInsert = Array(toInsertColumns.length);\n        var _iterator2 = _createForOfIteratorHelper(toInsertColumns),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _step2$value = _step2.value,\n              columnName = _step2$value.columnName,\n              value = _step2$value.value;\n            var index = columns.indexOf(columnName);\n            if (index === -1) {\n              throw new Error(\"Column \".concat(columnName, \" is not present at columns set: \").concat(columns, \". Make sure that you set all columns with setColumnNames() or each insert objects have the same keys present. Tried to insert: \").concat(JSON.stringify(toInsertColumns)));\n            }\n            toInsert[index] = value;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        return sql$1(_templateObject40 || (_templateObject40 = _taggedTemplateLiteral([\"(\", \")\"])), sql$1.join(toInsert));\n      }))), this._returningValue].filter(function (v) {\n        return v;\n      }), \" \");\n    }\n  };\n};\nvar update = function update(tbl) {\n  return {\n    type: TokenType.Update,\n    _updateTable: typeof tbl === \"string\" ? sql$1.table(tbl) : tbl,\n    _setValues: [],\n    _fromValues: [],\n    _joinValues: [],\n    _returningValue: returning(),\n    with: With,\n    withoutWith: withoutWith,\n    withRecursive: withRecursive,\n    from: from,\n    where: where,\n    orWhere: orWhere,\n    returning: returningForState,\n    withoutReturning: withoutReturningForState,\n    orAbort: orAbort,\n    orFail: orFail,\n    orIgnore: orIgnore,\n    orReplace: orReplace,\n    orRollback: orRollback,\n    withoutJoin: withoutJoin,\n    join: join,\n    joinCross: joinCross,\n    joinNatural: joinNatural,\n    joinLeft: joinLeft,\n    joinLeftOuter: joinLeftOuter,\n    joinLeftNatural: joinLeftNatural,\n    joinLeftNaturalOuter: joinLeftNaturalOuter,\n    joinRight: joinRight,\n    joinRightOuter: joinRightOuter,\n    joinRightNatural: joinRightNatural,\n    joinRightNaturalOuter: joinRightNaturalOuter,\n    joinFull: joinFull,\n    joinFullOuter: joinFullOuter,\n    joinFullNatural: joinFullNatural,\n    joinFullNaturalOuter: joinFullNaturalOuter,\n    joinInner: joinInner,\n    joinInnerNatural: joinInnerNatural,\n    set: function set() {\n      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n        args[_key21] = arguments[_key21];\n      }\n      var vals = args.flatMap(function (m) {\n        if (isToken(m)) {\n          return m;\n        } else if (sql$1.isSql(m)) {\n          return buildRawSql(m);\n        } else {\n          return Object.entries(m).map(function (_ref12) {\n            var _ref13 = _slicedToArray(_ref12, 2),\n              key = _ref13[0],\n              val = _ref13[1];\n            return {\n              columnName: key,\n              toSet: !isToken(val) && sql$1.isSql(val) ? buildRawSql(val) : val\n            };\n          });\n        }\n      });\n      return _objectSpread(_objectSpread({}, this), {}, {\n        _setValues: [].concat(_toConsumableArray(this._setValues), _toConsumableArray(vals))\n      });\n    },\n    toSql: function toSql() {\n      return sql$1.join([this._cteValue ? this._cteValue : null, sql$1(_templateObject41 || (_templateObject41 = _taggedTemplateLiteral([\"UPDATE\"]))), this._orReplaceValue ? sql$1(_templateObject42 || (_templateObject42 = _taggedTemplateLiteral([\"OR \", \"\"])), sql$1.raw(this._orReplaceValue)) : null, this._updateTable, sql$1(_templateObject43 || (_templateObject43 = _taggedTemplateLiteral([\"SET\"]))), sql$1.join(this._setValues.map(function (val) {\n        return isToken(val) ? val : sql$1(_templateObject44 || (_templateObject44 = _taggedTemplateLiteral([\"\", \" = \", \"\"])), sql$1.liter(val.columnName), wrapParentheses(val.toSet));\n      })), this._fromValues.length > 0 || this._joinValues.length > 0 ? sql$1(_templateObject45 || (_templateObject45 = _taggedTemplateLiteral([\"FROM\"]))) : null, fromToSql(this), this._joinValues.length > 0 ? sql$1.join(this._joinValues.map(function (expr) {\n        return expr.toSql();\n      }), \" \") : null, this._whereValue ? sql$1(_templateObject46 || (_templateObject46 = _taggedTemplateLiteral([\"WHERE \", \"\"])), this._whereValue) : null, this._returningValue].filter(function (v) {\n        return v;\n      }), \" \");\n    }\n  };\n};\nvar not = function not(expr) {\n  return {\n    _operator: \"NOT\",\n    type: TokenType.Unary,\n    _expr: expr,\n    toSql: function toSql() {\n      return sql$1(_templateObject47 || (_templateObject47 = _taggedTemplateLiteral([\"NOT (\", \")\"])), this._expr);\n    }\n  };\n};\nexport { In, alias, and, asc, buildRawSql, conditionValuesToToken, deleteFrom, desc, eq, eq$, gt, gt$, gtEq, gtEq$, in$, insert, isBinaryOperator, isSelect, isValues, join, joinCross, joinFull, joinFullNatural, joinFullNaturalOuter, joinFullOuter, joinInner, joinInnerNatural, joinLeft, joinLeftNatural, joinLeftNaturalOuter, joinLeftOuter, joinNatural, joinRight, joinRightNatural, joinRightNaturalOuter, joinRightOuter, like, like$, lt, lt$, ltEq, ltEq$, not, notEq, notEq$, notIn, notIn$, notLike, notLike$, or, select, toToken, update, values, withoutJoin, wrapParentheses };","map":{"version":3,"mappings":"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","names":["TokenType2","isToken","t","Object","values","TokenType","includes","type","buildRawSql","RawSql","toSql","sql","toToken","isSql","isBinaryOperator","Binary","binaryOperator","operator","left","right","_left","_right","Array","isArray","map","_operator","wrapParentheses","raw","join","notEq$","notEq","eq$","eq","gt$","gt","gtEq$","gtEq","lt$","lt","ltEq$","ltEq","like","like$","notLike","notLike$","In","notIn","in$","values2","notIn$","conditionValuesToToken","flatMap","v","entries","k","expr","liter","filter","isEmpty","conditionOperator","length","Error","current","exprs","slice","next","and","or","val","Select","Values","alias","Alias","baseJoin","toJoin","on","Join","_toJoin","table","isTable","toSelect","_on","operatorSql","joinType","isNatural","isOuter","_joinValues","orderTerm","nullOrder","OrderTerm","_orderType","_val","_nullOrder","empty","desc","asc","orderTerm2","_orderByValues","_orderByValue","cteTerm","args","CTE","_recursive","recursive","_values","columns","select","b","cteTermState","state","_cteValue","cteValue","returning","Returning","arg","_toSelect","columnOrAs","aliasOrQuery","_alias","_returningValue","constructWhere","andOrOr","finalValues","_whereValue","deleteFrom","tbl","Delete","_deleteTable","with","With","withoutWith","withRecursive","where","orWhere","returningForState","withoutReturning","withoutReturningForState","_orReplaceValue","buildInitialLimitOffsetState","LimitOffsetTerm","_limitValue","_offsetValue","_limitOffsetValue","vals","_compoundValues","orderBy","withoutOrder","union","unionAll","intersect","except","withoutCompound","limit","withoutLimit","offset","withoutOffset","isValues","makeCompounds","_compoundType","_value","isSelect","token","_fromValues","v2","flat","fromToSql","selectArgsToValues","i","selectArgs","_selectValues","_distinctValue","_groupByValues","selectArgs2","distinct","from","groupBy","having","_havingValue","withoutJoin","joinCross","joinNatural","joinLeft","joinLeftOuter","joinLeftNatural","joinLeftNaturalOuter","joinRight","joinRightOuter","joinRightNatural","joinRightNaturalOuter","joinFull","joinFullOuter","joinFullNatural","joinFullNaturalOuter","joinInner","joinInnerNatural","mapRecordArg","it","columnName","value","applyInsertArg","_toInsertValue","insert","insertArg","Insert","_columnNames","orAbort","orFail","orIgnore","orReplace","orRollback","setColumnNames","names","withoutColumnNames","withoutInsert","into","_intoTable","withoutInto","c","toInsertColumns","indexOf","index","JSON","stringify","toInsert","update","Update","_updateTable","_setValues","set","m","key","toSet","not","Unary","_expr"],"sources":["../src/types.ts","../src/tokens/rawSql.ts","../src/tokens/binary.ts","../src/tokens/utils.ts","../src/tokens/alias.ts","../src/tokens/join.ts","../src/tokens/order.ts","../src/tokens/cte.ts","../src/tokens/returning.ts","../src/tokens/where.ts","../src/tokens/statements/delete.ts","../src/tokens/orReplace.ts","../src/tokens/limitOffset.ts","../src/tokens/statements/values.ts","../src/tokens/compounds.ts","../src/tokens/from.ts","../src/tokens/statements/select.ts","../src/tokens/statements/insert.ts","../src/tokens/statements/update.ts","../src/tokens/unary.ts"],"sourcesContent":["import { ISql } from \"@kikko-land/sql\";\n\nexport enum TokenType {\n  Binary = \"Binary\",\n  Unary = \"Unary\",\n  Alias = \"Alias\",\n  Compound = \"Compound\",\n  Select = \"Select\",\n  Update = \"Update\",\n  Delete = \"Delete\",\n  Insert = \"Insert\",\n  Values = \"Values\",\n  OrderTerm = \"OrderTerm\",\n  LimitOffsetTerm = \"LimitOffsetTerm\",\n  RawSql = \"RawSql\",\n  CompoundOperator = \"CompoundOperator\",\n  CTE = \"CTE\",\n  Join = \"Join\",\n  Returning = \"Returning\",\n}\n\nexport interface IBaseToken<T extends TokenType = TokenType> {\n  type: T;\n  toSql(): ISql;\n}\n\nexport const isToken = (t: unknown): t is IBaseToken => {\n  return (\n    t !== null &&\n    typeof t === \"object\" &&\n    \"type\" in t &&\n    \"toSql\" in t &&\n    Object.values(TokenType).includes((t as IBaseToken).type)\n  );\n};\n\nexport function assertUnreachable(x: never): never {\n  throw new Error(`Didn't expect to get here: ${JSON.stringify(x)}`);\n}\n","import {\n  IContainsTable,\n  IPrimitiveValue,\n  ISqlAdapter,\n  sql,\n} from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../types\";\n\nexport const buildRawSql = (\n  t: ISqlAdapter | IContainsTable | IPrimitiveValue\n): IBaseToken<TokenType.RawSql> => {\n  return {\n    type: TokenType.RawSql,\n    toSql() {\n      return sql`${t}`;\n    },\n  };\n};\n\nexport const toToken = (\n  t: IBaseToken | ISqlAdapter | IPrimitiveValue | IContainsTable\n): IBaseToken => {\n  if (isToken(t)) return t;\n\n  if (sql.isSql(t)) {\n    return buildRawSql(t);\n  }\n\n  return buildRawSql(t);\n};\n","import { IPrimitiveValue, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../types\";\nimport { toToken } from \"./rawSql\";\nimport { wrapParentheses } from \"./utils\";\n\n// TODO: in null support\n// TODO: add ESCAPE for LIKE/NOT LIKE\nexport interface IBinaryOperator extends IBaseToken<TokenType.Binary> {\n  _operator:\n    | \"<\"\n    | \"<=\"\n    | \">\"\n    | \">=\"\n    | \"=\"\n    | \"<>\"\n    | \"AND\"\n    | \"OR\"\n    | \"IN\"\n    | \"NOT IN\"\n    | \"LIKE\"\n    | \"NOT LIKE\"\n    // TODO: add all\n    | \"BETWEEN\"\n    | \"NOT BETWEEN\"\n    | \"GLOB\"\n    | \"NOT GLOB\"\n    | \"MATCH\"\n    | \"NOT MATCH\"\n    | \"REGEXP\"\n    | \"NOT REGEXP\";\n  _left: IBaseToken;\n  _right: IBaseToken | IBaseToken[];\n}\n\nexport const isBinaryOperator = (t: unknown): t is IBinaryOperator => {\n  return (\n    t !== null &&\n    typeof t === \"object\" &&\n    \"type\" in t &&\n    (t as IBinaryOperator).type === TokenType.Binary\n  );\n};\n\nconst binaryOperator = (\n  operator: IBinaryOperator[\"_operator\"],\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right:\n    | IBaseToken\n    | ISqlAdapter\n    | IPrimitiveValue\n    | (IBaseToken | ISqlAdapter | IPrimitiveValue)[]\n): IBinaryOperator => {\n  return {\n    type: TokenType.Binary,\n    _left: toToken(left),\n    _right: Array.isArray(right) ? right.map(toToken) : toToken(right),\n    _operator: operator,\n    toSql() {\n      return sql`${wrapParentheses(this._left)} ${sql.raw(this._operator)} ${\n        Array.isArray(this._right)\n          ? sql`(${sql.join(this._right)})`\n          : wrapParentheses(this._right)\n      }`;\n    },\n  };\n};\n\nexport const notEq$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) =>\n    notEq(left, right);\n};\nexport const notEq = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"<>\", left, right);\n};\n\nexport const eq$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => eq(left, right);\n};\nexport const eq = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"=\", left, right);\n};\n\nexport const gt$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => gt(left, right);\n};\nexport const gt = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\">\", left, right);\n};\n\nexport const gtEq$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) =>\n    gtEq(left, right);\n};\nexport const gtEq = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\">=\", left, right);\n};\n\nexport const lt$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => lt(left, right);\n};\nexport const lt = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"<\", left, right);\n};\n\nexport const ltEq$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) =>\n    ltEq(left, right);\n};\nexport const ltEq = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"<=\", left, right);\n};\n\nexport const like = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"LIKE\", left, right);\n};\nexport const like$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) =>\n    like(left, right);\n};\n\nexport const notLike = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"NOT LIKE\", left, right);\n};\nexport const notLike$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) =>\n    notLike(left, right);\n};\n\nexport const In = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  ...right: (IBaseToken | ISqlAdapter | IPrimitiveValue)[]\n) => {\n  return binaryOperator(\"IN\", left, right);\n};\nexport const notIn = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  ...right: (IBaseToken | ISqlAdapter | IPrimitiveValue)[]\n) => {\n  return binaryOperator(\"NOT IN\", left, right);\n};\n\nexport const in$ =\n  (...values: (IBaseToken | ISqlAdapter | IPrimitiveValue)[]) =>\n  (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n    return In(left, ...values);\n  };\nexport const notIn$ =\n  (...values: (IBaseToken | ISqlAdapter | IPrimitiveValue)[]) =>\n  (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n    return notIn(left, ...values);\n  };\n\nexport type IConditionValue =\n  | IBaseToken\n  | ISqlAdapter\n  | Record<\n      string,\n      | ((left: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator)\n      | IBaseToken\n      | ISqlAdapter\n      | IPrimitiveValue\n    >;\n\nexport const conditionValuesToToken = (values: IConditionValue[]) => {\n  return values\n    .flatMap((v) =>\n      isToken(v) || sql.isSql(v)\n        ? toToken(v)\n        : Object.entries(v).map(([k, expr]) =>\n            toToken(\n              typeof expr === \"function\"\n                ? expr(sql.liter(k))\n                : eq(sql.liter(k), expr)\n            )\n          )\n    )\n    .filter((v) => !v.toSql().isEmpty);\n};\n\nconst conditionOperator = (\n  type: \"AND\" | \"OR\",\n  ...values: IConditionValue[]\n): IBinaryOperator => {\n  const exprs = conditionValuesToToken(values);\n\n  if (exprs.length <= 1) {\n    throw new Error(\"Must at least two arguments present\");\n  }\n\n  let current = binaryOperator(type, exprs[0], exprs[1]);\n\n  for (const next of exprs.slice(2)) {\n    current = binaryOperator(type, current, next);\n  }\n\n  return current;\n};\n\nexport const and = (...values: IConditionValue[]): IBinaryOperator => {\n  return conditionOperator(\"AND\", ...values);\n};\n\nexport const or = (...values: IConditionValue[]): IBinaryOperator => {\n  return conditionOperator(\"OR\", ...values);\n};\n","import {\n  IContainsTable,\n  IPrimitiveValue,\n  ISql,\n  ISqlAdapter,\n  sql,\n} from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../types\";\nimport { isBinaryOperator } from \"./binary\";\n\nexport const wrapParentheses = <\n  T extends IBaseToken | ISqlAdapter | IPrimitiveValue | IContainsTable\n>(\n  val: T\n): T | ISql =>\n  (isBinaryOperator(val) && val._operator === \"OR\") ||\n  (isToken(val) &&\n    (val.type === TokenType.Select || val.type === TokenType.Values))\n    ? sql`(${val})`\n    : val;\n","import {\n  IContainsTable,\n  IPrimitiveValue,\n  ISqlAdapter,\n  sql,\n} from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\nimport { toToken } from \"./rawSql\";\nimport { wrapParentheses } from \"./utils\";\n\nexport type IAlias = IBaseToken<TokenType.Alias> & {\n  _left: IBaseToken;\n  _right: string;\n};\n\nexport const alias = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue | IContainsTable,\n  right: string\n): IAlias => {\n  return {\n    type: TokenType.Alias,\n    _left: toToken(left),\n    _right: right,\n    toSql() {\n      return sql`${wrapParentheses(this._left)} AS ${sql.liter(this._right)}`;\n    },\n  };\n};\n","import { IContainsTable, ISqlAdapter, sql } from \"@kikko-land/sql\";\nimport { isTable } from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../types\";\nimport { alias } from \"./alias\";\nimport { conditionValuesToToken, IConditionValue } from \"./binary\";\nimport { toToken } from \"./rawSql\";\nimport { ISelectStatement } from \"./statements/select\";\nimport { wrapParentheses } from \"./utils\";\n\ntype IJoinOperator =\n  | {\n      joinType: \"CROSS\";\n    }\n  | ({\n      isNatural: boolean;\n    } & (\n      | {\n          joinType: \"LEFT\" | \"RIGHT\" | \"FULL\";\n          isOuter: boolean;\n        }\n      | {\n          joinType: \"INNER\";\n        }\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | {}\n    ));\n\nexport interface IJoinExpr extends IBaseToken<TokenType.Join> {\n  _operator?: IJoinOperator;\n  _toJoin:\n    | IContainsTable\n    | IBaseToken\n    | { toSelect: IBaseToken; alias: string };\n  _on?: IConditionValue;\n}\n\nconst baseJoin = (\n  operator: IJoinOperator | undefined,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): IJoinExpr => {\n  return {\n    type: TokenType.Join,\n    _operator: operator,\n    _toJoin: (() => {\n      if (typeof toJoin === \"string\") {\n        return sql.table(toJoin);\n      } else if (isTable(toJoin)) {\n        return toJoin;\n      } else if (isToken(toJoin) || sql.isSql(toJoin)) {\n        return toToken(toJoin);\n      } else {\n        const entries = Object.entries(toJoin);\n        if (entries.length === 0) {\n          throw new Error(\"No alias select present for join\");\n        }\n        if (entries.length > 1) {\n          throw new Error(\"Only one select could be specified at join\");\n        }\n        return { toSelect: toToken(entries[0][1]), alias: entries[0][0] };\n      }\n    })(),\n    _on: on,\n\n    toSql() {\n      const operatorSql = (() => {\n        if (!this._operator) return [sql`JOIN`];\n\n        if (\"joinType\" in this._operator) {\n          if (this._operator.joinType === \"CROSS\") {\n            return [sql`CROSS JOIN`] as const;\n          } else {\n            return [\n              this._operator.isNatural ? sql`NATURAL` : undefined,\n              sql.raw(this._operator.joinType),\n              \"isOuter\" in this._operator && this._operator.isOuter\n                ? sql`OUTER`\n                : undefined,\n              sql`JOIN`,\n            ] as const;\n          }\n        } else {\n          return [\n            this._operator.isNatural ? sql`NATURAL` : undefined,\n            sql`JOIN`,\n          ] as const;\n        }\n      })().flatMap((v) => (v === undefined ? [] : v));\n\n      return sql.join(\n        [\n          ...operatorSql,\n          \"toSelect\" in this._toJoin\n            ? alias(this._toJoin.toSelect, this._toJoin.alias)\n            : wrapParentheses(this._toJoin),\n          ...(this._on ? [sql`ON`, ...conditionValuesToToken([this._on])] : []),\n        ],\n        \" \"\n      );\n    },\n  };\n};\n\ntype IToJoinArg =\n  | IBaseToken\n  | ISqlAdapter\n  | IContainsTable\n  | string\n  | { [key: string]: ISqlAdapter | ISelectStatement | string };\n\nexport interface IJoinState {\n  _joinValues: IJoinExpr[];\n\n  withoutJoin: typeof withoutJoin;\n\n  join: typeof join;\n  joinCross: typeof joinCross;\n\n  joinNatural: typeof joinNatural;\n\n  joinLeft: typeof joinLeft;\n  joinLeftOuter: typeof joinLeftOuter;\n  joinLeftNatural: typeof joinLeftNatural;\n  joinLeftNaturalOuter: typeof joinLeftNaturalOuter;\n\n  joinRight: typeof joinRight;\n  joinRightOuter: typeof joinRightOuter;\n  joinRightNatural: typeof joinRightNatural;\n  joinRightNaturalOuter: typeof joinRightNaturalOuter;\n\n  joinFull: typeof joinFull;\n  joinFullOuter: typeof joinFullOuter;\n  joinFullNatural: typeof joinFullNatural;\n  joinFullNaturalOuter: typeof joinFullNaturalOuter;\n\n  joinInner: typeof joinInner;\n  joinInnerNatural: typeof joinInnerNatural;\n}\n\nexport function join<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [...this._joinValues, baseJoin(undefined, toJoin, on)],\n  };\n}\n\nexport function joinCross<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ joinType: \"CROSS\" }, toJoin, on),\n    ],\n  };\n}\n\nexport function joinNatural<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: true }, toJoin, on),\n    ],\n  };\n}\n\nexport function joinLeftNatural<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: false, joinType: \"LEFT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\n\nexport function joinRightNatural<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: false, joinType: \"RIGHT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\n\nexport function joinFullNatural<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: false, joinType: \"FULL\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\n\nexport function joinLeftNaturalOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: true, joinType: \"LEFT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\nexport function joinRightNaturalOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: true, joinType: \"RIGHT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\nexport function joinFullNaturalOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: true, joinType: \"FULL\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\n\nexport function joinInnerNatural<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: true, joinType: \"INNER\" as const }, toJoin, on),\n    ],\n  };\n}\n\nexport function joinLeft<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: false, joinType: \"LEFT\" as const }, toJoin, on),\n    ],\n  };\n}\nexport function joinRight<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: false, joinType: \"RIGHT\" as const }, toJoin, on),\n    ],\n  };\n}\nexport function joinFull<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: false, joinType: \"FULL\" as const }, toJoin, on),\n    ],\n  };\n}\n\nexport function joinLeftOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: false, isOuter: true, joinType: \"LEFT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\nexport function joinRightOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: false, isOuter: true, joinType: \"RIGHT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\nexport function joinFullOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: false, isOuter: true, joinType: \"FULL\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\n\nexport function joinInner<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: false, joinType: \"INNER\" as const }, toJoin),\n      on,\n    ],\n  };\n}\n\nexport function withoutJoin<T extends IJoinState>(this: T): T {\n  return {\n    ...this,\n    _joinValues: [],\n  };\n}\n","import { ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\nimport { toToken } from \"./rawSql\";\n\nexport interface IOrderTerm extends IBaseToken<TokenType.OrderTerm> {\n  _orderType: \"DESC\" | \"ASC\";\n  _val: IBaseToken | string;\n  _nullOrder?: \"NULLS FIRST\" | \"NULLS LAST\";\n}\n\nconst orderTerm = (\n  type: IOrderTerm[\"_orderType\"],\n  val: IBaseToken | ISqlAdapter | string,\n  nullOrder: IOrderTerm[\"_nullOrder\"]\n): IOrderTerm => {\n  return {\n    type: TokenType.OrderTerm,\n    _orderType: type,\n    _val: typeof val === \"string\" ? val : toToken(val),\n    _nullOrder: nullOrder,\n    toSql() {\n      return sql.join(\n        [\n          typeof this._val === \"string\" ? sql.liter(this._val) : this._val,\n          sql.raw(this._orderType),\n          nullOrder ? sql.raw(nullOrder) : sql.empty,\n        ],\n        \" \"\n      );\n    },\n  };\n};\n\nexport const desc = (\n  val: IBaseToken | ISqlAdapter | string,\n  nullOrder?: \"NULLS FIRST\" | \"NULLS LAST\"\n) => {\n  return orderTerm(\"DESC\", val, nullOrder);\n};\n\nexport const asc = (\n  val: IBaseToken | ISqlAdapter | string,\n  nullOrder?: \"NULLS FIRST\" | \"NULLS LAST\"\n) => {\n  return orderTerm(\"ASC\", val, nullOrder);\n};\n\nexport interface IOrderState {\n  _orderByValues: IOrderTerm[];\n\n  orderBy: typeof orderBy;\n  withoutOrder: typeof withoutOrder;\n}\n\nexport function orderBy<T extends IOrderState>(\n  this: T,\n  ...orderTerm: IOrderTerm[]\n): T {\n  return {\n    ...this,\n    _orderByValues: [...this._orderByValues, ...orderTerm],\n  };\n}\n\nexport function withoutOrder<T extends IOrderState>(this: T): T {\n  return {\n    ...this,\n    _orderByValue: undefined,\n  };\n}\n","import { ISql, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\nimport { buildRawSql } from \"./rawSql\";\nimport { ISelectStatement } from \"./statements/select\";\nimport { IValuesStatement } from \"./statements/values\";\n\nexport interface ICTETerm extends IBaseToken<TokenType.CTE> {\n  _recursive: boolean;\n  _values: {\n    table: string;\n    columns: string[];\n    select: ISelectStatement | IValuesStatement | IBaseToken<TokenType.RawSql>;\n  }[];\n}\n\nexport interface ICTEState {\n  _cteValue?: ICTETerm;\n\n  with: typeof With;\n  withRecursive: typeof withRecursive;\n  withoutWith: typeof withoutWith;\n}\n\nconst cteTerm = (args: {\n  table: string;\n  columns: string[];\n  recursive: boolean;\n  select: ISelectStatement | IValuesStatement | IBaseToken<TokenType.RawSql>;\n}): ICTETerm => {\n  return {\n    type: TokenType.CTE,\n    _recursive: args.recursive,\n    _values: [\n      {\n        table: args.table,\n        columns: args.columns,\n        select: args.select,\n      },\n    ],\n    toSql() {\n      return sql.join(\n        [\n          sql`WITH`,\n          this._recursive ? sql`RECURSIVE` : null,\n          sql.join(\n            this._values.map(\n              (v) =>\n                sql`${sql.liter(v.table)}(${sql.join(\n                  v.columns.map(sql.liter)\n                )}) AS (${v.select})`\n            )\n          ),\n        ].filter((b) => b),\n        \" \"\n      );\n    },\n  };\n};\n\nconst cteTermState = <T extends ICTEState>(\n  state: T,\n  args: {\n    table: string;\n    columns: string[];\n    recursive: boolean;\n    select: ISelectStatement | IValuesStatement | ISql;\n  }\n): T => {\n  if (state._cteValue?._recursive === true && args.recursive === false) {\n    throw new Error(\"WITH is already recursive\");\n  }\n\n  if (state._cteValue?._recursive === false && args.recursive === true) {\n    throw new Error(\"WITH is not recursive\");\n  }\n\n  return {\n    ...state,\n    _cteValue: state._cteValue\n      ? {\n          ...state._cteValue,\n          values: [...state._cteValue._values, {}],\n        }\n      : cteTerm({\n          table: args.table,\n          columns: args.columns,\n          recursive: args.recursive,\n          select: sql.isSql(args.select)\n            ? buildRawSql(args.select)\n            : args.select,\n        }),\n  };\n};\n\nexport function With<T extends ICTEState>(\n  this: T,\n  args: {\n    table: string;\n    columns: string[];\n    select: ISelectStatement | IValuesStatement | ISql;\n  }\n): T {\n  return cteTermState(this, { ...args, recursive: false });\n}\n\nexport function withRecursive<T extends ICTEState>(\n  this: T,\n  args: {\n    table: string;\n    columns: string[];\n    select: ISelectStatement | IValuesStatement | ISql;\n  }\n): T {\n  return cteTermState(this, { ...args, recursive: true });\n}\n\nexport function withoutWith<T extends ICTEState>(this: T): T {\n  return { ...this, cteValue: undefined };\n}\n","import { ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../types\";\nimport { alias } from \"./alias\";\nimport { toToken } from \"./rawSql\";\nimport { ISelectStatement } from \"./statements/select\";\n\ntype IReturnValue = {\n  _toSelect: \"*\" | string | ISelectStatement | IBaseToken;\n  _alias?: string;\n};\nexport interface IReturningClause extends IBaseToken<TokenType.Returning> {\n  _values: IReturnValue[];\n}\n\ntype IReturningArg =\n  | \"*\"\n  | string\n  | ISqlAdapter\n  | IBaseToken\n  | { [key: string]: ISqlAdapter | string | ISelectStatement };\n\nexport interface IReturningState {\n  _returningValue: IReturningClause;\n\n  returning: typeof returningForState;\n  withoutReturning: typeof withoutReturningForState;\n}\n\nexport const returning = (...args: IReturningArg[]): IReturningClause => {\n  return {\n    type: TokenType.Returning,\n    _values: args.flatMap((arg): IReturnValue | IReturnValue[] => {\n      if (sql.isSql(arg) || isToken(arg)) {\n        return { _toSelect: toToken(arg) };\n      } else if (typeof arg === \"string\") {\n        return { _toSelect: arg };\n      } else {\n        return Object.entries(arg).map(([columnOrAs, aliasOrQuery]) => {\n          return typeof aliasOrQuery === \"string\"\n            ? { _toSelect: columnOrAs, _alias: aliasOrQuery }\n            : { _toSelect: toToken(aliasOrQuery), _alias: columnOrAs };\n        });\n      }\n    }),\n    toSql() {\n      return this._values.length > 0\n        ? sql`RETURNING ${sql.join(\n            this._values.map((val) => {\n              if (val._toSelect === \"*\") {\n                return sql`*`;\n              } else {\n                return val._alias\n                  ? alias(val._toSelect, val._alias)\n                  : val._toSelect;\n              }\n            })\n          )}`\n        : sql.empty;\n    },\n  };\n};\n\nexport function returningForState<T extends IReturningState>(\n  this: T,\n  ...args: IReturningArg[]\n): T {\n  return {\n    ...this,\n    _returningValue: {\n      ...this._returningValue,\n      _values: [...this._returningValue._values, ...returning(...args)._values],\n    },\n  };\n}\n\nexport function withoutReturningForState<T extends IReturningState>(\n  this: T\n): T {\n  return {\n    ...this,\n    _returningValue: returning(),\n  };\n}\n","import { IBaseToken, TokenType } from \"../types\";\nimport {\n  and,\n  conditionValuesToToken,\n  IBinaryOperator,\n  IConditionValue,\n  or,\n} from \"./binary\";\nimport { IUnaryOperator } from \"./unary\";\n\nexport interface IWhereState {\n  _whereValue?: IBaseToken<TokenType.RawSql> | IBinaryOperator | IUnaryOperator;\n\n  where: typeof where;\n  orWhere: typeof orWhere;\n}\n\nconst constructWhere = function <T extends IWhereState>(\n  state: T,\n  andOrOr: \"and\" | \"or\",\n  values: IConditionValue[]\n): T {\n  const finalValues = state._whereValue\n    ? [state._whereValue, ...conditionValuesToToken(values)]\n    : conditionValuesToToken(values);\n\n  if (finalValues.length > 1) {\n    return {\n      ...state,\n      _whereValue: andOrOr === \"and\" ? and(...finalValues) : or(...finalValues),\n    };\n  } else {\n    return { ...state, _whereValue: finalValues[0] };\n  }\n};\n\nexport function where<T extends IWhereState>(\n  this: T,\n  ...values: IConditionValue[]\n): T {\n  return constructWhere(this, \"and\", values);\n}\n\nexport function orWhere<T extends IWhereState>(\n  this: T,\n  ...values: IConditionValue[]\n): T {\n  return constructWhere(this, \"or\", values);\n}\n","import { IContainsTable, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../../types\";\nimport { ICTEState, With, withoutWith, withRecursive } from \"../cte\";\nimport {\n  IReturningState,\n  returning,\n  returningForState,\n  withoutReturningForState,\n} from \"../returning\";\nimport { IWhereState, orWhere, where } from \"../where\";\n\nexport interface IDeleteStatement\n  extends IBaseToken<TokenType.Delete>,\n    ICTEState,\n    IWhereState,\n    IReturningState {\n  _deleteTable: IContainsTable;\n}\n\nexport const deleteFrom = (tbl: string | IContainsTable): IDeleteStatement => {\n  return {\n    type: TokenType.Delete,\n    _deleteTable: typeof tbl === \"string\" ? sql.table(tbl) : tbl,\n    _returningValue: returning(),\n\n    with: With,\n    withoutWith,\n    withRecursive,\n\n    where,\n    orWhere,\n\n    returning: returningForState,\n    withoutReturning: withoutReturningForState,\n\n    toSql() {\n      return sql.join(\n        [\n          this._cteValue ? this._cteValue : null,\n          sql`DELETE FROM ${this._deleteTable}`,\n          this._whereValue ? sql`WHERE ${this._whereValue}` : null,\n          this._returningValue,\n        ].filter((v) => v),\n        \" \"\n      );\n    },\n  };\n};\n","export interface IOrReplaceState {\n  _orReplaceValue?: \"ABORT\" | \"FAIL\" | \"IGNORE\" | \"REPLACE\" | \"ROLLBACK\";\n\n  orAbort: typeof orAbort;\n  orFail: typeof orFail;\n  orIgnore: typeof orIgnore;\n  orReplace: typeof orReplace;\n  orRollback: typeof orRollback;\n}\n\nexport function orAbort<T extends IOrReplaceState>(this: T): T {\n  return { ...this, _orReplaceValue: \"ABORT\" };\n}\n\nexport function orFail<T extends IOrReplaceState>(this: T): T {\n  return { ...this, _orReplaceValue: \"FAIL\" };\n}\n\nexport function orIgnore<T extends IOrReplaceState>(this: T): T {\n  return { ...this, _orReplaceValue: \"IGNORE\" };\n}\n\nexport function orReplace<T extends IOrReplaceState>(this: T): T {\n  return { ...this, _orReplaceValue: \"REPLACE\" };\n}\n\nexport function orRollback<T extends IOrReplaceState>(this: T): T {\n  return { ...this, _orReplaceValue: \"ROLLBACK\" };\n}\n","import { IPrimitiveValue, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\nimport { toToken } from \"./rawSql\";\nimport { wrapParentheses } from \"./utils\";\n\nexport interface ILimitOffsetTerm\n  extends IBaseToken<TokenType.LimitOffsetTerm> {\n  _limitValue?: IBaseToken;\n  _offsetValue?: IBaseToken;\n}\n\nexport interface ILimitOffsetState {\n  _limitOffsetValue: ILimitOffsetTerm;\n\n  limit: typeof limit;\n  offset: typeof offset;\n  withoutLimit: typeof withoutLimit;\n  withoutOffset: typeof withoutOffset;\n}\n\nexport const buildInitialLimitOffsetState = (): ILimitOffsetTerm => {\n  return {\n    type: TokenType.LimitOffsetTerm,\n    toSql() {\n      return this._limitValue\n        ? sql.join(\n            [\n              this._limitValue\n                ? sql`LIMIT ${wrapParentheses(this._limitValue)}`\n                : null,\n              this._offsetValue && this._limitValue\n                ? sql`OFFSET ${wrapParentheses(this._offsetValue)}`\n                : null,\n            ].filter((v) => v),\n            \" \"\n          )\n        : sql.empty;\n    },\n  };\n};\n\nexport function limit<T extends ILimitOffsetState>(\n  this: T,\n  val: IBaseToken | ISqlAdapter | IPrimitiveValue\n): T {\n  return {\n    ...this,\n    _limitOffsetValue: { ...this._limitOffsetValue, _limitValue: toToken(val) },\n  };\n}\n\nexport function withoutLimit<T extends ILimitOffsetState>(this: T): T {\n  return {\n    ...this,\n    _limitOffsetValue: { ...this._limitOffsetValue, _limitValue: undefined },\n  };\n}\n\nexport function offset<T extends ILimitOffsetState>(\n  this: T,\n  val: IBaseToken | ISqlAdapter | IPrimitiveValue\n): T {\n  return {\n    ...this,\n    _limitOffsetValue: {\n      ...this._limitOffsetValue,\n      _offsetValue: toToken(val),\n    },\n  };\n}\n\nexport function withoutOffset<T extends ILimitOffsetState>(this: T): T {\n  return {\n    ...this,\n    _limitOffsetValue: { ...this._limitOffsetValue, _offsetValue: undefined },\n  };\n}\n","import { IPrimitiveValue, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../../types\";\nimport {\n  except,\n  ICompoundState,\n  intersect,\n  union,\n  unionAll,\n  withoutCompound,\n} from \"../compounds\";\nimport { ICTEState, With, withoutWith, withRecursive } from \"../cte\";\nimport {\n  buildInitialLimitOffsetState,\n  ILimitOffsetState,\n  limit,\n  offset,\n  withoutLimit,\n  withoutOffset,\n} from \"../limitOffset\";\nimport { IOrderState, orderBy, withoutOrder } from \"../order\";\n\nexport interface IValuesStatement\n  extends IBaseToken<TokenType.Values>,\n    IOrderState,\n    ICompoundState,\n    ILimitOffsetState,\n    ICTEState {\n  _values: (IBaseToken | ISqlAdapter | IPrimitiveValue)[][];\n}\n\nexport const values = (\n  ...vals: (IBaseToken | ISqlAdapter | IPrimitiveValue)[][]\n): IValuesStatement => {\n  return {\n    type: TokenType.Values,\n    _values: vals,\n    _compoundValues: [],\n    _orderByValues: [],\n    _limitOffsetValue: buildInitialLimitOffsetState(),\n\n    orderBy,\n    withoutOrder,\n\n    union,\n    unionAll,\n    intersect,\n    except,\n    withoutCompound,\n\n    limit,\n    withoutLimit,\n    offset,\n    withoutOffset,\n\n    withoutWith,\n    withRecursive,\n    with: With,\n    toSql() {\n      return sql.join(\n        [\n          this._cteValue ? this._cteValue : null,\n          sql`VALUES ${sql.join(\n            this._values.map((val) => sql`(${sql.join(val)})`)\n          )}`,\n          this._compoundValues.length > 0\n            ? sql.join(this._compoundValues, \" \")\n            : null,\n          this._orderByValues.length > 0\n            ? sql.join([sql`ORDER BY`, sql.join(this._orderByValues)], \" \")\n            : null,\n          this._limitOffsetValue.toSql().isEmpty\n            ? null\n            : this._limitOffsetValue,\n        ].filter((v) => v),\n        \" \"\n      );\n    },\n  };\n};\n\nexport const isValues = (val: unknown): val is IValuesStatement => {\n  return (\n    val !== null &&\n    typeof val === \"object\" &&\n    (val as IValuesStatement).type === TokenType.Values\n  );\n};\n","import { ISql, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\nimport { toToken } from \"./rawSql\";\nimport { ISelectStatement, isSelect } from \"./statements/select\";\nimport { isValues, IValuesStatement } from \"./statements/values\";\n\ntype IUnionArg = ISelectStatement | IValuesStatement | ISql;\n\nexport interface ICompoundOperator extends IBaseToken<TokenType.OrderTerm> {\n  _compoundType: \"UNION\" | \"UNION ALL\" | \"INTERSECT\" | \"EXCEPT\";\n  _value: ISelectStatement | IValuesStatement | IBaseToken<TokenType.RawSql>;\n}\n\nexport interface ICompoundState {\n  _compoundValues: ICompoundOperator[];\n\n  union: typeof union;\n  unionAll: typeof unionAll;\n  intersect: typeof intersect;\n  except: typeof except;\n  withoutCompound: typeof withoutCompound;\n}\n\nconst makeCompounds = <T extends ICompoundState>(\n  state: T,\n  type: \"UNION\" | \"UNION ALL\" | \"INTERSECT\" | \"EXCEPT\",\n  values: IUnionArg[]\n): T => {\n  return {\n    ...state,\n    _compoundValues: [\n      ...state._compoundValues,\n      ...values.map((val): ICompoundOperator => {\n        const token = toToken(val);\n\n        return {\n          type: TokenType.OrderTerm,\n          _compoundType: type,\n          _value: isSelect(token)\n            ? token.withoutWith().withoutLimit().withoutOrder().withoutOffset()\n            : isValues(token)\n            ? token.withoutWith().withoutLimit().withoutOrder().withoutOffset()\n            : (token as IValuesStatement | IBaseToken<TokenType.RawSql>),\n          toSql() {\n            return sql`${sql.raw(this._compoundType)} ${this._value}`;\n          },\n        };\n      }),\n    ],\n  };\n};\n\nexport function union<T extends ICompoundState>(\n  this: T,\n  ...values: IUnionArg[]\n) {\n  return makeCompounds(this, \"UNION\", values);\n}\nexport function unionAll<T extends ICompoundState>(\n  this: T,\n  ...values: IUnionArg[]\n) {\n  return makeCompounds(this, \"UNION ALL\", values);\n}\nexport function intersect<T extends ICompoundState>(\n  this: T,\n  ...values: IUnionArg[]\n) {\n  return makeCompounds(this, \"INTERSECT\", values);\n}\nexport function except<T extends ICompoundState>(\n  this: T,\n  ...values: IUnionArg[]\n) {\n  return makeCompounds(this, \"EXCEPT\", values);\n}\n\nexport function withoutCompound<T extends ICompoundState>(this: T) {\n  return { ...this, _compoundValues: [] };\n}\n","import { IContainsTable, ISql, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken } from \"../types\";\nimport { alias } from \"./alias\";\nimport { toToken } from \"./rawSql\";\nimport { wrapParentheses } from \"./utils\";\n\nexport interface IFromState {\n  _fromValues: (\n    | IContainsTable\n    | IBaseToken\n    | { select: IContainsTable | IBaseToken; alias: string }\n  )[];\n\n  from: typeof from;\n}\n\nexport function from<T extends IFromState>(\n  this: T,\n  ...values: (\n    | IBaseToken\n    | ISqlAdapter\n    | IContainsTable\n    | string\n    | Record<string, IBaseToken | ISqlAdapter | IContainsTable | string>\n  )[]\n): T {\n  return {\n    ...this,\n    _fromValues: [\n      ...this._fromValues,\n      ...values\n        .map((v) => {\n          if (typeof v === \"string\") {\n            return sql.table(v);\n          } else if (isToken(v) || sql.isSql(v) || sql.isTable(v)) {\n            return toToken(wrapParentheses(v));\n          } else {\n            return Object.entries(v).map(([k, v]) => ({\n              select:\n                typeof v === \"string\"\n                  ? sql.table(v)\n                  : toToken(wrapParentheses(v)),\n              alias: k,\n            }));\n          }\n        })\n        .flat(),\n    ],\n  };\n}\n\nexport const fromToSql = (state: IFromState): ISql | null => {\n  return state._fromValues.length > 0\n    ? sql.join(\n        state._fromValues.map((v) =>\n          isToken(v) || sql.isTable(v) ? v : alias(v.select, v.alias)\n        )\n      )\n    : null;\n};\n","import { ISql, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../../types\";\nimport { alias } from \"../alias\";\nimport {\n  except,\n  ICompoundState,\n  intersect,\n  union,\n  unionAll,\n  withoutCompound,\n} from \"../compounds\";\nimport { ICTEState, With, withoutWith, withRecursive } from \"../cte\";\nimport { from, fromToSql, IFromState } from \"../from\";\nimport {\n  IJoinState,\n  join,\n  joinCross,\n  joinFull,\n  joinFullNatural,\n  joinFullNaturalOuter,\n  joinFullOuter,\n  joinInner,\n  joinInnerNatural,\n  joinLeft,\n  joinLeftNatural,\n  joinLeftNaturalOuter,\n  joinLeftOuter,\n  joinNatural,\n  joinRight,\n  joinRightNatural,\n  joinRightNaturalOuter,\n  joinRightOuter,\n  withoutJoin,\n} from \"../join\";\nimport {\n  buildInitialLimitOffsetState,\n  ILimitOffsetState,\n  limit,\n  offset,\n  withoutLimit,\n  withoutOffset,\n} from \"../limitOffset\";\nimport { IOrderState, orderBy, withoutOrder } from \"../order\";\nimport { toToken } from \"../rawSql\";\nimport { IWhereState, orWhere, where } from \"../where\";\nimport { IValuesStatement } from \"./values\";\n\nexport const isSelect = (val: unknown): val is ISelectStatement => {\n  return (\n    val !== null &&\n    typeof val === \"object\" &&\n    (val as ISelectStatement).type === TokenType.Select\n  );\n};\n\n// TODO: add filter, window support\nexport interface ISelectStatement\n  extends IBaseToken<TokenType.Select>,\n    IOrderState,\n    ICompoundState,\n    ILimitOffsetState,\n    ICTEState,\n    IWhereState,\n    IFromState,\n    IJoinState {\n  _distinctValue: boolean;\n\n  _selectValues: {\n    toSelect: \"*\" | string | ISelectStatement | IBaseToken;\n    alias?: string;\n  }[];\n\n  _groupByValues: (IBaseToken | string)[];\n  _havingValue?: IBaseToken;\n\n  distinct(val: boolean): ISelectStatement;\n  select(...args: ISelectArgType[]): ISelectStatement;\n\n  groupBy(...values: (IBaseToken | ISqlAdapter | string)[]): ISelectStatement;\n  having(val: IBaseToken | ISqlAdapter): ISelectStatement;\n}\n\ntype ISelectArgType =\n  | \"*\"\n  | string\n  | ISqlAdapter\n  | ISelectStatement\n  | IValuesStatement\n  | { [key: string]: ISqlAdapter | string | ISelectStatement }\n  | IBaseToken;\n\nconst selectArgsToValues = (\n  args: ISelectArgType[]\n): ISelectStatement[\"_selectValues\"] => {\n  if (args === null || args === undefined || args.length === 0)\n    return [{ toSelect: \"*\" }];\n\n  return args.flatMap((arg, i) => {\n    if (arg === \"*\" && i === 0) return { toSelect: \"*\" };\n    if (typeof arg === \"string\") return { toSelect: arg };\n    if (isToken(arg) || sql.isSql(arg)) return { toSelect: toToken(arg) };\n\n    return Object.entries(arg).map(([columnOrAs, aliasOrQuery]) =>\n      typeof aliasOrQuery === \"string\"\n        ? { toSelect: columnOrAs, alias: aliasOrQuery }\n        : { toSelect: toToken(aliasOrQuery), alias: columnOrAs }\n    );\n  });\n};\n\nexport const select = (...selectArgs: ISelectArgType[]): ISelectStatement => {\n  return {\n    type: TokenType.Select,\n    _fromValues: [],\n    _selectValues: selectArgsToValues(selectArgs),\n    _distinctValue: false,\n    _groupByValues: [],\n    _compoundValues: [],\n    _orderByValues: [],\n    _joinValues: [],\n    _limitOffsetValue: buildInitialLimitOffsetState(),\n    select(...selectArgs: ISelectArgType[]): ISelectStatement {\n      return {\n        ...this,\n        _selectValues: [\n          ...this._selectValues,\n          ...selectArgsToValues(selectArgs),\n        ],\n      };\n    },\n    distinct(val: boolean): ISelectStatement {\n      return {\n        ...this,\n        _distinctValue: val,\n      };\n    },\n    from,\n    where,\n    orWhere,\n    limit,\n    offset,\n    withoutLimit,\n    withoutOffset,\n    groupBy(...values: (IBaseToken | ISql | string)[]): ISelectStatement {\n      return {\n        ...this,\n        _groupByValues: values.map((val) =>\n          typeof val === \"string\" ? val : toToken(val)\n        ),\n      };\n    },\n    having(val: IBaseToken | ISql): ISelectStatement {\n      return { ...this, _havingValue: toToken(val) };\n    },\n    orderBy,\n    withoutOrder,\n\n    with: With,\n    withoutWith,\n    withRecursive,\n\n    union,\n    unionAll,\n    intersect,\n    except,\n    withoutCompound,\n\n    withoutJoin,\n\n    join,\n    joinCross,\n\n    joinNatural,\n\n    joinLeft,\n    joinLeftOuter,\n    joinLeftNatural: joinLeftNatural,\n    joinLeftNaturalOuter: joinLeftNaturalOuter,\n\n    joinRight,\n    joinRightOuter,\n    joinRightNatural: joinRightNatural,\n    joinRightNaturalOuter: joinRightNaturalOuter,\n\n    joinFull,\n    joinFullOuter,\n    joinFullNatural: joinFullNatural,\n    joinFullNaturalOuter: joinFullNaturalOuter,\n\n    joinInner,\n    joinInnerNatural: joinInnerNatural,\n\n    toSql() {\n      return sql.join(\n        [\n          this._cteValue ? this._cteValue : null,\n          sql`SELECT`,\n          this._distinctValue ? sql`DISTINCT` : null,\n          sql.join(\n            this._selectValues.map((val) => {\n              if (val.toSelect === \"*\") {\n                return sql`*`;\n              } else if (typeof val.toSelect === \"string\") {\n                return sql.liter(val.toSelect);\n              } else {\n                return val.alias\n                  ? alias(val.toSelect, val.alias)\n                  : val.toSelect;\n              }\n            })\n          ),\n          this._fromValues.length > 0 || this._joinValues.length > 0\n            ? sql`FROM`\n            : null,\n          fromToSql(this),\n          this._joinValues.length > 0\n            ? sql.join(\n                this._joinValues.map((expr) => expr.toSql()),\n                \" \"\n              )\n            : null,\n          this._whereValue ? sql`WHERE ${this._whereValue}` : null,\n          this._groupByValues.length > 0\n            ? sql`GROUP BY ${sql.join(\n                this._groupByValues.map((val) =>\n                  typeof val === \"string\" ? sql.liter(val) : val\n                )\n              )}`\n            : null,\n          this._groupByValues.length > 0 && this._havingValue\n            ? sql`HAVING ${this._havingValue}`\n            : null,\n          this._compoundValues.length > 0\n            ? sql.join(this._compoundValues, \" \")\n            : null,\n          this._orderByValues.length > 0\n            ? sql.join([sql`ORDER BY`, sql.join(this._orderByValues)], \" \")\n            : null,\n          this._limitOffsetValue.toSql().isEmpty\n            ? null\n            : this._limitOffsetValue,\n        ].filter((v) => v),\n        \" \"\n      );\n    },\n  };\n};\n","import {\n  IContainsTable,\n  IPrimitiveValue,\n  ISqlAdapter,\n  sql,\n} from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../../types\";\nimport { ICTEState, With, withoutWith, withRecursive } from \"../cte\";\nimport {\n  IOrReplaceState,\n  orAbort,\n  orFail,\n  orIgnore,\n  orReplace,\n  orRollback,\n} from \"../orReplace\";\nimport { buildRawSql } from \"../rawSql\";\nimport {\n  IReturningState,\n  returning,\n  returningForState,\n  withoutReturningForState,\n} from \"../returning\";\nimport { ISelectStatement, isSelect } from \"./select\";\nimport { isValues, IValuesStatement } from \"./values\";\n\n// TODO: on conflict support\nexport interface IInsertStatement\n  extends IBaseToken<TokenType.Insert>,\n    ICTEState,\n    IReturningState,\n    IOrReplaceState {\n  _intoTable?: IContainsTable;\n  _columnNames: string[];\n\n  _toInsertValue?:\n    | IValuesStatement\n    | ISelectStatement\n    | { columnName: string; value: IPrimitiveValue | IBaseToken }[][];\n\n  setColumnNames(columnNames: string[]): IInsertStatement;\n  withoutColumnNames(): IInsertStatement;\n\n  insert(arg: IInsertArg): IInsertStatement;\n  withoutInsert(): IInsertStatement;\n\n  withoutInto(): IInsertStatement;\n  into(val: string | IContainsTable): IInsertStatement;\n}\n\ntype IRecArg =\n  | Record<string, IPrimitiveValue | IBaseToken | ISqlAdapter>\n  | Record<string, IPrimitiveValue | IBaseToken | ISqlAdapter>[];\ntype IInsertArg = IValuesStatement | ISelectStatement | IRecArg;\n\nconst mapRecordArg = (arg: IRecArg) => {\n  return (Array.isArray(arg) ? arg : [arg]).map((it) =>\n    Object.entries(it).map(([columnName, value]) => {\n      return {\n        columnName,\n        value: sql.isSql(value) && !isToken(value) ? buildRawSql(value) : value,\n      };\n    })\n  );\n};\n\nconst applyInsertArg = (\n  state: IInsertStatement,\n  arg: IInsertArg\n): IInsertStatement => {\n  if (\n    state._toInsertValue &&\n    (isSelect(state._toInsertValue) || isValues(state._toInsertValue))\n  ) {\n    throw new Error(\n      \"Insert value is already state. If you want to change insert values user resetInsert() before.\"\n    );\n  }\n\n  if (isSelect(arg) || isValues(arg)) {\n    return { ...state, _toInsertValue: arg };\n  }\n\n  return {\n    ...state,\n    _toInsertValue: Array.isArray(state._toInsertValue)\n      ? [...state._toInsertValue, ...mapRecordArg(arg)]\n      : mapRecordArg(arg),\n  };\n};\n\nexport const insert = (insertArg: IInsertArg): IInsertStatement => {\n  return {\n    type: TokenType.Insert,\n    _returningValue: returning(),\n    _columnNames: [],\n    _toInsertValue:\n      isSelect(insertArg) || isValues(insertArg)\n        ? insertArg\n        : mapRecordArg(insertArg),\n\n    with: With,\n    withRecursive,\n    withoutWith,\n\n    orAbort,\n    orFail,\n    orIgnore,\n    orReplace,\n    orRollback,\n\n    returning: returningForState,\n    withoutReturning: withoutReturningForState,\n\n    setColumnNames(names: string[]): IInsertStatement {\n      return { ...this, _columnNames: names };\n    },\n    withoutColumnNames(): IInsertStatement {\n      return { ...this, _columnNames: [] };\n    },\n\n    insert(arg: IInsertArg): IInsertStatement {\n      return applyInsertArg(this, arg);\n    },\n    withoutInsert(): IInsertStatement {\n      return { ...this, _toInsertValue: undefined };\n    },\n\n    into(val: string | IContainsTable): IInsertStatement {\n      return {\n        ...this,\n        _intoTable: typeof val === \"string\" ? sql.table(val) : val,\n      };\n    },\n    withoutInto(): IInsertStatement {\n      return { ...this, _intoTable: undefined };\n    },\n\n    toSql() {\n      if (!this._toInsertValue) {\n        throw new Error(\"Insert values are not set\");\n      }\n\n      if (!this._intoTable) {\n        throw new Error(\"Into table is not set\");\n      }\n\n      const columns =\n        this._columnNames.length > 0\n          ? this._columnNames\n          : Array.isArray(this._toInsertValue)\n          ? this._toInsertValue[0].map(({ columnName }) => columnName)\n          : [];\n\n      return sql.join(\n        [\n          this._cteValue ? this._cteValue : null,\n          sql`INSERT`,\n          this._orReplaceValue\n            ? sql`OR ${sql.raw(this._orReplaceValue)}`\n            : null,\n          sql`INTO`,\n          this._intoTable,\n          columns.length > 0\n            ? sql`(${sql.join(columns.map((c) => sql.liter(c)))})`\n            : null,\n          isValues(this._toInsertValue) || isSelect(this._toInsertValue)\n            ? this._toInsertValue\n            : sql`VALUES ${sql.join(\n                this._toInsertValue.map((toInsertColumns) => {\n                  const toInsert: (IPrimitiveValue | IBaseToken)[] = Array(\n                    toInsertColumns.length\n                  );\n\n                  for (const { columnName, value } of toInsertColumns) {\n                    const index = columns.indexOf(columnName);\n\n                    if (index === -1) {\n                      throw new Error(\n                        `Column ${columnName} is not present at columns set: ${columns}. Make sure that you set all columns with setColumnNames() or each insert objects have the same keys present. Tried to insert: ${JSON.stringify(\n                          toInsertColumns\n                        )}`\n                      );\n                    }\n\n                    toInsert[index] = value;\n                  }\n\n                  return sql`(${sql.join(toInsert)})`;\n                })\n              )}`,\n          this._returningValue,\n        ].filter((v) => v),\n        \" \"\n      );\n    },\n  };\n};\n","import {\n  IContainsTable,\n  IPrimitiveValue,\n  ISqlAdapter,\n  sql,\n} from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../../types\";\nimport { ICTEState, With, withoutWith, withRecursive } from \"../cte\";\nimport { from, fromToSql, IFromState } from \"../from\";\nimport {\n  IJoinState,\n  join,\n  joinCross,\n  joinFull,\n  joinFullNatural,\n  joinFullNaturalOuter,\n  joinFullOuter,\n  joinInner,\n  joinInnerNatural,\n  joinLeft,\n  joinLeftNatural,\n  joinLeftNaturalOuter,\n  joinLeftOuter,\n  joinNatural,\n  joinRight,\n  joinRightNatural,\n  joinRightNaturalOuter,\n  joinRightOuter,\n  withoutJoin,\n} from \"../join\";\nimport {\n  IOrReplaceState,\n  orAbort,\n  orFail,\n  orIgnore,\n  orReplace,\n  orRollback,\n} from \"../orReplace\";\nimport { buildRawSql } from \"../rawSql\";\nimport {\n  IReturningState,\n  returning,\n  returningForState,\n  withoutReturningForState,\n} from \"../returning\";\nimport { wrapParentheses } from \"../utils\";\nimport { IWhereState, orWhere, where } from \"../where\";\nimport { ISelectStatement } from \"./select\";\nimport { IValuesStatement } from \"./values\";\n\ntype ISetValue =\n  | {\n      columnName: string;\n      toSet:\n        | IBaseToken<TokenType.RawSql>\n        | IPrimitiveValue\n        | ISelectStatement\n        | IValuesStatement;\n    }\n  | IBaseToken<TokenType.RawSql>;\n\nexport interface IUpdateStatement\n  extends IBaseToken<TokenType.Update>,\n    ICTEState,\n    IWhereState,\n    IFromState,\n    IReturningState,\n    IOrReplaceState,\n    IJoinState {\n  _updateTable: IContainsTable;\n  _setValues: ISetValue[];\n\n  set(...args: ISetArgType[]): IUpdateStatement;\n}\n\ntype ISetArgType =\n  | ISqlAdapter\n  | {\n      [key: string]:\n        | ISqlAdapter\n        | IBaseToken<TokenType.RawSql>\n        | IPrimitiveValue\n        | ISelectStatement\n        | IValuesStatement;\n    }\n  | IBaseToken<TokenType.RawSql>;\n\nexport const update = (tbl: string | IContainsTable): IUpdateStatement => {\n  return {\n    type: TokenType.Update,\n    _updateTable: typeof tbl === \"string\" ? sql.table(tbl) : tbl,\n    _setValues: [],\n    _fromValues: [],\n    _joinValues: [],\n    _returningValue: returning(),\n\n    with: With,\n    withoutWith,\n    withRecursive,\n\n    from,\n\n    where,\n    orWhere,\n\n    returning: returningForState,\n    withoutReturning: withoutReturningForState,\n\n    orAbort,\n    orFail,\n    orIgnore,\n    orReplace,\n    orRollback,\n\n    withoutJoin,\n\n    join,\n    joinCross,\n\n    joinNatural,\n\n    joinLeft,\n    joinLeftOuter,\n    joinLeftNatural: joinLeftNatural,\n    joinLeftNaturalOuter: joinLeftNaturalOuter,\n\n    joinRight,\n    joinRightOuter,\n    joinRightNatural: joinRightNatural,\n    joinRightNaturalOuter: joinRightNaturalOuter,\n\n    joinFull,\n    joinFullOuter,\n    joinFullNatural: joinFullNatural,\n    joinFullNaturalOuter: joinFullNaturalOuter,\n\n    joinInner,\n    joinInnerNatural: joinInnerNatural,\n\n    set(...args: ISetArgType[]): IUpdateStatement {\n      const vals = args.flatMap((m): ISetValue | ISetValue[] => {\n        if (isToken(m)) {\n          return m;\n        } else if (sql.isSql(m)) {\n          return buildRawSql(m);\n        } else {\n          return Object.entries(m).map(([key, val]) => {\n            return {\n              columnName: key,\n              toSet: !isToken(val) && sql.isSql(val) ? buildRawSql(val) : val,\n            };\n          });\n        }\n      });\n\n      return { ...this, _setValues: [...this._setValues, ...vals] };\n    },\n\n    toSql() {\n      return sql.join(\n        [\n          this._cteValue ? this._cteValue : null,\n          sql`UPDATE`,\n          this._orReplaceValue\n            ? sql`OR ${sql.raw(this._orReplaceValue)}`\n            : null,\n          this._updateTable,\n          sql`SET`,\n          sql.join(\n            this._setValues.map((val) =>\n              isToken(val)\n                ? val\n                : sql`${sql.liter(val.columnName)} = ${wrapParentheses(\n                    val.toSet\n                  )}`\n            )\n          ),\n          this._fromValues.length > 0 || this._joinValues.length > 0\n            ? sql`FROM`\n            : null,\n          fromToSql(this),\n          this._joinValues.length > 0\n            ? sql.join(\n                this._joinValues.map((expr) => expr.toSql()),\n                \" \"\n              )\n            : null,\n          this._whereValue ? sql`WHERE ${this._whereValue}` : null,\n          this._returningValue,\n        ].filter((v) => v),\n        \" \"\n      );\n    },\n  };\n};\n","import { IPrimitiveValue, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\n\nexport interface IUnaryOperator extends IBaseToken<TokenType.Unary> {\n  _operator: \"NOT\";\n  _expr: IBaseToken | ISqlAdapter | IPrimitiveValue;\n}\n\nexport const not = (\n  expr: IBaseToken | ISqlAdapter | IPrimitiveValue\n): IUnaryOperator => {\n  return {\n    _operator: \"NOT\",\n    type: TokenType.Unary,\n    _expr: expr,\n    toSql() {\n      return sql`NOT (${this._expr})`;\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"module"}