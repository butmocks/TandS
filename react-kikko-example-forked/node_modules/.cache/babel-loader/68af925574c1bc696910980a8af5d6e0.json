{"ast":null,"code":"import _objectSpread from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/home/butmocks/Projects/TandS/react-kikko-example-forked/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { initDbClient, stopDb, withSuppressedLog, runInTransaction } from \"@kikko-land/kikko\";\nimport React, { useState, useEffect, useContext, useMemo, useCallback, useRef } from \"react\";\nimport { listenQueries } from \"@kikko-land/reactive-queries-plugin\";\nvar DbContext = React.createContext({\n  type: \"notInitialized\"\n});\nvar DbProvider = function DbProvider(_ref) {\n  var children = _ref.children,\n    config = _ref.config;\n  var _useState = useState({\n      type: \"notInitialized\"\n    }),\n    _useState2 = _slicedToArray(_useState, 2),\n    currentState = _useState2[0],\n    setCurrentState = _useState2[1];\n  useEffect(function () {\n    var shouldBeStopped = false;\n    var initializedDb = void 0;\n    var cb = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var db;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                setCurrentState({\n                  type: \"initializing\",\n                  config: config\n                });\n                _context.next = 3;\n                return initDbClient(config);\n              case 3:\n                db = _context.sent;\n                initializedDb = db;\n                if (!shouldBeStopped) {\n                  _context.next = 8;\n                  break;\n                }\n                void stopDb(db);\n                return _context.abrupt(\"return\");\n              case 8:\n                setCurrentState({\n                  type: \"initialized\",\n                  db: db,\n                  config: config\n                });\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function cb() {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    void cb();\n    return function () {\n      shouldBeStopped = true;\n      if (initializedDb) {\n        setCurrentState({\n          type: \"notInitialized\"\n        });\n        void stopDb(initializedDb);\n      }\n    };\n  }, [config]);\n  return /* @__PURE__ */React.createElement(DbContext.Provider, {\n    value: currentState\n  }, children);\n};\nvar useDbState = function useDbState() {\n  return useContext(DbContext);\n};\nvar useDb = function useDb() {\n  var res = useDbState();\n  if (res.type === \"initialized\") {\n    return res.db;\n  } else {\n    return void 0;\n  }\n};\nvar useDbStrict = function useDbStrict() {\n  var db = useDb();\n  if (!db) throw new Error(\"DB is not initialized!\");\n  return db;\n};\nvar EnsureDbLoaded = function EnsureDbLoaded(_ref3) {\n  var children = _ref3.children,\n    fallback = _ref3.fallback;\n  var dbState = useDbState();\n  return dbState.type === \"initialized\" ? children : fallback ? fallback : null;\n};\nfunction useQueries(_queries, _opts) {\n  var dbState = useDbState();\n  var _suppressLog = {\n      suppressLog: (_opts == null ? void 0 : _opts.suppressLog) !== void 0 ? _opts.suppressLog : false\n    },\n    suppressLog = _suppressLog.suppressLog;\n  var _useState3 = useState(_queries ? _queries : []),\n    _useState4 = _slicedToArray(_useState3, 2),\n    currentQueries = _useState4[0],\n    setCurrentQueries = _useState4[1];\n  var _useState5 = useState(),\n    _useState6 = _slicedToArray(_useState5, 2),\n    data = _useState6[0],\n    setData = _useState6[1];\n  var _useState7 = useState(_queries ? dbState.type === \"initialized\" ? {\n      type: \"loading\"\n    } : {\n      type: \"waitingDb\"\n    } : {\n      type: \"noSqlPresent\"\n    }),\n    _useState8 = _slicedToArray(_useState7, 2),\n    response = _useState8[0],\n    setResponse = _useState8[1];\n  useEffect(function () {\n    if (currentQueries.length === 0) {\n      setResponse({\n        type: \"noSqlPresent\"\n      });\n      return;\n    }\n    if (dbState.type !== \"initialized\") {\n      setResponse({\n        type: \"waitingDb\"\n      });\n      return;\n    }\n    var db = suppressLog ? withSuppressedLog(dbState.db) : dbState.db;\n    var subscription = listenQueries(db, currentQueries).subscribe(function (result) {\n      setData(result);\n      setResponse({\n        type: \"loaded\"\n      });\n    });\n    return function () {\n      subscription.unsubscribe();\n    };\n  }, [dbState, currentQueries, suppressLog]);\n  useEffect(function () {\n    if (currentQueries.map(function (q) {\n      return q.toSql().hash;\n    }).join() !== (_queries || []).map(function (q) {\n      return q.toSql().hash;\n    }).join()) {\n      setCurrentQueries(_queries || []);\n    }\n  }, [currentQueries, _queries]);\n  return useMemo(function () {\n    if (response.type === \"loaded\") {\n      if (!data) {\n        throw new Error(\"Internal error: response state is loaded, but there is not data!\");\n      }\n      return _objectSpread(_objectSpread({}, response), {}, {\n        data: data\n      });\n    }\n    return _objectSpread(_objectSpread({}, response), {}, {\n      data: data || []\n    });\n  }, [data, response]);\n}\nfunction useQuery(query, _opts) {\n  var queries = useMemo(function () {\n    return query ? [query] : [];\n  }, [query]);\n  var result = useQueries(queries, _opts);\n  return useMemo(function () {\n    var _a;\n    if (result.type === \"loaded\") {\n      if (!result.data) {\n        throw new Error(\"Internal error: response state is loaded, but there is not data!\");\n      }\n      return _objectSpread(_objectSpread({}, result), {}, {\n        data: result.data[0] || []\n      });\n    }\n    return _objectSpread(_objectSpread({}, result), {}, {\n      data: ((_a = result.data) == null ? void 0 : _a[0]) || []\n    });\n  }, [result]);\n}\nfunction useQueryFirstRow(query, _opts) {\n  var res = useQuery(query, _opts);\n  return useMemo(function () {\n    var _a;\n    if (res.type === \"loaded\") {\n      return _objectSpread(_objectSpread({}, res), {}, {\n        data: res.data[0]\n      });\n    }\n    return _objectSpread(_objectSpread({}, res), {}, {\n      data: (_a = res.data) == null ? void 0 : _a[0]\n    });\n  }, [res]);\n}\nfunction useIsMounted() {\n  var isMounted = useRef(false);\n  useEffect(function () {\n    isMounted.current = true;\n    return function () {\n      isMounted.current = false;\n    };\n  }, []);\n  return useCallback(function () {\n    return isMounted.current;\n  }, []);\n}\nfunction useRunQuery(cb, _opts) {\n  var _suppressLog$inTransa = {\n      suppressLog: (_opts == null ? void 0 : _opts.suppressLog) !== void 0 ? _opts.suppressLog : false,\n      inTransaction: (_opts == null ? void 0 : _opts.inTransaction) !== void 0 ? _opts.inTransaction : true\n    },\n    suppressLog = _suppressLog$inTransa.suppressLog,\n    inTransaction = _suppressLog$inTransa.inTransaction;\n  var dbState = useDbState();\n  var isMounted = useIsMounted();\n  var _useState9 = useState(),\n    _useState10 = _slicedToArray(_useState9, 2),\n    data = _useState10[0],\n    setData = _useState10[1];\n  var _useState11 = useState(dbState.type === \"initialized\" ? \"idle\" : \"waitingDb\"),\n    _useState12 = _slicedToArray(_useState11, 2),\n    runStateType = _useState12[0],\n    setRunStateType = _useState12[1];\n  useEffect(function () {\n    if (dbState.type === \"initialized\") {\n      setRunStateType(\"idle\");\n    } else {\n      setRunStateType(\"waitingDb\");\n    }\n  }, [dbState.type]);\n  var toCall = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var _len,\n      args,\n      _key,\n      db,\n      res,\n      _args2 = arguments;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            for (_len = _args2.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = _args2[_key];\n            }\n            if (!(dbState.type !== \"initialized\")) {\n              _context2.next = 3;\n              break;\n            }\n            throw new Error(\"Db not initialized!\");\n          case 3:\n            setRunStateType(\"running\");\n            db = suppressLog ? withSuppressedLog(dbState.db) : dbState.db;\n            _context2.next = 7;\n            return inTransaction ? runInTransaction(db, function (db2) {\n              return cb(db2).apply(void 0, args);\n            }) : cb(db).apply(void 0, args);\n          case 7:\n            res = _context2.sent;\n            if (isMounted()) {\n              setData(res);\n              setRunStateType(\"done\");\n            }\n            return _context2.abrupt(\"return\", res);\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  })), [cb, dbState, inTransaction, isMounted, suppressLog]);\n  var toCallRef = useRef(toCall);\n  useEffect(function () {\n    toCallRef.current = toCall;\n  }, [toCall]);\n  var run = useCallback(function () {\n    return toCallRef.current.apply(toCallRef, arguments);\n  }, []);\n  var result = useMemo(function () {\n    return {\n      type: runStateType,\n      data: data\n    };\n  }, [data, runStateType]);\n  return [run, result];\n}\nfunction useCacheQuery(_query) {\n  var _useState13 = useState(_query),\n    _useState14 = _slicedToArray(_useState13, 2),\n    query = _useState14[0],\n    setQuery = _useState14[1];\n  useEffect(function () {\n    if (query.toSql().hash !== _query.toSql().hash) {\n      setQuery(_query);\n    }\n  }, [_query, query]);\n  return query;\n}\nexport { DbProvider, EnsureDbLoaded, useCacheQuery, useDb, useDbState, useDbStrict, useQueries, useQuery, useQueryFirstRow, useRunQuery };","map":{"version":3,"mappings":"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","names":["DbContext","React","createContext","type","DbProvider","children","config","useState","currentState","setCurrentState","useEffect","shouldBeStopped","initializedDb","cb","initDbClient","db","stopDb","Provider","value","useDbState","useContext","useDb","res","useDbStrict","Error","EnsureDbLoaded","fallback","dbState","_queries","_opts","suppressLog","currentQueries","setCurrentQueries","data","setData","response","setResponse","length","withSuppressedLog","subscription","listenQueries","subscribe","result","unsubscribe","map","q","toSql","hash","join","useMemo","query","useQueries","queries","useQuery","useRef","isMounted","current","useCallback","inTransaction","useIsMounted","runStateType","setRunStateType","args","runInTransaction","db2","toCall","toCallRef","run","_query","setQuery"],"sources":["../src/DbProvider.tsx","../src/hooks/useQueries.tsx"],"sourcesContent":["import {\n  IDbState,\n  IInitDbClientConfig,\n  initDbClient,\n  stopDb,\n} from \"@kikko-land/kikko\";\nimport React, { ReactElement, useContext, useEffect, useState } from \"react\";\n\nexport type IDbInitState =\n  | { type: \"initialized\"; db: IDbState; config: IInitDbClientConfig }\n  | { type: \"notInitialized\" }\n  | { type: \"initializing\"; config: IInitDbClientConfig };\n\nconst DbContext = React.createContext<IDbInitState>({\n  type: \"notInitialized\",\n});\n\nexport const DbProvider: React.FC<{\n  children?: React.ReactNode;\n  config: IInitDbClientConfig;\n}> = ({ children, config }) => {\n  const [currentState, setCurrentState] = useState<IDbInitState>({\n    type: \"notInitialized\",\n  });\n\n  useEffect(() => {\n    let shouldBeStopped = false;\n    let initializedDb: IDbState | undefined = undefined;\n\n    const cb = async () => {\n      setCurrentState({ type: \"initializing\", config });\n\n      const db = await initDbClient(config);\n      initializedDb = db;\n\n      if (shouldBeStopped) {\n        void stopDb(db);\n\n        return;\n      }\n\n      setCurrentState({ type: \"initialized\", db, config });\n    };\n\n    void cb();\n\n    return () => {\n      shouldBeStopped = true;\n\n      if (initializedDb) {\n        setCurrentState({ type: \"notInitialized\" });\n\n        void stopDb(initializedDb);\n      }\n    };\n  }, [config]);\n\n  return (\n    <DbContext.Provider value={currentState}>{children}</DbContext.Provider>\n  );\n};\n\nexport const useDbState = () => {\n  return useContext(DbContext);\n};\n\nexport const useDb = () => {\n  const res = useDbState();\n\n  if (res.type === \"initialized\") {\n    return res.db;\n  } else {\n    return undefined;\n  }\n};\n\nexport const useDbStrict = () => {\n  const db = useDb();\n\n  if (!db) throw new Error(\"DB is not initialized!\");\n\n  return db;\n};\n\nexport const EnsureDbLoaded: React.FC<{\n  children: React.ReactNode;\n  fallback?: React.ReactNode;\n}> = ({ children, fallback }) => {\n  const dbState = useDbState();\n\n  return dbState.type === \"initialized\"\n    ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (children as ReactElement<any, any>)\n    : fallback\n    ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (fallback as ReactElement<unknown, any>)\n    : null;\n};\n","import { runInTransaction, withSuppressedLog } from \"@kikko-land/kikko\";\nimport { IDbState } from \"@kikko-land/kikko\";\nimport { listenQueries } from \"@kikko-land/reactive-queries-plugin\";\nimport { ISqlAdapter } from \"@kikko-land/sql\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { Falsy } from \"rxjs\";\n\nimport { useDbState } from \"../DbProvider\";\nimport {\n  DistributiveOmit,\n  IQueryHookResult,\n  IRunQueryHookResult,\n  ISingleQueryHookResult,\n} from \"./types\";\n\nexport function useQueries<D extends Record<string, unknown>>(\n  _queries: ISqlAdapter[] | Falsy,\n  _opts?: { suppressLog?: boolean; mapToObject?: boolean } | undefined\n): IQueryHookResult<D[]> {\n  const dbState = useDbState();\n\n  const { suppressLog } = {\n    suppressLog: _opts?.suppressLog !== undefined ? _opts.suppressLog : false,\n  };\n\n  const [currentQueries, setCurrentQueries] = useState<ISqlAdapter[]>(\n    _queries ? _queries : []\n  );\n  const [data, setData] = useState<D[][] | undefined>();\n  const [response, setResponse] = useState<\n    DistributiveOmit<IQueryHookResult<D[][]>, \"data\">\n  >(\n    _queries\n      ? dbState.type === \"initialized\"\n        ? { type: \"loading\" }\n        : { type: \"waitingDb\" }\n      : { type: \"noSqlPresent\" }\n  );\n\n  useEffect(() => {\n    if (currentQueries.length === 0) {\n      setResponse({ type: \"noSqlPresent\" });\n\n      return;\n    }\n\n    if (dbState.type !== \"initialized\") {\n      setResponse({ type: \"waitingDb\" });\n\n      return;\n    }\n\n    const db = suppressLog ? withSuppressedLog(dbState.db) : dbState.db;\n\n    const subscription = listenQueries<D>(db, currentQueries).subscribe(\n      (result) => {\n        setData(result);\n        setResponse({ type: \"loaded\" });\n      }\n    );\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [dbState, currentQueries, suppressLog]);\n\n  useEffect(() => {\n    if (\n      currentQueries.map((q) => q.toSql().hash).join() !==\n      (_queries || []).map((q) => q.toSql().hash).join()\n    ) {\n      setCurrentQueries(_queries || []);\n    }\n  }, [currentQueries, _queries]);\n\n  return useMemo(() => {\n    if (response.type === \"loaded\") {\n      if (!data) {\n        throw new Error(\n          \"Internal error: response state is loaded, but there is not data!\"\n        );\n      }\n\n      return { ...response, data };\n    }\n\n    return { ...response, data: data || [] };\n  }, [data, response]);\n}\n\nexport function useQuery<D extends Record<string, unknown>>(\n  query: ISqlAdapter | Falsy,\n  _opts?: { suppressLog?: boolean; mapToObject?: boolean } | undefined\n): IQueryHookResult<D> {\n  const queries = useMemo(() => (query ? [query] : []), [query]);\n\n  const result = useQueries<D>(queries, _opts);\n\n  return useMemo(() => {\n    if (result.type === \"loaded\") {\n      if (!result.data) {\n        throw new Error(\n          \"Internal error: response state is loaded, but there is not data!\"\n        );\n      }\n\n      return { ...result, data: result.data[0] || [] };\n    }\n\n    return {\n      ...result,\n      data: result.data?.[0] || [],\n    };\n  }, [result]);\n}\n\nexport function useQueryFirstRow<D extends Record<string, unknown>>(\n  query: ISqlAdapter | Falsy,\n  _opts?: { suppressLog?: boolean; mapToObject?: boolean } | undefined\n): ISingleQueryHookResult<D> {\n  const res = useQuery<D>(query, _opts);\n\n  return useMemo(() => {\n    if (res.type === \"loaded\") {\n      return { ...res, data: res.data[0] };\n    }\n\n    return { ...res, data: res.data?.[0] };\n  }, [res]);\n}\n\nfunction useIsMounted() {\n  const isMounted = useRef(false);\n\n  useEffect(() => {\n    isMounted.current = true;\n\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return useCallback(() => isMounted.current, []);\n}\n\nexport function useRunQuery<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  D extends (db: IDbState) => (...args: any[]) => Promise<R>,\n  R\n>(\n  cb: D,\n  _opts?: { suppressLog?: boolean; inTransaction?: boolean } | undefined\n): readonly [\n  (...args: Parameters<ReturnType<D>>) => Promise<R>,\n  IRunQueryHookResult<R>\n] {\n  const { suppressLog, inTransaction } = {\n    suppressLog: _opts?.suppressLog !== undefined ? _opts.suppressLog : false,\n    inTransaction:\n      _opts?.inTransaction !== undefined ? _opts.inTransaction : true,\n  };\n\n  const dbState = useDbState();\n  const isMounted = useIsMounted();\n\n  const [data, setData] = useState<R>();\n  const [runStateType, setRunStateType] = useState<\n    IRunQueryHookResult<R>[\"type\"]\n  >(dbState.type === \"initialized\" ? \"idle\" : \"waitingDb\");\n\n  useEffect(() => {\n    if (dbState.type === \"initialized\") {\n      setRunStateType(\"idle\");\n    } else {\n      setRunStateType(\"waitingDb\");\n    }\n  }, [dbState.type]);\n\n  const toCall = useCallback(\n    async (...args: Parameters<ReturnType<D>>) => {\n      if (dbState.type !== \"initialized\") {\n        // TODO: maybe wait db init as opts?\n\n        throw new Error(\"Db not initialized!\");\n      }\n\n      setRunStateType(\"running\");\n\n      const db = suppressLog ? withSuppressedLog(dbState.db) : dbState.db;\n      const res = await (inTransaction\n        ? runInTransaction(db, (db) => cb(db)(...args))\n        : cb(db)(...args));\n\n      if (isMounted()) {\n        setData(res);\n        setRunStateType(\"done\");\n      }\n\n      return res;\n    },\n    [cb, dbState, inTransaction, isMounted, suppressLog]\n  );\n\n  // Simulation of useEvent\n  const toCallRef = useRef<(...args: Parameters<ReturnType<D>>) => Promise<R>>(\n    toCall\n  );\n  useEffect(() => {\n    toCallRef.current = toCall;\n  }, [toCall]);\n\n  const run = useCallback((...args: Parameters<ReturnType<D>>) => {\n    return toCallRef.current(...args);\n  }, []);\n\n  const result = useMemo(() => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return { type: runStateType, data: data! };\n  }, [data, runStateType]);\n\n  return [run, result];\n}\n\nexport function useCacheQuery<T extends ISqlAdapter>(_query: T): T {\n  const [query, setQuery] = useState(_query);\n\n  useEffect(() => {\n    if (query.toSql().hash !== _query.toSql().hash) {\n      setQuery(_query);\n    }\n  }, [_query, query]);\n\n  return query;\n}\n"]},"metadata":{},"sourceType":"module"}