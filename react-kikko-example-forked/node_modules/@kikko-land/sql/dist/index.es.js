const tableSymbol = Symbol("table");
const table = (name, dependsOnTables) => {
  return {
    name,
    dependsOnTables: dependsOnTables || [],
    get allDependingTables() {
      const tableDefs = [];
      this.dependsOnTables.forEach((def) => {
        tableDefs.push(...def.allDependingTables);
      });
      return tableDefs;
    },
    get [tableSymbol]() {
      return this;
    },
    __discriminator: "ITableDef"
  };
};
function isTable(x) {
  if (x === null)
    return false;
  if (typeof x !== "object")
    return false;
  return Boolean(x[tableSymbol]);
}
const isPrimitiveValue = (t) => {
  return t === null || typeof t === "string" || typeof t === "number" || t instanceof Uint8Array;
};
const insertRegex = /insert\s+(or\s+\w+\s+)?into\s+/gim;
const deleteRegex = /delete\s+from\s+/gim;
const updateRegex = /update\s+(or\s+\w+\s+)?/gim;
const strip = (str) => {
  return str.replace(/"/g, "").split(".").map((v) => '"' + v + '"').join(".");
};
function isSql(x) {
  if (x === null)
    return false;
  if (typeof x !== "object")
    return false;
  return "toSql" in x;
}
function internalSql(_rawStrings, _rawValues) {
  if (_rawStrings.length - 1 !== _rawValues.length) {
    if (_rawStrings.length === 0) {
      throw new TypeError("Expected at least 1 string");
    }
    throw new TypeError(`Expected ${_rawStrings.length} strings to have ${_rawStrings.length - 1} values`);
  }
  const valuesLength = _rawValues.reduce((len, value) => len + (isSql(value) ? value.toSql()._values.length : isTable(value) ? 0 : 1), 0);
  const tablesLength = _rawValues.reduce((len, value) => len + (isSql(value) ? value.toSql().tables.length : isTable(value) ? 1 : 0), 0);
  const values = new Array(valuesLength);
  const strings = new Array(valuesLength + 1);
  const tables = new Array(tablesLength);
  strings[0] = _rawStrings[0];
  let pos = 0, tableI = 0;
  _rawValues.forEach((val, i) => {
    const child = _rawValues[i];
    const rawString = _rawStrings[i + 1];
    if (isSql(child)) {
      const sql2 = child.toSql();
      strings[pos] += sql2._strings[0];
      sql2._values.forEach((childVal, childI) => {
        values[pos++] = sql2._values[childI];
        strings[pos] = sql2._strings[childI + 1];
      });
      sql2.tables.forEach((t, childTableI) => {
        tables[tableI++] = sql2.tables[childTableI++];
      });
      strings[pos] += rawString;
    } else if (isTable(child)) {
      strings[pos] += strip(child[tableSymbol].name) + rawString;
      tables[tableI++] = child[tableSymbol];
    } else {
      values[pos++] = child;
      strings[pos] = rawString;
    }
  });
  return {
    _values: values,
    _strings: strings,
    tables,
    get isModifyQuery() {
      const query = this.preparedQuery.text;
      return query.match(insertRegex) !== null || query.match(deleteRegex) !== null || query.match(updateRegex) !== null;
    },
    get isReadQuery() {
      return !this.isModifyQuery;
    },
    get isEmpty() {
      return this.preparedQuery.text.trim().length === 0;
    },
    get hash() {
      if (!this._hash) {
        this._hash = this._strings.join() + this._values.join();
      }
      return this._hash;
    },
    get raw() {
      return this._strings[0] + this._strings.slice(1).map((val, i) => (typeof this._values[i] === "string" ? "'" + this._values[i] + "'" : this._values[i]) + val).join("");
    },
    get preparedQuery() {
      if (!this._cachedText) {
        this._cachedText = (this._strings[0] + this._strings.slice(1).map((val, i) => `?${val}`).join("")).trim();
      }
      return {
        values: this._values,
        text: this._cachedText
      };
    },
    inspect() {
      return {
        preparedQuery: this.preparedQuery,
        tables: this.tables
      };
    },
    toSql() {
      return this;
    },
    toString() {
      const { values: values2, text } = this.preparedQuery;
      return `${text} - [${values2.join(", ")}]`;
    }
  };
}
function sql(rawStrings, ...rawValues) {
  return internalSql(rawStrings, rawValues);
}
sql.raw = (value) => {
  return sql([value]);
};
sql.liter = (str) => {
  return sql.raw(strip(str));
};
sql.table = table;
sql.isTable = isTable;
sql.isSql = isSql;
sql.empty = sql.raw("");
sql.join = (values, separator = ", ", prefix = "", suffix = "") => {
  values = values.filter((v) => isSql(v) ? !v.toSql().isEmpty : true);
  if (values.length === 0) {
    throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
  }
  return internalSql([prefix, ...Array(values.length - 1).fill(separator), suffix], values);
};
const generateInsert = (tableName, objs, replace = false, returning = false) => {
  if (objs.length === 0)
    throw new Error("Can't insert empty objects");
  const keys = Object.keys(objs[0]);
  const values = sql.join(objs.map((obj) => sql`(${sql.join(keys.map((k) => obj[k]))})`));
  return sql`INSERT ${replace ? sql`OR REPLACE` : sql.empty} INTO ${sql.table(tableName)} (${sql.join(keys.map((k) => sql.raw(k)))}) VALUES ${values} ${returning ? sql`returning *` : sql.empty}`;
};
const generateUpdate = (tableName, obj) => {
  const values = sql.join(Object.entries(obj).map(([k, v]) => sql`${sql.raw(k)} = ${v}`));
  return sql`UPDATE ${sql.table(tableName)} SET ${values}`;
};
export { generateInsert, generateUpdate, isPrimitiveValue, isTable, sql, tableSymbol };
//# sourceMappingURL=index.es.js.map
