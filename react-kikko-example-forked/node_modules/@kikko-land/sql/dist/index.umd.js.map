{"version":3,"file":"index.umd.js","sources":["../src/table.ts","../src/sql.ts","../src/helpers.ts"],"sourcesContent":["export const tableSymbol: unique symbol = Symbol(\"table\");\n\nexport interface ITableDef {\n  name: string;\n  dependsOnTables: ITableDef[];\n  __discriminator: \"ITableDef\";\n  allDependingTables: ITableDef[];\n}\n\nexport interface IContainsTable {\n  [tableSymbol]: ITableDef;\n}\n\nexport const table = (\n  name: string,\n  dependsOnTables?: ITableDef[]\n): ITableDef & IContainsTable => {\n  return {\n    name,\n    dependsOnTables: dependsOnTables || [],\n    get allDependingTables() {\n      const tableDefs: ITableDef[] = [];\n\n      this.dependsOnTables.forEach((def) => {\n        tableDefs.push(...def.allDependingTables);\n      });\n\n      return tableDefs;\n    },\n    get [tableSymbol]() {\n      return this;\n    },\n    __discriminator: \"ITableDef\",\n  };\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isTable(x: any): x is IContainsTable {\n  if (x === null) return false;\n  if (typeof x !== \"object\") return false;\n\n  return Boolean(x[tableSymbol]);\n}\n","import {\n  IContainsTable,\n  isTable,\n  ITableDef,\n  table,\n  tableSymbol,\n} from \"./table\";\n\n// Code is taken and adopted from https://github.com/blakeembrey/sql-template-tag\n\nexport type IPrimitiveValue = string | number | null | Uint8Array;\nexport const isPrimitiveValue = (t: unknown): t is IPrimitiveValue => {\n  return (\n    t === null ||\n    typeof t === \"string\" ||\n    typeof t === \"number\" ||\n    t instanceof Uint8Array\n  );\n};\n\nexport type IRawValue = IPrimitiveValue | ISql | IContainsTable | ISqlAdapter;\n\nconst insertRegex = /insert\\s+(or\\s+\\w+\\s+)?into\\s+/gim;\nconst deleteRegex = /delete\\s+from\\s+/gim;\nconst updateRegex = /update\\s+(or\\s+\\w+\\s+)?/gim;\n\nconst strip = (str: string) => {\n  return str\n    .replace(/\"/g, \"\")\n    .split(\".\")\n    .map((v) => '\"' + v + '\"')\n    .join(\".\");\n};\n\nexport interface ISqlAdapter {\n  toSql(): ISql;\n}\n\nfunction isSql(x: unknown): x is ISqlAdapter {\n  if (x === null) return false;\n  if (typeof x !== \"object\") return false;\n\n  return \"toSql\" in x;\n}\n\nexport interface ISql extends ISqlAdapter {\n  readonly _values: IPrimitiveValue[];\n  readonly _strings: string[];\n  readonly tables: ITableDef[];\n\n  _cachedText?: string;\n  _hash?: string;\n\n  get isModifyQuery(): boolean;\n  get isReadQuery(): boolean;\n  get isEmpty(): boolean;\n  get raw(): string;\n\n  get hash(): string;\n\n  get preparedQuery(): {\n    values: IPrimitiveValue[];\n    text: string;\n  };\n\n  inspect(): {\n    preparedQuery: ISql[\"preparedQuery\"];\n    tables: ISql[\"tables\"];\n  };\n\n  toString(): string;\n}\n\nfunction internalSql(\n  _rawStrings: ReadonlyArray<string>,\n  _rawValues: IRawValue[]\n\n): ISql {\n\n\n  if (_rawStrings.length - 1 !== _rawValues.length) {\n    if (_rawStrings.length === 0) {\n      throw new TypeError(\"Expected at least 1 string\");\n    }\n\n    throw new TypeError(\n      `Expected ${_rawStrings.length} strings to have ${\n        _rawStrings.length - 1\n      } values`\n    );\n  }\n\n  const valuesLength = _rawValues.reduce<number>(\n    (len, value) =>\n      len +\n      (isSql(value) ? value.toSql()._values.length : isTable(value) ? 0 : 1),\n    0\n  );\n  const tablesLength = _rawValues.reduce<number>(\n    (len, value) =>\n      len +\n      (isSql(value) ? value.toSql().tables.length : isTable(value) ? 1 : 0),\n    0\n  );\n\n  const values: IPrimitiveValue[] = new Array(valuesLength);\n  const strings: string[] = new Array(valuesLength + 1);\n  const tables: ITableDef[] = new Array(tablesLength);\n\n  strings[0] = _rawStrings[0];\n\n  // Iterate over rw values, strings, and children. The value is always\n  // positioned between two strings, e.g. `index + 1`.\n  let pos = 0,\n    tableI = 0;\n\n  _rawValues.forEach((val, i) => {\n    const child = _rawValues[i];\n    const rawString = _rawStrings[i + 1];\n\n    // Check for nested `sql` queries.\n    if (isSql(child)) {\n      const sql = child.toSql();\n      // Append child prefix text to current string.\n      strings[pos] += sql._strings[0];\n\n      sql._values.forEach((childVal, childI) => {\n        values[pos++] = sql._values[childI];\n        strings[pos] = sql._strings[childI + 1];\n      });\n\n      sql.tables.forEach((t, childTableI) => {\n        tables[tableI++] = sql.tables[childTableI++];\n      });\n\n      // Append raw string to current string.\n      strings[pos] += rawString;\n    } else if (isTable(child)) {\n      strings[pos] += strip(child[tableSymbol].name) + rawString;\n\n      tables[tableI++] = child[tableSymbol];\n    } else {\n      values[pos++] = child;\n      strings[pos] = rawString;\n    }\n  });\n\n  return {\n    _values: values,\n    _strings: strings,\n    tables: tables,\n\n    get isModifyQuery() {\n      const query = this.preparedQuery.text;\n\n      // There some edge cases could happen here, so better regex could be introduced\n      // I don't want put AST parser to frontend lib\n      return (\n        query.match(insertRegex) !== null ||\n        query.match(deleteRegex) !== null ||\n        query.match(updateRegex) !== null\n      );\n    },\n    get isReadQuery() {\n      return !this.isModifyQuery;\n    },\n    get isEmpty() {\n      return this.preparedQuery.text.trim().length === 0;\n    },\n\n    get hash() {\n      if (!this._hash) {\n        this._hash = this._strings.join() + this._values.join();\n      }\n\n      return this._hash;\n    },\n\n    get raw() {\n      return (\n        this._strings[0] +\n        this._strings\n          .slice(1)\n          .map(\n            (val, i) =>\n              (typeof this._values[i] === \"string\"\n                ? \"'\" + this._values[i] + \"'\"\n                : this._values[i]) + val\n          )\n          .join(\"\")\n      );\n    },\n\n    get preparedQuery() {\n      if (!this._cachedText) {\n        this._cachedText = (\n          this._strings[0] +\n          this._strings\n            .slice(1)\n            .map((val, i) => `?${val}`)\n            .join(\"\")\n        ).trim();\n      }\n\n      return {\n        values: this._values,\n        text: this._cachedText,\n      };\n    },\n\n    inspect() {\n      return {\n        preparedQuery: this.preparedQuery,\n        tables: this.tables,\n      };\n    },\n\n    toSql() {\n      return this;\n    },\n\n    toString() {\n      const { values, text } = this.preparedQuery;\n\n      return `${text} - [${values.join(\", \")}]`;\n    },\n  };\n}\n\nexport function sql(\n  rawStrings: ReadonlyArray<string>,\n  ...rawValues: IRawValue[]\n): ISql {\n  return internalSql(rawStrings, rawValues)\n}\n\nsql.raw = (value: string) => {\n  return sql([value]);\n};\nsql.liter = (str: string) => {\n  return sql.raw(strip(str));\n};\nsql.table = table;\nsql.isTable = isTable;\nsql.isSql = isSql;\nsql.empty = sql.raw(\"\");\nsql.join = (\n  values: IRawValue[],\n  separator = \", \",\n  prefix = \"\",\n  suffix = \"\"\n) => {\n  values = values.filter((v) => (isSql(v) ? !v.toSql().isEmpty : true));\n\n  if (values.length === 0) {\n    throw new TypeError(\n      \"Expected `join([])` to be called with an array of multiple elements, but got an empty array\"\n    );\n  }\n\n  return internalSql(\n    [prefix, ...Array(values.length - 1).fill(separator), suffix],\n    values\n  );\n};\n","import { sql } from \"./sql\";\n\nexport const generateInsert = (\n  tableName: string,\n  objs: Record<string, unknown>[],\n  replace = false,\n  returning = false\n) => {\n  if (objs.length === 0) throw new Error(\"Can't insert empty objects\");\n\n  const keys = Object.keys(objs[0]);\n\n  const values = sql.join(\n    objs.map((obj) => sql`(${sql.join(keys.map((k) => obj[k] as string))})`)\n  );\n\n  return sql`INSERT ${replace ? sql`OR REPLACE` : sql.empty} INTO ${sql.table(\n    tableName\n  )} (${sql.join(keys.map((k) => sql.raw(k)))}) VALUES ${values} ${\n    returning ? sql`returning *` : sql.empty\n  }`;\n};\n\nexport const generateUpdate = (\n  tableName: string,\n  obj: Record<string, unknown>\n) => {\n  const values = sql.join(\n    Object.entries(obj).map(([k, v]) => sql`${sql.raw(k)} = ${v as string}`)\n  );\n\n  return sql`UPDATE ${sql.table(tableName)} SET ${values}`;\n};\n"],"names":[],"mappings":"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"}