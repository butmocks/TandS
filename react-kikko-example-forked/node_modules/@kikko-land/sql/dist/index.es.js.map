{"version":3,"file":"index.es.js","sources":["../src/table.ts","../src/sql.ts","../src/helpers.ts"],"sourcesContent":["export const tableSymbol: unique symbol = Symbol(\"table\");\n\nexport interface ITableDef {\n  name: string;\n  dependsOnTables: ITableDef[];\n  __discriminator: \"ITableDef\";\n  allDependingTables: ITableDef[];\n}\n\nexport interface IContainsTable {\n  [tableSymbol]: ITableDef;\n}\n\nexport const table = (\n  name: string,\n  dependsOnTables?: ITableDef[]\n): ITableDef & IContainsTable => {\n  return {\n    name,\n    dependsOnTables: dependsOnTables || [],\n    get allDependingTables() {\n      const tableDefs: ITableDef[] = [];\n\n      this.dependsOnTables.forEach((def) => {\n        tableDefs.push(...def.allDependingTables);\n      });\n\n      return tableDefs;\n    },\n    get [tableSymbol]() {\n      return this;\n    },\n    __discriminator: \"ITableDef\",\n  };\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isTable(x: any): x is IContainsTable {\n  if (x === null) return false;\n  if (typeof x !== \"object\") return false;\n\n  return Boolean(x[tableSymbol]);\n}\n","import {\n  IContainsTable,\n  isTable,\n  ITableDef,\n  table,\n  tableSymbol,\n} from \"./table\";\n\n// Code is taken and adopted from https://github.com/blakeembrey/sql-template-tag\n\nexport type IPrimitiveValue = string | number | null | Uint8Array;\nexport const isPrimitiveValue = (t: unknown): t is IPrimitiveValue => {\n  return (\n    t === null ||\n    typeof t === \"string\" ||\n    typeof t === \"number\" ||\n    t instanceof Uint8Array\n  );\n};\n\nexport type IRawValue = IPrimitiveValue | ISql | IContainsTable | ISqlAdapter;\n\nconst insertRegex = /insert\\s+(or\\s+\\w+\\s+)?into\\s+/gim;\nconst deleteRegex = /delete\\s+from\\s+/gim;\nconst updateRegex = /update\\s+(or\\s+\\w+\\s+)?/gim;\n\nconst strip = (str: string) => {\n  return str\n    .replace(/\"/g, \"\")\n    .split(\".\")\n    .map((v) => '\"' + v + '\"')\n    .join(\".\");\n};\n\nexport interface ISqlAdapter {\n  toSql(): ISql;\n}\n\nfunction isSql(x: unknown): x is ISqlAdapter {\n  if (x === null) return false;\n  if (typeof x !== \"object\") return false;\n\n  return \"toSql\" in x;\n}\n\nexport interface ISql extends ISqlAdapter {\n  readonly _values: IPrimitiveValue[];\n  readonly _strings: string[];\n  readonly tables: ITableDef[];\n\n  _cachedText?: string;\n  _hash?: string;\n\n  get isModifyQuery(): boolean;\n  get isReadQuery(): boolean;\n  get isEmpty(): boolean;\n  get raw(): string;\n\n  get hash(): string;\n\n  get preparedQuery(): {\n    values: IPrimitiveValue[];\n    text: string;\n  };\n\n  inspect(): {\n    preparedQuery: ISql[\"preparedQuery\"];\n    tables: ISql[\"tables\"];\n  };\n\n  toString(): string;\n}\n\nfunction internalSql(\n  _rawStrings: ReadonlyArray<string>,\n  _rawValues: IRawValue[]\n\n): ISql {\n\n\n  if (_rawStrings.length - 1 !== _rawValues.length) {\n    if (_rawStrings.length === 0) {\n      throw new TypeError(\"Expected at least 1 string\");\n    }\n\n    throw new TypeError(\n      `Expected ${_rawStrings.length} strings to have ${\n        _rawStrings.length - 1\n      } values`\n    );\n  }\n\n  const valuesLength = _rawValues.reduce<number>(\n    (len, value) =>\n      len +\n      (isSql(value) ? value.toSql()._values.length : isTable(value) ? 0 : 1),\n    0\n  );\n  const tablesLength = _rawValues.reduce<number>(\n    (len, value) =>\n      len +\n      (isSql(value) ? value.toSql().tables.length : isTable(value) ? 1 : 0),\n    0\n  );\n\n  const values: IPrimitiveValue[] = new Array(valuesLength);\n  const strings: string[] = new Array(valuesLength + 1);\n  const tables: ITableDef[] = new Array(tablesLength);\n\n  strings[0] = _rawStrings[0];\n\n  // Iterate over rw values, strings, and children. The value is always\n  // positioned between two strings, e.g. `index + 1`.\n  let pos = 0,\n    tableI = 0;\n\n  _rawValues.forEach((val, i) => {\n    const child = _rawValues[i];\n    const rawString = _rawStrings[i + 1];\n\n    // Check for nested `sql` queries.\n    if (isSql(child)) {\n      const sql = child.toSql();\n      // Append child prefix text to current string.\n      strings[pos] += sql._strings[0];\n\n      sql._values.forEach((childVal, childI) => {\n        values[pos++] = sql._values[childI];\n        strings[pos] = sql._strings[childI + 1];\n      });\n\n      sql.tables.forEach((t, childTableI) => {\n        tables[tableI++] = sql.tables[childTableI++];\n      });\n\n      // Append raw string to current string.\n      strings[pos] += rawString;\n    } else if (isTable(child)) {\n      strings[pos] += strip(child[tableSymbol].name) + rawString;\n\n      tables[tableI++] = child[tableSymbol];\n    } else {\n      values[pos++] = child;\n      strings[pos] = rawString;\n    }\n  });\n\n  return {\n    _values: values,\n    _strings: strings,\n    tables: tables,\n\n    get isModifyQuery() {\n      const query = this.preparedQuery.text;\n\n      // There some edge cases could happen here, so better regex could be introduced\n      // I don't want put AST parser to frontend lib\n      return (\n        query.match(insertRegex) !== null ||\n        query.match(deleteRegex) !== null ||\n        query.match(updateRegex) !== null\n      );\n    },\n    get isReadQuery() {\n      return !this.isModifyQuery;\n    },\n    get isEmpty() {\n      return this.preparedQuery.text.trim().length === 0;\n    },\n\n    get hash() {\n      if (!this._hash) {\n        this._hash = this._strings.join() + this._values.join();\n      }\n\n      return this._hash;\n    },\n\n    get raw() {\n      return (\n        this._strings[0] +\n        this._strings\n          .slice(1)\n          .map(\n            (val, i) =>\n              (typeof this._values[i] === \"string\"\n                ? \"'\" + this._values[i] + \"'\"\n                : this._values[i]) + val\n          )\n          .join(\"\")\n      );\n    },\n\n    get preparedQuery() {\n      if (!this._cachedText) {\n        this._cachedText = (\n          this._strings[0] +\n          this._strings\n            .slice(1)\n            .map((val, i) => `?${val}`)\n            .join(\"\")\n        ).trim();\n      }\n\n      return {\n        values: this._values,\n        text: this._cachedText,\n      };\n    },\n\n    inspect() {\n      return {\n        preparedQuery: this.preparedQuery,\n        tables: this.tables,\n      };\n    },\n\n    toSql() {\n      return this;\n    },\n\n    toString() {\n      const { values, text } = this.preparedQuery;\n\n      return `${text} - [${values.join(\", \")}]`;\n    },\n  };\n}\n\nexport function sql(\n  rawStrings: ReadonlyArray<string>,\n  ...rawValues: IRawValue[]\n): ISql {\n  return internalSql(rawStrings, rawValues)\n}\n\nsql.raw = (value: string) => {\n  return sql([value]);\n};\nsql.liter = (str: string) => {\n  return sql.raw(strip(str));\n};\nsql.table = table;\nsql.isTable = isTable;\nsql.isSql = isSql;\nsql.empty = sql.raw(\"\");\nsql.join = (\n  values: IRawValue[],\n  separator = \", \",\n  prefix = \"\",\n  suffix = \"\"\n) => {\n  values = values.filter((v) => (isSql(v) ? !v.toSql().isEmpty : true));\n\n  if (values.length === 0) {\n    throw new TypeError(\n      \"Expected `join([])` to be called with an array of multiple elements, but got an empty array\"\n    );\n  }\n\n  return internalSql(\n    [prefix, ...Array(values.length - 1).fill(separator), suffix],\n    values\n  );\n};\n","import { sql } from \"./sql\";\n\nexport const generateInsert = (\n  tableName: string,\n  objs: Record<string, unknown>[],\n  replace = false,\n  returning = false\n) => {\n  if (objs.length === 0) throw new Error(\"Can't insert empty objects\");\n\n  const keys = Object.keys(objs[0]);\n\n  const values = sql.join(\n    objs.map((obj) => sql`(${sql.join(keys.map((k) => obj[k] as string))})`)\n  );\n\n  return sql`INSERT ${replace ? sql`OR REPLACE` : sql.empty} INTO ${sql.table(\n    tableName\n  )} (${sql.join(keys.map((k) => sql.raw(k)))}) VALUES ${values} ${\n    returning ? sql`returning *` : sql.empty\n  }`;\n};\n\nexport const generateUpdate = (\n  tableName: string,\n  obj: Record<string, unknown>\n) => {\n  const values = sql.join(\n    Object.entries(obj).map(([k, v]) => sql`${sql.raw(k)} = ${v as string}`)\n  );\n\n  return sql`UPDATE ${sql.table(tableName)} SET ${values}`;\n};\n"],"names":[],"mappings":"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"}