import { initDbClient, stopDb, withSuppressedLog, runInTransaction } from "@kikko-land/kikko";
import React, { useState, useEffect, useContext, useMemo, useCallback, useRef } from "react";
import { listenQueries } from "@kikko-land/reactive-queries-plugin";
const DbContext = React.createContext({
  type: "notInitialized"
});
const DbProvider = ({ children, config }) => {
  const [currentState, setCurrentState] = useState({
    type: "notInitialized"
  });
  useEffect(() => {
    let shouldBeStopped = false;
    let initializedDb = void 0;
    const cb = async () => {
      setCurrentState({ type: "initializing", config });
      const db = await initDbClient(config);
      initializedDb = db;
      if (shouldBeStopped) {
        void stopDb(db);
        return;
      }
      setCurrentState({ type: "initialized", db, config });
    };
    void cb();
    return () => {
      shouldBeStopped = true;
      if (initializedDb) {
        setCurrentState({ type: "notInitialized" });
        void stopDb(initializedDb);
      }
    };
  }, [config]);
  return /* @__PURE__ */ React.createElement(DbContext.Provider, {
    value: currentState
  }, children);
};
const useDbState = () => {
  return useContext(DbContext);
};
const useDb = () => {
  const res = useDbState();
  if (res.type === "initialized") {
    return res.db;
  } else {
    return void 0;
  }
};
const useDbStrict = () => {
  const db = useDb();
  if (!db)
    throw new Error("DB is not initialized!");
  return db;
};
const EnsureDbLoaded = ({ children, fallback }) => {
  const dbState = useDbState();
  return dbState.type === "initialized" ? children : fallback ? fallback : null;
};
function useQueries(_queries, _opts) {
  const dbState = useDbState();
  const { suppressLog } = {
    suppressLog: (_opts == null ? void 0 : _opts.suppressLog) !== void 0 ? _opts.suppressLog : false
  };
  const [currentQueries, setCurrentQueries] = useState(_queries ? _queries : []);
  const [data, setData] = useState();
  const [response, setResponse] = useState(_queries ? dbState.type === "initialized" ? { type: "loading" } : { type: "waitingDb" } : { type: "noSqlPresent" });
  useEffect(() => {
    if (currentQueries.length === 0) {
      setResponse({ type: "noSqlPresent" });
      return;
    }
    if (dbState.type !== "initialized") {
      setResponse({ type: "waitingDb" });
      return;
    }
    const db = suppressLog ? withSuppressedLog(dbState.db) : dbState.db;
    const subscription = listenQueries(db, currentQueries).subscribe((result) => {
      setData(result);
      setResponse({ type: "loaded" });
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [dbState, currentQueries, suppressLog]);
  useEffect(() => {
    if (currentQueries.map((q) => q.toSql().hash).join() !== (_queries || []).map((q) => q.toSql().hash).join()) {
      setCurrentQueries(_queries || []);
    }
  }, [currentQueries, _queries]);
  return useMemo(() => {
    if (response.type === "loaded") {
      if (!data) {
        throw new Error("Internal error: response state is loaded, but there is not data!");
      }
      return { ...response, data };
    }
    return { ...response, data: data || [] };
  }, [data, response]);
}
function useQuery(query, _opts) {
  const queries = useMemo(() => query ? [query] : [], [query]);
  const result = useQueries(queries, _opts);
  return useMemo(() => {
    var _a;
    if (result.type === "loaded") {
      if (!result.data) {
        throw new Error("Internal error: response state is loaded, but there is not data!");
      }
      return { ...result, data: result.data[0] || [] };
    }
    return {
      ...result,
      data: ((_a = result.data) == null ? void 0 : _a[0]) || []
    };
  }, [result]);
}
function useQueryFirstRow(query, _opts) {
  const res = useQuery(query, _opts);
  return useMemo(() => {
    var _a;
    if (res.type === "loaded") {
      return { ...res, data: res.data[0] };
    }
    return { ...res, data: (_a = res.data) == null ? void 0 : _a[0] };
  }, [res]);
}
function useIsMounted() {
  const isMounted = useRef(false);
  useEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return useCallback(() => isMounted.current, []);
}
function useRunQuery(cb, _opts) {
  const { suppressLog, inTransaction } = {
    suppressLog: (_opts == null ? void 0 : _opts.suppressLog) !== void 0 ? _opts.suppressLog : false,
    inTransaction: (_opts == null ? void 0 : _opts.inTransaction) !== void 0 ? _opts.inTransaction : true
  };
  const dbState = useDbState();
  const isMounted = useIsMounted();
  const [data, setData] = useState();
  const [runStateType, setRunStateType] = useState(dbState.type === "initialized" ? "idle" : "waitingDb");
  useEffect(() => {
    if (dbState.type === "initialized") {
      setRunStateType("idle");
    } else {
      setRunStateType("waitingDb");
    }
  }, [dbState.type]);
  const toCall = useCallback(async (...args) => {
    if (dbState.type !== "initialized") {
      throw new Error("Db not initialized!");
    }
    setRunStateType("running");
    const db = suppressLog ? withSuppressedLog(dbState.db) : dbState.db;
    const res = await (inTransaction ? runInTransaction(db, (db2) => cb(db2)(...args)) : cb(db)(...args));
    if (isMounted()) {
      setData(res);
      setRunStateType("done");
    }
    return res;
  }, [cb, dbState, inTransaction, isMounted, suppressLog]);
  const toCallRef = useRef(toCall);
  useEffect(() => {
    toCallRef.current = toCall;
  }, [toCall]);
  const run = useCallback((...args) => {
    return toCallRef.current(...args);
  }, []);
  const result = useMemo(() => {
    return { type: runStateType, data };
  }, [data, runStateType]);
  return [run, result];
}
function useCacheQuery(_query) {
  const [query, setQuery] = useState(_query);
  useEffect(() => {
    if (query.toSql().hash !== _query.toSql().hash) {
      setQuery(_query);
    }
  }, [_query, query]);
  return query;
}
export { DbProvider, EnsureDbLoaded, useCacheQuery, useDb, useDbState, useDbStrict, useQueries, useQuery, useQueryFirstRow, useRunQuery };
//# sourceMappingURL=index.es.js.map
