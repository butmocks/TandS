{"version":3,"file":"index.es.js","sources":["../src/afterTransaction.ts","../src/createNanoEvents.ts","../src/utils.ts","../src/job.ts","../src/initDb.ts","../src/runQueries.ts","../src/suppressLog.ts","../src/transaction.ts"],"sourcesContent":["import { IDbState, ITransaction } from \"./types\";\n\nconst runAfterTransaction = (\n  db: IDbState,\n  func: (\n    event: \"committed\" | \"rollbacked\",\n    db: IDbState,\n    transaction: ITransaction\n  ) => void\n) => {\n  if (!db.localState.transactionsState) {\n    throw new Error(\"Not in transaction.\");\n  }\n\n  const unsubscribes: (() => void)[] = [];\n\n  const listener =\n    (event: \"committed\" | \"rollbacked\") =>\n    (db: IDbState, transaction: ITransaction) => {\n      func(event, db, transaction);\n\n      for (const unsubscribe of unsubscribes) {\n        unsubscribe();\n      }\n    };\n\n  unsubscribes.push(\n    db.sharedState.eventsEmitter.on(\n      \"transactionCommitted\",\n      listener(\"committed\")\n    )\n  );\n\n  unsubscribes.push(\n    db.sharedState.eventsEmitter.on(\n      \"transactionRollbacked\",\n      listener(\"rollbacked\")\n    )\n  );\n};\n\nexport const runAfterTransactionCommitted = (\n  db: IDbState,\n  func: (db: IDbState, transaction: ITransaction) => void\n) => {\n  runAfterTransaction(db, (ev, db, transaction) => {\n    if (ev === \"committed\") {\n      func(db, transaction);\n    }\n  });\n};\n\nexport const runAfterTransactionRollbacked = (\n  db: IDbState,\n  func: (db: IDbState, transaction: ITransaction) => void\n) => {\n  runAfterTransaction(db, (ev, db, transaction) => {\n    if (ev === \"rollbacked\") {\n      func(db, transaction);\n    }\n  });\n};\n","// Adopted from https://github.com/ai/nanoevents/blob/main/index.js\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type EventsMap<K extends keyof any> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [P in K]: (...args: any[]) => Promise<void> | void;\n};\n\n// Adopted from https://github.com/ai/nanoevents\n// I didn't use original due to lack of cjs support\n\nexport function createNanoEvents<Events extends EventsMap<keyof Events>>() {\n  const events: Partial<{ [E in keyof Events]: Events[E][] }> = {};\n\n  return {\n    async emit<K extends keyof Events>(\n      event: K,\n      ...args: Parameters<Events[K]>\n    ) {\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n      const all = (events[event] || []) as Events[K][];\n      for (const toCall of all) {\n        await toCall(...args);\n      }\n    },\n    on<K extends keyof Events>(event: K, cb: Events[K]): () => void {\n      ((events[event] = events[event] || []) as Events[K][]).push(cb);\n\n      return () => {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        events[event] = ((events[event] || []) as Events[K][]).filter(\n          (i: unknown) => i !== cb\n        ) as Events[K][];\n      };\n    },\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type INanoEmitter<T extends EventsMap<keyof T>> = ReturnType<\n  typeof createNanoEvents\n>;\n","import { ISql } from \"@kikko-land/sql\";\n\nimport { IDbState, IQuery } from \"./types\";\n\nexport const assureDbIsRunning = (state: IDbState, toStart: () => string) => {\n  const {\n    sharedState: { runningState$, dbName },\n  } = state;\n\n  if (runningState$.value !== \"running\") {\n    throw new Error(`Failed to start ${toStart()}, db ${dbName} is stopping`);\n  }\n};\n\nexport const unwrapQueries = (queries: ISql[]): IQuery[] => {\n  return queries.map((q) => q.preparedQuery);\n};\n\nexport function makeId() {\n  let result = \"\";\n  const characters =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  const charactersLength = characters.length;\n  for (let i = 0; i < 32; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n\n  return result;\n}\n","import { ISql } from \"@kikko-land/sql\";\nimport { BehaviorSubject, filter, firstValueFrom } from \"rxjs\";\nimport { DeepReadonly } from \"ts-essentials\";\n\nimport { ITransaction } from \"./types\";\nimport { makeId } from \"./utils\";\n\nexport type DistributiveOmit<\n  T,\n  K extends keyof Record<string, unknown>\n> = T extends unknown ? Omit<T, K> : never;\n\nexport type IJob =\n  | { type: \"runTransaction\"; id: string; transaction: ITransaction }\n  | { type: \"runQueries\"; queries: ISql[]; id: string }\n  | { type: \"initDb\"; name: string; id: string };\n\nexport type IJobsState = DeepReadonly<{\n  queue: IJob[];\n  current?: IJob;\n}>;\n\n// Actually it works like locking mechanism\nexport const acquireJob = async (\n  jobsState$: BehaviorSubject<IJobsState>,\n  _job: DistributiveOmit<IJob, \"id\">\n): Promise<IJob> => {\n  const id = makeId();\n  const job = { ..._job, id };\n\n  const { current, queue } = jobsState$.value;\n\n  if (current || queue.length > 0) {\n    const promise = firstValueFrom(\n      jobsState$.pipe(filter(({ current }) => current?.id === id))\n    );\n\n    jobsState$.next({ queue: [...queue, job], current });\n\n    await promise;\n  } else {\n    jobsState$.next({ queue: [], current: job });\n  }\n\n  return job;\n};\n\nexport const releaseJob = (\n  jobsState$: BehaviorSubject<IJobsState>,\n  job: IJob\n) => {\n  const { current, queue } = jobsState$.value;\n\n  if (current?.id !== job.id) {\n    throw new Error(\n      `Can't release job that is not currently running, current: ${JSON.stringify(\n        current\n      )}, queue: ${JSON.stringify(queue)}, toRelease: ${JSON.stringify(job)}`\n    );\n  }\n\n  jobsState$.next({ queue: queue.slice(1), current: queue[0] });\n};\n\nexport const whenAllJobsDone = async (\n  jobsState$: BehaviorSubject<IJobsState>\n) => {\n  return firstValueFrom(\n    jobsState$.pipe(filter(({ queue }) => queue.length === 0))\n  );\n};\n","import {\n  BehaviorSubject,\n  filter,\n  firstValueFrom,\n  map,\n  of,\n  pipe,\n  switchMap,\n  take,\n} from \"rxjs\";\n\nimport { createNanoEvents } from \"./createNanoEvents\";\nimport { acquireJob, IJobsState, releaseJob, whenAllJobsDone } from \"./job\";\nimport {\n  IDbBackend,\n  IDbState,\n  IKikkoEvents,\n  IQueriesMiddleware,\n} from \"./types\";\nimport { makeId } from \"./utils\";\n\nexport type IDbClientPlugin = (state: IDbState) => IDbState;\n\nexport type IInitDbClientConfig = {\n  dbName: string;\n  dbBackend: Promise<IDbBackend> | IDbBackend;\n  plugins?: IDbClientPlugin[];\n  queriesMiddlewares?: IQueriesMiddleware[];\n};\n\nexport const initDbClient = async ({\n  dbName,\n  plugins,\n  queriesMiddlewares,\n  dbBackend,\n}: IInitDbClientConfig): Promise<IDbState> => {\n  const runningState$ = new BehaviorSubject<\"running\" | \"stopping\" | \"stopped\">(\n    \"running\"\n  );\n\n  const dbBackendCalled = (await dbBackend)({\n    dbName,\n    stopped$: runningState$.pipe(\n      filter((e) => e === \"stopped\"),\n      map(() => undefined as void),\n      take(1)\n    ),\n  });\n\n  const jobsState$ = new BehaviorSubject<IJobsState>({\n    queue: [],\n    current: undefined,\n  });\n\n  const state: IDbState = {\n    sharedState: {\n      clientId: makeId(),\n      dbBackend: dbBackendCalled,\n      dbName,\n\n      runningState$,\n      stopStarted$: runningState$.pipe(\n        filter((e) => e === \"stopping\"),\n        map(() => undefined as void),\n        take(1)\n      ),\n\n      eventsEmitter: createNanoEvents<IKikkoEvents>(),\n\n      jobsState$,\n      transactionsState: {},\n    },\n    localState: {\n      queriesMiddlewares: queriesMiddlewares || [],\n      transactionsState: {},\n    },\n  };\n\n  const job = await acquireJob(state.sharedState.jobsState$, {\n    type: \"initDb\",\n    name: dbName,\n  });\n\n  const initializerPipe = pipe(\n    switchMap(async () => {\n      await dbBackendCalled.initialize();\n    }),\n    map(() => {\n      let currentState = state;\n\n      for (const plugin of plugins || []) {\n        currentState = plugin(state);\n      }\n\n      return currentState;\n    }),\n    switchMap(async (currentState) => {\n      releaseJob(jobsState$, job);\n\n      await state.sharedState.eventsEmitter.emit(\"initialized\", state);\n      return currentState;\n    })\n  );\n\n  return firstValueFrom(\n    state.sharedState.runningState$.pipe(\n      switchMap((runningState) =>\n        runningState === \"running\"\n          ? of(undefined).pipe(initializerPipe)\n          : of(state)\n      )\n    )\n  );\n};\n\nexport const stopDb = async (state: IDbState) => {\n  state.sharedState.runningState$.next(\"stopping\");\n\n  await whenAllJobsDone(state.sharedState.jobsState$);\n\n  console.log(\"stopped db\");\n\n  state.sharedState.runningState$.next(\"stopped\");\n};\n","import { ISqlAdapter } from \"@kikko-land/sql\";\n\nimport { acquireJob, IJob, releaseJob } from \"./job\";\nimport {\n  IDbState,\n  INextQueriesMiddleware,\n  IQueriesMiddleware,\n  IQueriesMiddlewareState,\n} from \"./types\";\nimport { assureDbIsRunning, unwrapQueries } from \"./utils\";\n\nconst runQueriesMiddleware: IQueriesMiddleware = async ({\n  dbState,\n  queries,\n}) => {\n  const {\n    localState: { transactionsState: transactionsLocalState, suppressLog },\n    sharedState: {\n      transactionsState: transactionsSharedState,\n      jobsState$,\n      dbBackend,\n    },\n  } = dbState;\n\n  if (!transactionsLocalState.current) {\n    assureDbIsRunning(dbState, () => JSON.stringify(queries));\n  }\n\n  if (transactionsLocalState.current && transactionsSharedState.current) {\n    if (\n      transactionsLocalState.current.id !== transactionsSharedState.current.id\n    ) {\n      // Is it possible?\n      throw new Error(\n        \"Internal error: local running transaction is not the same as shared state transaction\"\n      );\n    }\n  }\n\n  let job: IJob | undefined;\n\n  if (!transactionsLocalState.current) {\n    job = await acquireJob(jobsState$, {\n      type: \"runQueries\",\n      queries: queries.map((q) => q.toSql()),\n    });\n  }\n\n  const execOpts = {\n    log: {\n      suppress: Boolean(suppressLog),\n      transactionId: transactionsLocalState.current?.id,\n    },\n  };\n\n  try {\n    const result = await dbBackend.execQueries(\n      unwrapQueries(queries.map((q) => q.toSql())),\n      execOpts\n    );\n\n    return { dbState, result, queries };\n  } finally {\n    if (job) {\n      releaseJob(jobsState$, job);\n    }\n  }\n};\n\nexport const runQueries = async <D extends Record<string, unknown>>(\n  state: IDbState,\n  queries: ISqlAdapter[]\n): Promise<D[][]> => {\n  const middlewares: IQueriesMiddleware[] = [\n    ...state.localState.queriesMiddlewares,\n    runQueriesMiddleware,\n  ].reverse();\n\n  let toCall: INextQueriesMiddleware = (args) => Promise.resolve(args);\n\n  for (const middleware of middlewares) {\n    const currentCall = toCall;\n\n    toCall = (args: IQueriesMiddlewareState) =>\n      middleware({ ...args, next: currentCall });\n  }\n\n  return (\n    await toCall({\n      dbState: state,\n      result: [],\n      queries: queries.map((q) => q.toSql()),\n    })\n  ).result as D[][];\n};\n\nexport const runQuery = async <D extends Record<string, unknown>>(\n  state: IDbState,\n  query: ISqlAdapter\n) => {\n  return (await runQueries<D>(state, [query]))[0] || [];\n};\n","import { IDbState } from \"./types\";\n\nexport const suppressLog = <T>(\n  state: IDbState,\n  func: (state: IDbState) => T\n): T => {\n  return func({\n    ...state,\n    localState: { ...state.localState, suppressLog: true },\n  });\n};\n\nexport const withSuppressedLog = (state: IDbState): IDbState => {\n  return { ...state, localState: { ...state.localState, suppressLog: true } };\n};\n","import { sql } from \"@kikko-land/sql\";\n\nimport { acquireJob, releaseJob } from \"./job\";\nimport { IDbState, ITransaction } from \"./types\";\nimport { assureDbIsRunning, makeId, unwrapQueries } from \"./utils\";\n\nconst runInTransactionFunc = async <T>(\n  state: IDbState,\n  transactionType: \"DEFERRED\" | \"IMMEDIATE\" | \"EXCLUSIVE\",\n  func: (state: IDbState) => Promise<T>\n) => {\n  const {\n    localState: { transactionsState: transactionsLocalState },\n    sharedState: {\n      transactionsState: transactionsSharedState,\n      eventsEmitter,\n      dbBackend,\n    },\n  } = state;\n\n  // It's indeed that function in same transaction don't need to check db is running\n  // Cause all transaction will await to execute on DB before stop\n  if (transactionsLocalState.current && transactionsSharedState.current) {\n    if (\n      transactionsLocalState.current.id !== transactionsSharedState.current.id\n    ) {\n      // Is it possible?\n      throw new Error(\n        \"Internal error: local running transaction is not the same as shared state transaction\"\n      );\n    }\n\n    // we already in same transaction\n    return await func(state);\n  }\n\n  assureDbIsRunning(state, () => \"transaction\");\n\n  const transaction: ITransaction = {\n    id: makeId(),\n  };\n\n  state = {\n    ...state,\n    localState: {\n      ...state.localState,\n      transactionsState: { current: transaction },\n    },\n  };\n\n  const job = await acquireJob(state.sharedState.jobsState$, {\n    type: \"runTransaction\",\n    transaction,\n  });\n\n  const execOpts = {\n    log: {\n      suppress: Boolean(state.localState.suppressLog),\n      transactionId: transaction.id,\n    },\n  };\n\n  try {\n    transactionsSharedState.current = transaction;\n\n    await eventsEmitter.emit(\"transactionWillStart\", state, transaction);\n\n    await dbBackend.execQueries(\n      unwrapQueries([sql`BEGIN ${sql.raw(transactionType)} TRANSACTION;`]),\n      execOpts\n    );\n\n    await eventsEmitter.emit(\"transactionStarted\", state, transaction);\n\n    try {\n      const res = await func(state);\n\n      await eventsEmitter.emit(\"transactionWillCommit\", state, transaction);\n\n      await dbBackend.execQueries(unwrapQueries([sql`COMMIT`]), execOpts);\n\n      await eventsEmitter.emit(\"transactionCommitted\", state, transaction);\n\n      return res;\n    } catch (e) {\n      console.error(\"Rollback transaction\", e);\n\n      await eventsEmitter.emit(\"transactionWillRollback\", state, transaction);\n\n      await dbBackend.execQueries(unwrapQueries([sql`ROLLBACK`]), execOpts);\n\n      await eventsEmitter.emit(\"transactionRollbacked\", state, transaction);\n\n      throw e;\n    }\n  } finally {\n    releaseJob(state.sharedState.jobsState$, job);\n  }\n};\n\n// By default it is deferred\nexport const runInDeferredTransaction = <T>(\n  state: IDbState,\n  func: (state: IDbState) => Promise<T>\n) => runInTransactionFunc(state, \"DEFERRED\", func);\nexport const runInImmediateTransaction = <T>(\n  state: IDbState,\n  func: (state: IDbState) => Promise<T>\n) => runInTransactionFunc(state, \"IMMEDIATE\", func);\nexport const runInExclusiveTransaction = <T>(\n  state: IDbState,\n  func: (state: IDbState) => Promise<T>\n) => runInTransactionFunc(state, \"EXCLUSIVE\", func);\n\nexport const runInTransaction = <T>(\n  state: IDbState,\n  func: (state: IDbState) => Promise<T>\n) => runInDeferredTransaction(state, func);\n"],"names":[],"mappings":"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"}