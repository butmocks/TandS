(function(s,o){typeof exports=="object"&&typeof module!="undefined"?o(exports,require("rxjs"),require("@kikko-land/sql")):typeof define=="function"&&define.amd?define(["exports","rxjs","@kikko-land/sql"],o):(s=typeof globalThis!="undefined"?globalThis:s||self,o(s.core={},s.rxjs,s.sql))})(this,function(s,o,S){"use strict";const y=(t,e)=>{if(!t.localState.transactionsState)throw new Error("Not in transaction.");const n=[],a=i=>(c,l)=>{e(i,c,l);for(const r of n)r()};n.push(t.sharedState.eventsEmitter.on("transactionCommitted",a("committed"))),n.push(t.sharedState.eventsEmitter.on("transactionRollbacked",a("rollbacked")))},E=(t,e)=>{y(t,(n,a,i)=>{n==="committed"&&e(a,i)})},v=(t,e)=>{y(t,(n,a,i)=>{n==="rollbacked"&&e(a,i)})};function q(){const t={};return{async emit(e,...n){const a=t[e]||[];for(const i of a)await i(...n)},on(e,n){return(t[e]=t[e]||[]).push(n),()=>{t[e]=(t[e]||[]).filter(a=>a!==n)}}}}const I=(t,e)=>{const{sharedState:{runningState$:n,dbName:a}}=t;if(n.value!=="running")throw new Error(`Failed to start ${e()}, db ${a} is stopping`)},f=t=>t.map(e=>e.preparedQuery);function m(){let t="";const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",n=e.length;for(let a=0;a<32;a++)t+=e.charAt(Math.floor(Math.random()*n));return t}const h=async(t,e)=>{const n=m(),a={...e,id:n},{current:i,queue:c}=t.value;if(i||c.length>0){const l=o.firstValueFrom(t.pipe(o.filter(({current:r})=>(r==null?void 0:r.id)===n)));t.next({queue:[...c,a],current:i}),await l}else t.next({queue:[],current:a});return a},w=(t,e)=>{const{current:n,queue:a}=t.value;if((n==null?void 0:n.id)!==e.id)throw new Error(`Can't release job that is not currently running, current: ${JSON.stringify(n)}, queue: ${JSON.stringify(a)}, toRelease: ${JSON.stringify(e)}`);t.next({queue:a.slice(1),current:a[0]})},C=async t=>o.firstValueFrom(t.pipe(o.filter(({queue:e})=>e.length===0))),L=async({dbName:t,plugins:e,queriesMiddlewares:n,dbBackend:a})=>{const i=new o.BehaviorSubject("running"),c=(await a)({dbName:t,stopped$:i.pipe(o.filter(u=>u==="stopped"),o.map(()=>{}),o.take(1))}),l=new o.BehaviorSubject({queue:[],current:void 0}),r={sharedState:{clientId:m(),dbBackend:c,dbName:t,runningState$:i,stopStarted$:i.pipe(o.filter(u=>u==="stopping"),o.map(()=>{}),o.take(1)),eventsEmitter:q(),jobsState$:l,transactionsState:{}},localState:{queriesMiddlewares:n||[],transactionsState:{}}},p=await h(r.sharedState.jobsState$,{type:"initDb",name:t}),d=o.pipe(o.switchMap(async()=>{await c.initialize()}),o.map(()=>{let u=r;for(const b of e||[])u=b(r);return u}),o.switchMap(async u=>(w(l,p),await r.sharedState.eventsEmitter.emit("initialized",r),u)));return o.firstValueFrom(r.sharedState.runningState$.pipe(o.switchMap(u=>u==="running"?o.of(void 0).pipe(d):o.of(r))))},M=async t=>{t.sharedState.runningState$.next("stopping"),await C(t.sharedState.jobsState$),console.log("stopped db"),t.sharedState.runningState$.next("stopped")},$=async({dbState:t,queries:e})=>{var d;const{localState:{transactionsState:n,suppressLog:a},sharedState:{transactionsState:i,jobsState$:c,dbBackend:l}}=t;if(n.current||I(t,()=>JSON.stringify(e)),n.current&&i.current&&n.current.id!==i.current.id)throw new Error("Internal error: local running transaction is not the same as shared state transaction");let r;n.current||(r=await h(c,{type:"runQueries",queries:e.map(u=>u.toSql())}));const p={log:{suppress:Boolean(a),transactionId:(d=n.current)==null?void 0:d.id}};try{const u=await l.execQueries(f(e.map(b=>b.toSql())),p);return{dbState:t,result:u,queries:e}}finally{r&&w(c,r)}},k=async(t,e)=>{const n=[...t.localState.queriesMiddlewares,$].reverse();let a=i=>Promise.resolve(i);for(const i of n){const c=a;a=l=>i({...l,next:c})}return(await a({dbState:t,result:[],queries:e.map(i=>i.toSql())})).result},D=async(t,e)=>(await k(t,[e]))[0]||[],Q=(t,e)=>e({...t,localState:{...t.localState,suppressLog:!0}}),R=t=>({...t,localState:{...t.localState,suppressLog:!0}}),g=async(t,e,n)=>{const{localState:{transactionsState:a},sharedState:{transactionsState:i,eventsEmitter:c,dbBackend:l}}=t;if(a.current&&i.current){if(a.current.id!==i.current.id)throw new Error("Internal error: local running transaction is not the same as shared state transaction");return await n(t)}I(t,()=>"transaction");const r={id:m()};t={...t,localState:{...t.localState,transactionsState:{current:r}}};const p=await h(t.sharedState.jobsState$,{type:"runTransaction",transaction:r}),d={log:{suppress:Boolean(t.localState.suppressLog),transactionId:r.id}};try{i.current=r,await c.emit("transactionWillStart",t,r),await l.execQueries(f([S.sql`BEGIN ${S.sql.raw(e)} TRANSACTION;`]),d),await c.emit("transactionStarted",t,r);try{const u=await n(t);return await c.emit("transactionWillCommit",t,r),await l.execQueries(f([S.sql`COMMIT`]),d),await c.emit("transactionCommitted",t,r),u}catch(u){throw console.error("Rollback transaction",u),await c.emit("transactionWillRollback",t,r),await l.execQueries(f([S.sql`ROLLBACK`]),d),await c.emit("transactionRollbacked",t,r),u}}finally{w(t.sharedState.jobsState$,p)}},T=(t,e)=>g(t,"DEFERRED",e),A=(t,e)=>g(t,"IMMEDIATE",e),B=(t,e)=>g(t,"EXCLUSIVE",e),O=(t,e)=>T(t,e);s.initDbClient=L,s.makeId=m,s.runAfterTransactionCommitted=E,s.runAfterTransactionRollbacked=v,s.runInDeferredTransaction=T,s.runInExclusiveTransaction=B,s.runInImmediateTransaction=A,s.runInTransaction=O,s.runQueries=k,s.runQuery=D,s.stopDb=M,s.suppressLog=Q,s.withSuppressedLog=R,Object.defineProperties(s,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
//# sourceMappingURL=index.umd.js.map
