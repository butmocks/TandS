import { firstValueFrom, filter, BehaviorSubject, map, take, pipe, switchMap, of } from "rxjs";
import { sql } from "@kikko-land/sql";
const runAfterTransaction = (db, func) => {
  if (!db.localState.transactionsState) {
    throw new Error("Not in transaction.");
  }
  const unsubscribes = [];
  const listener = (event) => (db2, transaction) => {
    func(event, db2, transaction);
    for (const unsubscribe of unsubscribes) {
      unsubscribe();
    }
  };
  unsubscribes.push(db.sharedState.eventsEmitter.on("transactionCommitted", listener("committed")));
  unsubscribes.push(db.sharedState.eventsEmitter.on("transactionRollbacked", listener("rollbacked")));
};
const runAfterTransactionCommitted = (db, func) => {
  runAfterTransaction(db, (ev, db2, transaction) => {
    if (ev === "committed") {
      func(db2, transaction);
    }
  });
};
const runAfterTransactionRollbacked = (db, func) => {
  runAfterTransaction(db, (ev, db2, transaction) => {
    if (ev === "rollbacked") {
      func(db2, transaction);
    }
  });
};
function createNanoEvents() {
  const events = {};
  return {
    async emit(event, ...args) {
      const all = events[event] || [];
      for (const toCall of all) {
        await toCall(...args);
      }
    },
    on(event, cb) {
      (events[event] = events[event] || []).push(cb);
      return () => {
        events[event] = (events[event] || []).filter((i) => i !== cb);
      };
    }
  };
}
const assureDbIsRunning = (state, toStart) => {
  const {
    sharedState: { runningState$, dbName }
  } = state;
  if (runningState$.value !== "running") {
    throw new Error(`Failed to start ${toStart()}, db ${dbName} is stopping`);
  }
};
const unwrapQueries = (queries) => {
  return queries.map((q) => q.preparedQuery);
};
function makeId() {
  let result = "";
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const charactersLength = characters.length;
  for (let i = 0; i < 32; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}
const acquireJob = async (jobsState$, _job) => {
  const id = makeId();
  const job = { ..._job, id };
  const { current, queue } = jobsState$.value;
  if (current || queue.length > 0) {
    const promise = firstValueFrom(jobsState$.pipe(filter(({ current: current2 }) => (current2 == null ? void 0 : current2.id) === id)));
    jobsState$.next({ queue: [...queue, job], current });
    await promise;
  } else {
    jobsState$.next({ queue: [], current: job });
  }
  return job;
};
const releaseJob = (jobsState$, job) => {
  const { current, queue } = jobsState$.value;
  if ((current == null ? void 0 : current.id) !== job.id) {
    throw new Error(`Can't release job that is not currently running, current: ${JSON.stringify(current)}, queue: ${JSON.stringify(queue)}, toRelease: ${JSON.stringify(job)}`);
  }
  jobsState$.next({ queue: queue.slice(1), current: queue[0] });
};
const whenAllJobsDone = async (jobsState$) => {
  return firstValueFrom(jobsState$.pipe(filter(({ queue }) => queue.length === 0)));
};
const initDbClient = async ({
  dbName,
  plugins,
  queriesMiddlewares,
  dbBackend
}) => {
  const runningState$ = new BehaviorSubject("running");
  const dbBackendCalled = (await dbBackend)({
    dbName,
    stopped$: runningState$.pipe(filter((e) => e === "stopped"), map(() => void 0), take(1))
  });
  const jobsState$ = new BehaviorSubject({
    queue: [],
    current: void 0
  });
  const state = {
    sharedState: {
      clientId: makeId(),
      dbBackend: dbBackendCalled,
      dbName,
      runningState$,
      stopStarted$: runningState$.pipe(filter((e) => e === "stopping"), map(() => void 0), take(1)),
      eventsEmitter: createNanoEvents(),
      jobsState$,
      transactionsState: {}
    },
    localState: {
      queriesMiddlewares: queriesMiddlewares || [],
      transactionsState: {}
    }
  };
  const job = await acquireJob(state.sharedState.jobsState$, {
    type: "initDb",
    name: dbName
  });
  const initializerPipe = pipe(switchMap(async () => {
    await dbBackendCalled.initialize();
  }), map(() => {
    let currentState = state;
    for (const plugin of plugins || []) {
      currentState = plugin(state);
    }
    return currentState;
  }), switchMap(async (currentState) => {
    releaseJob(jobsState$, job);
    await state.sharedState.eventsEmitter.emit("initialized", state);
    return currentState;
  }));
  return firstValueFrom(state.sharedState.runningState$.pipe(switchMap((runningState) => runningState === "running" ? of(void 0).pipe(initializerPipe) : of(state))));
};
const stopDb = async (state) => {
  state.sharedState.runningState$.next("stopping");
  await whenAllJobsDone(state.sharedState.jobsState$);
  console.log("stopped db");
  state.sharedState.runningState$.next("stopped");
};
const runQueriesMiddleware = async ({
  dbState,
  queries
}) => {
  var _a;
  const {
    localState: { transactionsState: transactionsLocalState, suppressLog: suppressLog2 },
    sharedState: {
      transactionsState: transactionsSharedState,
      jobsState$,
      dbBackend
    }
  } = dbState;
  if (!transactionsLocalState.current) {
    assureDbIsRunning(dbState, () => JSON.stringify(queries));
  }
  if (transactionsLocalState.current && transactionsSharedState.current) {
    if (transactionsLocalState.current.id !== transactionsSharedState.current.id) {
      throw new Error("Internal error: local running transaction is not the same as shared state transaction");
    }
  }
  let job;
  if (!transactionsLocalState.current) {
    job = await acquireJob(jobsState$, {
      type: "runQueries",
      queries: queries.map((q) => q.toSql())
    });
  }
  const execOpts = {
    log: {
      suppress: Boolean(suppressLog2),
      transactionId: (_a = transactionsLocalState.current) == null ? void 0 : _a.id
    }
  };
  try {
    const result = await dbBackend.execQueries(unwrapQueries(queries.map((q) => q.toSql())), execOpts);
    return { dbState, result, queries };
  } finally {
    if (job) {
      releaseJob(jobsState$, job);
    }
  }
};
const runQueries = async (state, queries) => {
  const middlewares = [
    ...state.localState.queriesMiddlewares,
    runQueriesMiddleware
  ].reverse();
  let toCall = (args) => Promise.resolve(args);
  for (const middleware of middlewares) {
    const currentCall = toCall;
    toCall = (args) => middleware({ ...args, next: currentCall });
  }
  return (await toCall({
    dbState: state,
    result: [],
    queries: queries.map((q) => q.toSql())
  })).result;
};
const runQuery = async (state, query) => {
  return (await runQueries(state, [query]))[0] || [];
};
const suppressLog = (state, func) => {
  return func({
    ...state,
    localState: { ...state.localState, suppressLog: true }
  });
};
const withSuppressedLog = (state) => {
  return { ...state, localState: { ...state.localState, suppressLog: true } };
};
const runInTransactionFunc = async (state, transactionType, func) => {
  const {
    localState: { transactionsState: transactionsLocalState },
    sharedState: {
      transactionsState: transactionsSharedState,
      eventsEmitter,
      dbBackend
    }
  } = state;
  if (transactionsLocalState.current && transactionsSharedState.current) {
    if (transactionsLocalState.current.id !== transactionsSharedState.current.id) {
      throw new Error("Internal error: local running transaction is not the same as shared state transaction");
    }
    return await func(state);
  }
  assureDbIsRunning(state, () => "transaction");
  const transaction = {
    id: makeId()
  };
  state = {
    ...state,
    localState: {
      ...state.localState,
      transactionsState: { current: transaction }
    }
  };
  const job = await acquireJob(state.sharedState.jobsState$, {
    type: "runTransaction",
    transaction
  });
  const execOpts = {
    log: {
      suppress: Boolean(state.localState.suppressLog),
      transactionId: transaction.id
    }
  };
  try {
    transactionsSharedState.current = transaction;
    await eventsEmitter.emit("transactionWillStart", state, transaction);
    await dbBackend.execQueries(unwrapQueries([sql`BEGIN ${sql.raw(transactionType)} TRANSACTION;`]), execOpts);
    await eventsEmitter.emit("transactionStarted", state, transaction);
    try {
      const res = await func(state);
      await eventsEmitter.emit("transactionWillCommit", state, transaction);
      await dbBackend.execQueries(unwrapQueries([sql`COMMIT`]), execOpts);
      await eventsEmitter.emit("transactionCommitted", state, transaction);
      return res;
    } catch (e) {
      console.error("Rollback transaction", e);
      await eventsEmitter.emit("transactionWillRollback", state, transaction);
      await dbBackend.execQueries(unwrapQueries([sql`ROLLBACK`]), execOpts);
      await eventsEmitter.emit("transactionRollbacked", state, transaction);
      throw e;
    }
  } finally {
    releaseJob(state.sharedState.jobsState$, job);
  }
};
const runInDeferredTransaction = (state, func) => runInTransactionFunc(state, "DEFERRED", func);
const runInImmediateTransaction = (state, func) => runInTransactionFunc(state, "IMMEDIATE", func);
const runInExclusiveTransaction = (state, func) => runInTransactionFunc(state, "EXCLUSIVE", func);
const runInTransaction = (state, func) => runInDeferredTransaction(state, func);
export { initDbClient, makeId, runAfterTransactionCommitted, runAfterTransactionRollbacked, runInDeferredTransaction, runInExclusiveTransaction, runInImmediateTransaction, runInTransaction, runQueries, runQuery, stopDb, suppressLog, withSuppressedLog };
//# sourceMappingURL=index.es.js.map
