import { ISql } from "@kikko-land/sql";
import { BehaviorSubject } from "rxjs";
import { DeepReadonly } from "ts-essentials";
import { ITransaction } from "./types";
export declare type DistributiveOmit<T, K extends keyof Record<string, unknown>> = T extends unknown ? Omit<T, K> : never;
export declare type IJob = {
    type: "runTransaction";
    id: string;
    transaction: ITransaction;
} | {
    type: "runQueries";
    queries: ISql[];
    id: string;
} | {
    type: "initDb";
    name: string;
    id: string;
};
export declare type IJobsState = DeepReadonly<{
    queue: IJob[];
    current?: IJob;
}>;
export declare const acquireJob: (jobsState$: BehaviorSubject<IJobsState>, _job: DistributiveOmit<IJob, "id">) => Promise<IJob>;
export declare const releaseJob: (jobsState$: BehaviorSubject<IJobsState>, job: IJob) => void;
export declare const whenAllJobsDone: (jobsState$: BehaviorSubject<IJobsState>) => Promise<{
    readonly queue: readonly ({
        readonly type: "runTransaction";
        readonly id: string;
        readonly transaction: {
            readonly id: string;
        };
    } | {
        readonly type: "runQueries";
        readonly queries: readonly {
            readonly _values: readonly (string | number | {
                readonly [x: number]: number;
                readonly BYTES_PER_ELEMENT: number;
                readonly buffer: {
                    readonly byteLength: number;
                    readonly slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                    readonly [Symbol.toStringTag]: string;
                } | {
                    readonly byteLength: number;
                    readonly slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                    readonly [Symbol.species]: any;
                    readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                };
                readonly byteLength: number;
                readonly byteOffset: number;
                readonly copyWithin: (target: number, start: number, end?: number | undefined) => Uint8Array;
                readonly every: (predicate: (value: number, index: number, array: Uint8Array) => unknown, thisArg?: any) => boolean;
                readonly fill: (value: number, start?: number | undefined, end?: number | undefined) => Uint8Array;
                readonly filter: (predicate: (value: number, index: number, array: Uint8Array) => any, thisArg?: any) => Uint8Array;
                readonly find: (predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any) => number | undefined;
                readonly findIndex: (predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any) => number;
                readonly forEach: (callbackfn: (value: number, index: number, array: Uint8Array) => void, thisArg?: any) => void;
                readonly indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                readonly join: (separator?: string | undefined) => string;
                readonly lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                readonly length: number;
                readonly map: (callbackfn: (value: number, index: number, array: Uint8Array) => number, thisArg?: any) => Uint8Array;
                readonly reduce: {
                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;
                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;
                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;
                };
                readonly reduceRight: {
                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;
                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;
                    <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Uint8Array) => U_1, initialValue: U_1): U_1;
                };
                readonly reverse: () => Uint8Array;
                readonly set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                readonly slice: (start?: number | undefined, end?: number | undefined) => Uint8Array;
                readonly some: (predicate: (value: number, index: number, array: Uint8Array) => unknown, thisArg?: any) => boolean;
                readonly sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array;
                readonly subarray: (begin?: number | undefined, end?: number | undefined) => Uint8Array;
                readonly toLocaleString: () => string;
                readonly toString: () => string;
                readonly valueOf: () => Uint8Array;
                readonly entries: () => IterableIterator<[number, number]>;
                readonly keys: () => IterableIterator<number>;
                readonly values: () => IterableIterator<number>;
                readonly includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                readonly at: (index: number) => number | undefined;
                readonly [Symbol.iterator]: () => IterableIterator<number>;
                readonly [Symbol.toStringTag]: "Uint8Array";
            } | null)[];
            readonly _strings: readonly string[];
            readonly tables: readonly {
                readonly name: string;
                readonly dependsOnTables: readonly any[];
                readonly __discriminator: "ITableDef";
                readonly allDependingTables: readonly any[];
            }[];
            readonly _cachedText?: string | undefined;
            readonly _hash?: string | undefined;
            readonly isModifyQuery: boolean;
            readonly isReadQuery: boolean;
            readonly isEmpty: boolean;
            readonly raw: string;
            readonly hash: string;
            readonly preparedQuery: {
                readonly values: readonly (string | number | {
                    readonly [x: number]: number;
                    readonly BYTES_PER_ELEMENT: number;
                    readonly buffer: {
                        readonly byteLength: number;
                        readonly slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                        readonly [Symbol.toStringTag]: string;
                    } | {
                        readonly byteLength: number;
                        readonly slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                        readonly [Symbol.species]: any;
                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                    };
                    readonly byteLength: number;
                    readonly byteOffset: number;
                    readonly copyWithin: (target: number, start: number, end?: number | undefined) => Uint8Array;
                    readonly every: (predicate: (value: number, index: number, array: Uint8Array) => unknown, thisArg?: any) => boolean;
                    readonly fill: (value: number, start?: number | undefined, end?: number | undefined) => Uint8Array;
                    readonly filter: (predicate: (value: number, index: number, array: Uint8Array) => any, thisArg?: any) => Uint8Array;
                    readonly find: (predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any) => number | undefined;
                    readonly findIndex: (predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any) => number;
                    readonly forEach: (callbackfn: (value: number, index: number, array: Uint8Array) => void, thisArg?: any) => void;
                    readonly indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                    readonly join: (separator?: string | undefined) => string;
                    readonly lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                    readonly length: number;
                    readonly map: (callbackfn: (value: number, index: number, array: Uint8Array) => number, thisArg?: any) => Uint8Array;
                    readonly reduce: {
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;
                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;
                    };
                    readonly reduceRight: {
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;
                        <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Uint8Array) => U_1, initialValue: U_1): U_1;
                    };
                    readonly reverse: () => Uint8Array;
                    readonly set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                    readonly slice: (start?: number | undefined, end?: number | undefined) => Uint8Array;
                    readonly some: (predicate: (value: number, index: number, array: Uint8Array) => unknown, thisArg?: any) => boolean;
                    readonly sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array;
                    readonly subarray: (begin?: number | undefined, end?: number | undefined) => Uint8Array;
                    readonly toLocaleString: () => string;
                    readonly toString: () => string;
                    readonly valueOf: () => Uint8Array;
                    readonly entries: () => IterableIterator<[number, number]>;
                    readonly keys: () => IterableIterator<number>;
                    readonly values: () => IterableIterator<number>;
                    readonly includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                    readonly at: (index: number) => number | undefined;
                    readonly [Symbol.iterator]: () => IterableIterator<number>;
                    readonly [Symbol.toStringTag]: "Uint8Array";
                } | null)[];
                readonly text: string;
            };
            readonly inspect: () => {
                preparedQuery: {
                    values: import("@kikko-land/sql").IPrimitiveValue[];
                    text: string;
                };
                tables: import("@kikko-land/sql").ITableDef[];
            };
            readonly toString: () => string;
            readonly toSql: () => ISql;
        }[];
        readonly id: string;
    } | {
        readonly type: "initDb";
        readonly name: string;
        readonly id: string;
    })[];
    readonly current?: {
        readonly type: "runTransaction";
        readonly id: string;
        readonly transaction: {
            readonly id: string;
        };
    } | {
        readonly type: "runQueries";
        readonly queries: readonly {
            readonly _values: readonly (string | number | {
                readonly [x: number]: number;
                readonly BYTES_PER_ELEMENT: number;
                readonly buffer: {
                    readonly byteLength: number;
                    readonly slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                    readonly [Symbol.toStringTag]: string;
                } | {
                    readonly byteLength: number;
                    readonly slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                    readonly [Symbol.species]: any;
                    readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                };
                readonly byteLength: number;
                readonly byteOffset: number;
                readonly copyWithin: (target: number, start: number, end?: number | undefined) => Uint8Array;
                readonly every: (predicate: (value: number, index: number, array: Uint8Array) => unknown, thisArg?: any) => boolean;
                readonly fill: (value: number, start?: number | undefined, end?: number | undefined) => Uint8Array;
                readonly filter: (predicate: (value: number, index: number, array: Uint8Array) => any, thisArg?: any) => Uint8Array;
                readonly find: (predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any) => number | undefined;
                readonly findIndex: (predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any) => number;
                readonly forEach: (callbackfn: (value: number, index: number, array: Uint8Array) => void, thisArg?: any) => void;
                readonly indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                readonly join: (separator?: string | undefined) => string;
                readonly lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                readonly length: number;
                readonly map: (callbackfn: (value: number, index: number, array: Uint8Array) => number, thisArg?: any) => Uint8Array;
                readonly reduce: {
                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;
                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;
                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;
                };
                readonly reduceRight: {
                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;
                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;
                    <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Uint8Array) => U_1, initialValue: U_1): U_1;
                };
                readonly reverse: () => Uint8Array;
                readonly set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                readonly slice: (start?: number | undefined, end?: number | undefined) => Uint8Array;
                readonly some: (predicate: (value: number, index: number, array: Uint8Array) => unknown, thisArg?: any) => boolean;
                readonly sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array;
                readonly subarray: (begin?: number | undefined, end?: number | undefined) => Uint8Array;
                readonly toLocaleString: () => string;
                readonly toString: () => string;
                readonly valueOf: () => Uint8Array;
                readonly entries: () => IterableIterator<[number, number]>;
                readonly keys: () => IterableIterator<number>;
                readonly values: () => IterableIterator<number>;
                readonly includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                readonly at: (index: number) => number | undefined;
                readonly [Symbol.iterator]: () => IterableIterator<number>;
                readonly [Symbol.toStringTag]: "Uint8Array";
            } | null)[];
            readonly _strings: readonly string[];
            readonly tables: readonly {
                readonly name: string;
                readonly dependsOnTables: readonly any[];
                readonly __discriminator: "ITableDef";
                readonly allDependingTables: readonly any[];
            }[];
            readonly _cachedText?: string | undefined;
            readonly _hash?: string | undefined;
            readonly isModifyQuery: boolean;
            readonly isReadQuery: boolean;
            readonly isEmpty: boolean;
            readonly raw: string;
            readonly hash: string;
            readonly preparedQuery: {
                readonly values: readonly (string | number | {
                    readonly [x: number]: number;
                    readonly BYTES_PER_ELEMENT: number;
                    readonly buffer: {
                        readonly byteLength: number;
                        readonly slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                        readonly [Symbol.toStringTag]: string;
                    } | {
                        readonly byteLength: number;
                        readonly slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                        readonly [Symbol.species]: any;
                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                    };
                    readonly byteLength: number;
                    readonly byteOffset: number;
                    readonly copyWithin: (target: number, start: number, end?: number | undefined) => Uint8Array;
                    readonly every: (predicate: (value: number, index: number, array: Uint8Array) => unknown, thisArg?: any) => boolean;
                    readonly fill: (value: number, start?: number | undefined, end?: number | undefined) => Uint8Array;
                    readonly filter: (predicate: (value: number, index: number, array: Uint8Array) => any, thisArg?: any) => Uint8Array;
                    readonly find: (predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any) => number | undefined;
                    readonly findIndex: (predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any) => number;
                    readonly forEach: (callbackfn: (value: number, index: number, array: Uint8Array) => void, thisArg?: any) => void;
                    readonly indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                    readonly join: (separator?: string | undefined) => string;
                    readonly lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                    readonly length: number;
                    readonly map: (callbackfn: (value: number, index: number, array: Uint8Array) => number, thisArg?: any) => Uint8Array;
                    readonly reduce: {
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;
                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;
                    };
                    readonly reduceRight: {
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;
                        <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Uint8Array) => U_1, initialValue: U_1): U_1;
                    };
                    readonly reverse: () => Uint8Array;
                    readonly set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                    readonly slice: (start?: number | undefined, end?: number | undefined) => Uint8Array;
                    readonly some: (predicate: (value: number, index: number, array: Uint8Array) => unknown, thisArg?: any) => boolean;
                    readonly sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array;
                    readonly subarray: (begin?: number | undefined, end?: number | undefined) => Uint8Array;
                    readonly toLocaleString: () => string;
                    readonly toString: () => string;
                    readonly valueOf: () => Uint8Array;
                    readonly entries: () => IterableIterator<[number, number]>;
                    readonly keys: () => IterableIterator<number>;
                    readonly values: () => IterableIterator<number>;
                    readonly includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                    readonly at: (index: number) => number | undefined;
                    readonly [Symbol.iterator]: () => IterableIterator<number>;
                    readonly [Symbol.toStringTag]: "Uint8Array";
                } | null)[];
                readonly text: string;
            };
            readonly inspect: () => {
                preparedQuery: {
                    values: import("@kikko-land/sql").IPrimitiveValue[];
                    text: string;
                };
                tables: import("@kikko-land/sql").ITableDef[];
            };
            readonly toString: () => string;
            readonly toSql: () => ISql;
        }[];
        readonly id: string;
    } | {
        readonly type: "initDb";
        readonly name: string;
        readonly id: string;
    } | undefined;
}>;
