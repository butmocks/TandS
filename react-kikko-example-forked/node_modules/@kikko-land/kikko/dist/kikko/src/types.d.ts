import { IBaseToken } from "@kikko-land/query-builder/src/types";
import { ISqlAdapter } from "@kikko-land/sql";
import { BehaviorSubject, Observable } from "rxjs";
import { DeepReadonly } from "ts-essentials";
import { INanoEmitter } from "./createNanoEvents";
import { IJobsState } from "./job";
export interface IKikkoEvents {
    initialized: (db: IDbState) => Promise<void> | void;
    transactionWillStart: (db: IDbState, transaction: ITransaction) => Promise<void> | void;
    transactionStarted: (db: IDbState, transaction: ITransaction) => Promise<void> | void;
    transactionWillCommit: (db: IDbState, transaction: ITransaction) => Promise<void> | void;
    transactionCommitted: (db: IDbState, transaction: ITransaction) => Promise<void> | void;
    transactionWillRollback: (db: IDbState, transaction: ITransaction) => Promise<void> | void;
    transactionRollbacked: (db: IDbState, transaction: ITransaction) => Promise<void> | void;
}
export interface ITransaction {
    id: string;
}
export declare type IQueriesMiddlewareState = {
    dbState: IDbState;
    result: IQueryResult[];
    queries: (IBaseToken | ISqlAdapter)[];
};
export declare type INextQueriesMiddleware = (args: IQueriesMiddlewareState) => Promise<IQueriesMiddlewareState>;
export declare type IQueriesMiddleware = (args: IQueriesMiddlewareState & {
    next: INextQueriesMiddleware;
}) => Promise<IQueriesMiddlewareState>;
export interface IDbState {
    sharedState: ISharedDbState;
    localState: DeepReadonly<ILocalDbState>;
}
export declare type IQueryValue = number | string | Uint8Array | null;
export declare type IQuery = {
    values: IQueryValue[];
    text: string;
};
export declare type IQueryResult = Record<string, IQueryValue>[];
declare type IDbInstance = {
    initialize(): Promise<void>;
    execQueries(queries: IQuery[], opts: {
        log: {
            suppress: boolean;
            transactionId?: string;
        };
    }): Promise<IQueryResult[]>;
};
export declare type IDbBackend = (db: {
    dbName: string;
    stopped$: Observable<void>;
}) => IDbInstance;
export interface ISharedDbState {
    dbName: string;
    dbBackend: ReturnType<IDbBackend>;
    runningState$: BehaviorSubject<"running" | "stopping" | "stopped">;
    stopStarted$: Observable<void>;
    eventsEmitter: INanoEmitter<IKikkoEvents>;
    clientId: string;
    jobsState$: BehaviorSubject<IJobsState>;
    transactionsState: {
        current?: ITransaction;
    };
}
export interface ILocalDbState {
    transactionsState: {
        current?: ITransaction;
    };
    suppressLog?: boolean;
    queriesMiddlewares: IQueriesMiddleware[];
}
export {};
