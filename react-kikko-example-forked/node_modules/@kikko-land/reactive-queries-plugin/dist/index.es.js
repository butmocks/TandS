import { runQueries } from "@kikko-land/kikko";
import { switchMap, Observable, filter, startWith, takeUntil, share, ReplaySubject, firstValueFrom } from "rxjs";
const getReactiveState = (state) => {
  const reactiveState = state.sharedState.reactiveQueriesState;
  if (!reactiveState) {
    throw new Error("Internal error, maybe you forget to connect the 'reactiveQueries' plugin?");
  }
  return reactiveState;
};
const listenQueries = (db, queries) => {
  const { eventsCh$ } = getReactiveState(db);
  const readingTables = new Set(queries.map((q) => q.toSql()).flatMap((q) => q.tables).map((t) => t.name));
  return eventsCh$.pipe(switchMap((ch) => {
    return new Observable((subscriber) => {
      const func = (data) => {
        subscriber.next(data);
      };
      ch.addEventListener(func);
      return () => {
        ch.removeEventListener(func);
      };
    });
  }), filter(({ changesInTables }) => changesInTables.some((table) => readingTables.has(table))), startWith(void 0), switchMap(async () => {
    return runQueries(db, queries);
  }), takeUntil(db.sharedState.stopStarted$));
};
const createMultiTabChannel = async (name, webMultiTabSupport) => {
  const webChannel = await (async () => {
    if (!webMultiTabSupport)
      return void 0;
    return new (await import("broadcast-channel")).BroadcastChannel(name, {
      type: "localstorage",
      webWorkerSupport: false
    });
  })();
  let listeners = [];
  return {
    async postMessage(data) {
      listeners.forEach((l) => {
        l(data);
      });
      if (webChannel) {
        await webChannel.postMessage(data);
      }
    },
    addEventListener(cb) {
      listeners.push(cb);
      webChannel == null ? void 0 : webChannel.addEventListener("message", cb);
    },
    removeEventListener(cb) {
      listeners = listeners.filter((l) => l !== cb);
      webChannel == null ? void 0 : webChannel.removeEventListener("message", cb);
    },
    async close() {
      listeners = [];
      if (webChannel) {
        await webChannel.close();
      }
    }
  };
};
const getBroadcastCh = (name, webMultiTabSupport, stop$) => {
  return new Observable((sub) => {
    let isClosed = false;
    let currentChannel;
    const init = async () => {
      const ch = await createMultiTabChannel(name, webMultiTabSupport);
      if (isClosed)
        return;
      sub.next(ch);
    };
    void init();
    return () => {
      isClosed = true;
      void (currentChannel == null ? void 0 : currentChannel.close());
    };
  }).pipe(share({
    connector: () => new ReplaySubject(1)
  }), takeUntil(stop$));
};
const notifyTablesContentChanged = async (state, tables) => {
  if (tables.length === 0)
    return;
  const reactiveState = getReactiveState(state);
  return firstValueFrom(reactiveState.eventsCh$.pipe(switchMap(async (ch) => {
    await ch.postMessage({ changesInTables: tables });
  })));
};
const reactiveQueriesPlugin = (opts) => (db) => {
  const transactionTables = {};
  const { dbName, eventsEmitter, stopStarted$ } = db.sharedState;
  const webMultiTabSupport = (opts == null ? void 0 : opts.webMultiTabSupport) !== void 0 ? opts.webMultiTabSupport : true;
  const reactiveQueriesMiddleware = (state) => {
    const transaction = state.dbState.localState.transactionsState.current;
    const writeTables = state.queries.map((q) => q.toSql()).filter((q) => q.isModifyQuery).flatMap((q) => q.tables).flatMap((def) => [
      def.name,
      ...def.dependsOnTables.map(({ name }) => name)
    ]);
    if (writeTables.length !== 0) {
      if (transaction) {
        if (!transactionTables[transaction.id]) {
          throw new Error("Internal error: records with transactionId key was not created");
        }
        for (const t of writeTables) {
          transactionTables[transaction.id].writeTables.add(t);
        }
      } else {
        void notifyTablesContentChanged(state.dbState, writeTables);
      }
    }
    return state.next(state);
  };
  eventsEmitter.on("transactionWillStart", (_db, transaction) => {
    transactionTables[transaction.id] = { writeTables: /* @__PURE__ */ new Set() };
  });
  eventsEmitter.on("transactionRollbacked", (_db, transaction) => {
    delete transactionTables[transaction.id];
  });
  eventsEmitter.on("transactionCommitted", (db2, transaction) => {
    if (!transactionTables[transaction.id]) {
      throw new Error("Internal error: records with transactionId key was not created");
    }
    void notifyTablesContentChanged(db2, [
      ...Array.from(transactionTables[transaction.id].writeTables)
    ]);
    delete transactionTables[transaction.id];
  });
  db.sharedState.reactiveQueriesState = {
    eventsCh$: getBroadcastCh(dbName + "-reactiveQueriesPlugin", webMultiTabSupport, stopStarted$)
  };
  return {
    ...db,
    localState: {
      ...db.localState,
      queriesMiddlewares: [
        ...db.localState.queriesMiddlewares,
        reactiveQueriesMiddleware
      ]
    }
  };
};
export { listenQueries, reactiveQueriesPlugin };
//# sourceMappingURL=index.es.js.map
