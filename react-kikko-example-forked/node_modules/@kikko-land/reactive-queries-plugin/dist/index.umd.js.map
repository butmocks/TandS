{"version":3,"file":"index.umd.js","sources":["../src/utils.ts","../src/listenQueries.ts","../src/getBroadcastCh.ts","../src/reactivePlugin.ts"],"sourcesContent":["import { IDbState } from \"@kikko-land/kikko\";\n\nexport const getReactiveState = (state: IDbState) => {\n  const reactiveState = state.sharedState.reactiveQueriesState;\n\n  if (!reactiveState) {\n    throw new Error(\n      \"Internal error, maybe you forget to connect the 'reactiveQueries' plugin?\"\n    );\n  }\n\n  return reactiveState;\n};\n","import { IDbState, runQueries } from \"@kikko-land/kikko\";\nimport { ISqlAdapter } from \"@kikko-land/sql\";\nimport { filter, Observable, startWith, switchMap, takeUntil } from \"rxjs\";\n\nimport { IMessage } from \"./getBroadcastCh\";\nimport { getReactiveState } from \"./utils\";\n\nexport const listenQueries = <D extends Record<string, unknown>>(\n  db: IDbState,\n  queries: ISqlAdapter[]\n): Observable<D[][]> => {\n  const { eventsCh$ } = getReactiveState(db);\n\n  const readingTables = new Set(\n    queries\n      .map((q) => q.toSql())\n      .flatMap((q) => q.tables)\n      .map((t) => t.name)\n  );\n\n  return eventsCh$.pipe(\n    switchMap((ch) => {\n      return new Observable<IMessage>((subscriber) => {\n        const func = (data: IMessage) => {\n          subscriber.next(data);\n        };\n\n        ch.addEventListener(func);\n\n        return () => {\n          ch.removeEventListener(func);\n        };\n      });\n    }),\n    filter(({ changesInTables }) =>\n      changesInTables.some((table) => readingTables.has(table))\n    ),\n    startWith(undefined), // to exec query at start\n    switchMap(async () => {\n      return runQueries<D>(db, queries);\n    }),\n    takeUntil(db.sharedState.stopStarted$)\n  );\n};\n","import { Observable, ReplaySubject, share, takeUntil } from \"rxjs\";\n\nexport type IMessage = { changesInTables: string[] };\nexport type IListener = (msg: IMessage) => void;\nexport interface INotifyChannel {\n  postMessage(msg: IMessage): Promise<void>;\n  addEventListener(cb: IListener): void;\n  removeEventListener(cb: IListener): void;\n  close(): Promise<void>;\n}\n\nconst createMultiTabChannel = async (\n  name: string,\n  webMultiTabSupport: boolean\n): Promise<INotifyChannel> => {\n  const webChannel = await (async () => {\n    if (!webMultiTabSupport) return undefined;\n\n    return new (await import(\"broadcast-channel\")).BroadcastChannel(name, {\n      type: \"localstorage\",\n      webWorkerSupport: false,\n      // idb: {\n      //   onclose: () => {\n      //     // the onclose event is just the IndexedDB closing.\n      //     // you should also close the channel before creating\n      //     // a new one.\n      //     void currentChannel?.close();\n      //     createChannel();\n      //   },\n      // },\n    });\n  })();\n\n  let listeners: IListener[] = [];\n\n  return {\n    async postMessage(data) {\n      listeners.forEach((l) => {\n        l(data);\n      });\n\n      if (webChannel) {\n        await webChannel.postMessage(data);\n      }\n    },\n    addEventListener(cb) {\n      listeners.push(cb);\n\n      webChannel?.addEventListener(\"message\", cb);\n    },\n    removeEventListener(cb) {\n      listeners = listeners.filter((l) => l !== cb);\n\n      webChannel?.removeEventListener(\"message\", cb);\n    },\n    async close() {\n      listeners = [];\n\n      if (webChannel) {\n        await webChannel.close();\n      }\n    },\n  };\n};\n\nexport const getBroadcastCh = (\n  name: string,\n  webMultiTabSupport: boolean,\n  stop$: Observable<void>\n) => {\n  return new Observable<INotifyChannel>((sub) => {\n    let isClosed = false;\n    let currentChannel: INotifyChannel | undefined;\n\n    const init = async () => {\n      const ch = await createMultiTabChannel(name, webMultiTabSupport);\n\n      if (isClosed) return;\n\n      sub.next(ch);\n    };\n\n    void init();\n\n    return () => {\n      isClosed = true;\n      void currentChannel?.close();\n    };\n  }).pipe(\n    share({\n      connector: () => new ReplaySubject(1),\n    }),\n    takeUntil(stop$)\n  );\n};\n","import {\n  IDbClientPlugin,\n  IDbState,\n  IQueriesMiddleware,\n} from \"@kikko-land/kikko\";\nimport { firstValueFrom, switchMap } from \"rxjs\";\n\nimport { getBroadcastCh } from \"./getBroadcastCh\";\nimport { getReactiveState } from \"./utils\";\n\nconst notifyTablesContentChanged = async (\n  state: IDbState,\n  tables: string[]\n) => {\n  if (tables.length === 0) return;\n\n  const reactiveState = getReactiveState(state);\n\n  return firstValueFrom(\n    reactiveState.eventsCh$.pipe(\n      switchMap(async (ch) => {\n        await ch.postMessage({ changesInTables: tables });\n      })\n    )\n  );\n};\n\nexport const reactiveQueriesPlugin: (opts?: {\n  webMultiTabSupport?: boolean;\n}) => IDbClientPlugin = (opts) => (db) => {\n  const transactionTables: Record<string, { writeTables: Set<string> }> = {};\n  const { dbName, eventsEmitter, stopStarted$ } = db.sharedState;\n\n  const webMultiTabSupport =\n    opts?.webMultiTabSupport !== undefined ? opts.webMultiTabSupport : true;\n\n  const reactiveQueriesMiddleware: IQueriesMiddleware = (state) => {\n    const transaction = state.dbState.localState.transactionsState.current;\n\n    const writeTables = state.queries\n      .map((q) => q.toSql())\n      .filter((q) => q.isModifyQuery)\n      .flatMap((q) => q.tables)\n      .flatMap((def) => [\n        def.name,\n        ...def.dependsOnTables.map(({ name }) => name),\n      ]);\n\n    if (writeTables.length !== 0) {\n      if (transaction) {\n        if (!transactionTables[transaction.id]) {\n          throw new Error(\n            \"Internal error: records with transactionId key was not created\"\n          );\n        }\n\n        for (const t of writeTables) {\n          transactionTables[transaction.id].writeTables.add(t);\n        }\n      } else {\n        // dont await so notification happens after function return\n        void notifyTablesContentChanged(state.dbState, writeTables);\n      }\n    }\n\n    return state.next(state);\n  };\n\n  eventsEmitter.on(\"transactionWillStart\", (_db, transaction) => {\n    transactionTables[transaction.id] = { writeTables: new Set() };\n  });\n\n  eventsEmitter.on(\"transactionRollbacked\", (_db, transaction) => {\n    delete transactionTables[transaction.id];\n  });\n\n  eventsEmitter.on(\"transactionCommitted\", (db, transaction) => {\n    if (!transactionTables[transaction.id]) {\n      throw new Error(\n        \"Internal error: records with transactionId key was not created\"\n      );\n    }\n\n    void notifyTablesContentChanged(db, [\n      ...Array.from(transactionTables[transaction.id].writeTables),\n    ]);\n\n    delete transactionTables[transaction.id];\n  });\n\n  db.sharedState.reactiveQueriesState = {\n    eventsCh$: getBroadcastCh(\n      dbName + \"-reactiveQueriesPlugin\",\n      webMultiTabSupport,\n      stopStarted$\n    ),\n  };\n\n  return {\n    ...db,\n    localState: {\n      ...db.localState,\n      queriesMiddlewares: [\n        ...db.localState.queriesMiddlewares,\n        reactiveQueriesMiddleware,\n      ],\n    },\n  };\n};\n"],"names":["switchMap","Observable","filter","startWith","runQueries","takeUntil","share","ReplaySubject","firstValueFrom"],"mappings":"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"}