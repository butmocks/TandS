function isWorker() {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
}
function makeStartWorkerFromMain(getModule) {
  return (argBuffer, resultBuffer, parentWorker) => {
    if (isWorker()) {
      throw new Error("`startWorkerFromMain` should only be called from the main thread");
    }
    if (typeof Worker === "undefined") {
      throw new Error("Web workers not available. sqlite3 requires web workers to work.");
    }
    getModule().then(({ default: BackendWorker }) => {
      let worker = new BackendWorker();
      worker.postMessage({ type: "init", buffers: [argBuffer, resultBuffer] });
      worker.addEventListener("message", (msg) => {
        parentWorker.postMessage(msg.data);
      });
    });
  };
}
function makeInitBackend(spawnEventName, getModule) {
  const startWorkerFromMain = makeStartWorkerFromMain(getModule);
  return (worker) => {
    worker.addEventListener("message", (e) => {
      switch (e.data.type) {
        case spawnEventName:
          startWorkerFromMain(e.data.argBuffer, e.data.resultBuffer, worker);
          break;
      }
    });
  };
}
const initBackend = makeInitBackend("__absurd:spawn-idb-worker", () => Promise.resolve().then(function() {
  return indexeddbMainThreadWorkerD62f296a;
}));
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function isFunction(value) {
  return typeof value === "function";
}
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty = new Subscription2();
    empty.closed = true;
    return empty;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    {
      throw err;
    }
  });
}
function noop() {
}
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped)
      ;
    else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x) {
  return x;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last2 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last2 = i;
      }
      last2 && _buffer.splice(0, last2 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay) {
    return this;
  };
  return Action2;
}(Subscription);
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay != null && this.delay === delay && this.pending === false) {
      return id;
    }
    intervalProvider.clearInterval(id);
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    _this._scheduled = void 0;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);
var asyncScheduler = new AsyncScheduler(AsyncAction);
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});
function isScheduler(value) {
  return value && isFunction(value.schedule);
}
function last(arr) {
  return arr[arr.length - 1];
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}
function isInteropObservable(input) {
  return isFunction(input[observable]);
}
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
  if (delay === void 0) {
    delay = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
function observeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay);
    }));
  });
}
function subscribeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay));
  });
}
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator$1;
    executeSchedule(subscriber, scheduler, function() {
      iterator$1 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator$1.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return();
    };
  });
}
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});
function timeout(config2, schedulerArg) {
  var _a = isValidDate(config2) ? { first: config2 } : typeof config2 === "number" ? { each: config2 } : config2, first2 = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
  if (first2 == null && each == null) {
    throw new TypeError("No timeout provided.");
  }
  return operate(function(source, subscriber) {
    var originalSourceSubscription;
    var timerSubscription;
    var lastValue = null;
    var seen = 0;
    var startTimer = function(delay) {
      timerSubscription = executeSchedule(subscriber, scheduler, function() {
        try {
          originalSourceSubscription.unsubscribe();
          innerFrom(_with({
            meta,
            lastValue,
            seen
          })).subscribe(subscriber);
        } catch (err) {
          subscriber.error(err);
        }
      }, delay);
    };
    originalSourceSubscription = source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
      seen++;
      subscriber.next(lastValue = value);
      each > 0 && startTimer(each);
    }, void 0, void 0, function() {
      if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
        timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
      }
      lastValue = null;
    }));
    !seen && startTimer(first2 != null ? typeof first2 === "number" ? first2 : +first2 - scheduler.now() : each);
  });
}
function timeoutErrorFactory(info) {
  throw new TimeoutError(info);
}
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}
function defaultIfEmpty(defaultValue) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}
function take(count) {
  return count <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count) {
        subscriber.next(value);
        if (count <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
    }));
  });
}
function defaultErrorFactory() {
  return new EmptyError();
}
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v, i) {
      return predicate(v, i, source);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.connector, connector = _a === void 0 ? function() {
    return new Subject();
  } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection = null;
    var resetConnection = null;
    var subject = null;
    var refCount = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = null;
    };
    var reset = function() {
      cancelReset();
      connection = subject = null;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount--;
        if (refCount === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        from(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return null;
  }
  if (on === false) {
    return null;
  }
  return on.apply(void 0, __spreadArray([], __read(args))).pipe(take(1)).subscribe(function() {
    return reset();
  });
}
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}
function makeId() {
  let result = "";
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const charactersLength = characters.length;
  for (let i = 0; i < 32; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}
const tableSymbol = Symbol("table");
const table = (name, dependsOnTables) => {
  return {
    name,
    dependsOnTables: dependsOnTables || [],
    get allDependingTables() {
      const tableDefs = [];
      this.dependsOnTables.forEach((def) => {
        tableDefs.push(...def.allDependingTables);
      });
      return tableDefs;
    },
    get [tableSymbol]() {
      return this;
    },
    __discriminator: "ITableDef"
  };
};
function isTable(x) {
  if (x === null)
    return false;
  if (typeof x !== "object")
    return false;
  return Boolean(x[tableSymbol]);
}
const insertRegex = /insert\s+(or\s+\w+\s+)?into\s+/gim;
const deleteRegex = /delete\s+from\s+/gim;
const updateRegex = /update\s+(or\s+\w+\s+)?/gim;
const strip = (str) => {
  return str.replace(/"/g, "").split(".").map((v) => '"' + v + '"').join(".");
};
function isSql(x) {
  if (x === null)
    return false;
  if (typeof x !== "object")
    return false;
  return "toSql" in x;
}
function internalSql(_rawStrings, _rawValues) {
  if (_rawStrings.length - 1 !== _rawValues.length) {
    if (_rawStrings.length === 0) {
      throw new TypeError("Expected at least 1 string");
    }
    throw new TypeError(`Expected ${_rawStrings.length} strings to have ${_rawStrings.length - 1} values`);
  }
  const valuesLength = _rawValues.reduce((len, value) => len + (isSql(value) ? value.toSql()._values.length : isTable(value) ? 0 : 1), 0);
  const tablesLength = _rawValues.reduce((len, value) => len + (isSql(value) ? value.toSql().tables.length : isTable(value) ? 1 : 0), 0);
  const values = new Array(valuesLength);
  const strings = new Array(valuesLength + 1);
  const tables = new Array(tablesLength);
  strings[0] = _rawStrings[0];
  let pos = 0, tableI = 0;
  _rawValues.forEach((val, i) => {
    const child = _rawValues[i];
    const rawString = _rawStrings[i + 1];
    if (isSql(child)) {
      const sql2 = child.toSql();
      strings[pos] += sql2._strings[0];
      sql2._values.forEach((childVal, childI) => {
        values[pos++] = sql2._values[childI];
        strings[pos] = sql2._strings[childI + 1];
      });
      sql2.tables.forEach((t, childTableI) => {
        tables[tableI++] = sql2.tables[childTableI++];
      });
      strings[pos] += rawString;
    } else if (isTable(child)) {
      strings[pos] += strip(child[tableSymbol].name) + rawString;
      tables[tableI++] = child[tableSymbol];
    } else {
      values[pos++] = child;
      strings[pos] = rawString;
    }
  });
  return {
    _values: values,
    _strings: strings,
    tables,
    get isModifyQuery() {
      const query = this.preparedQuery.text;
      return query.match(insertRegex) !== null || query.match(deleteRegex) !== null || query.match(updateRegex) !== null;
    },
    get isReadQuery() {
      return !this.isModifyQuery;
    },
    get isEmpty() {
      return this.preparedQuery.text.trim().length === 0;
    },
    get hash() {
      if (!this._hash) {
        this._hash = this._strings.join() + this._values.join();
      }
      return this._hash;
    },
    get raw() {
      return this._strings[0] + this._strings.slice(1).map((val, i) => (typeof this._values[i] === "string" ? "'" + this._values[i] + "'" : this._values[i]) + val).join("");
    },
    get preparedQuery() {
      if (!this._cachedText) {
        this._cachedText = (this._strings[0] + this._strings.slice(1).map((val, i) => `?${val}`).join("")).trim();
      }
      return {
        values: this._values,
        text: this._cachedText
      };
    },
    inspect() {
      return {
        preparedQuery: this.preparedQuery,
        tables: this.tables
      };
    },
    toSql() {
      return this;
    },
    toString() {
      const { values: values2, text } = this.preparedQuery;
      return `${text} - [${values2.join(", ")}]`;
    }
  };
}
function sql(rawStrings, ...rawValues) {
  return internalSql(rawStrings, rawValues);
}
sql.raw = (value) => {
  return sql([value]);
};
sql.liter = (str) => {
  return sql.raw(strip(str));
};
sql.table = table;
sql.isTable = isTable;
sql.isSql = isSql;
sql.empty = sql.raw("");
sql.join = (values, separator = ", ", prefix = "", suffix = "") => {
  values = values.filter((v) => isSql(v) ? !v.toSql().isEmpty : true);
  if (values.length === 0) {
    throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
  }
  return internalSql([prefix, ...Array(values.length - 1).fill(separator), suffix], values);
};
const buildRunQueriesCommand = (queries, opts) => {
  return {
    commandId: makeId(),
    type: "runQueries",
    queries,
    logOpts: opts.log
  };
};
const runWorkerCommand = async (backendState, command) => {
  const { messagesFromWorker$, messagesToWorker$, stop$ } = backendState;
  const waitResponse = firstValueFrom(messagesFromWorker$.pipe(filter((ev) => ev.type === "response" && ev.data.commandId === command.commandId), take(1), switchMap((ev) => {
    if (ev.type === "response" && ev.data.status === "error") {
      throw new Error(ev.data.message);
    } else {
      return of(ev);
    }
  }), map((ev) => {
    if (ev.type === "response" && ev.data.status === "success") {
      return ev.data.result;
    } else {
      throw new Error("Unknown data format");
    }
  }), timeout({
    each: backendState.queryTimeout,
    with: () => throwError(() => new Error(`Failed to execute ${JSON.stringify(command)} - timeout`))
  }), takeUntil(stop$)));
  messagesToWorker$.next({
    type: "command",
    data: command
  });
  try {
    return await waitResponse;
  } catch (e) {
    if (e instanceof EmptyError) {
      throw new Error(`Failed to run command, usually it means DB is already stopped. Command:
${JSON.stringify(command, void 0, 2)}`);
    }
    throw e;
  }
};
const encodedJs = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NvbnN0IGZ0PXtFUEVSTTo2MyxFTk9FTlQ6NDR9O2NsYXNzIE90e2NvbnN0cnVjdG9yKGEsZil7dGhpcy5GUz1hLHRoaXMuYmFja2VuZD1mLHRoaXMubm9kZV9vcHM9e2dldGF0dHI6dT0+e2xldCBjPWEuaXNGaWxlKHUubW9kZSk/dS5jb250ZW50cy5nZXRhdHRyKCk6bnVsbCxwPXt9O3JldHVybiBwLmRldj0xLHAuaW5vPXUuaWQscC5tb2RlPWM/Yy5tb2RlOnUubW9kZSxwLm5saW5rPTEscC51aWQ9MCxwLmdpZD0wLHAucmRldj11LnJkZXYscC5zaXplPWM/Yy5zaXplOmEuaXNEaXIodS5tb2RlKT80MDk2OjAscC5hdGltZT1uZXcgRGF0ZSgwKSxwLm10aW1lPW5ldyBEYXRlKDApLHAuY3RpbWU9bmV3IERhdGUoMCkscC5ibGtzaXplPWM/Yy5ibG9ja1NpemU6NDA5NixwLmJsb2Nrcz1NYXRoLmNlaWwocC5zaXplL3AuYmxrc2l6ZSkscH0sc2V0YXR0cjoodSxjKT0+e3RoaXMuRlMuaXNGaWxlKHUubW9kZSk/dS5jb250ZW50cy5zZXRhdHRyKGMpOihjLm1vZGUhPW51bGwmJih1Lm1vZGU9Yy5tb2RlKSxjLnNpemUhPW51bGwmJih1LnNpemU9Yy5zaXplKSl9LGxvb2t1cDoodSxjKT0+e3Rocm93IG5ldyB0aGlzLkZTLkVycm5vRXJyb3IoZnQuRU5PRU5UKX0sbWtub2Q6KHUsYyxwLHkpPT57aWYoYy5lbmRzV2l0aCgiLmxvY2siKSl0aHJvdyBuZXcgRXJyb3IoIkxvY2tpbmcgdmlhIGxvY2tmaWxlcyBpcyBub3Qgc3VwcG9ydGVkIik7cmV0dXJuIHRoaXMuY3JlYXRlTm9kZSh1LGMscCx5KX0scmVuYW1lOih1LGMscCk9Pnt0aHJvdyBuZXcgRXJyb3IoInJlbmFtZSBub3QgaW1wbGVtZW50ZWQiKX0sdW5saW5rOih1LGMpPT57dGhpcy5GUy5sb29rdXBOb2RlKHUsYykuY29udGVudHMuZGVsZXRlKGMpfSxyZWFkZGlyOnU9Pnt0aHJvdyBuZXcgRXJyb3IoInJlYWRkaXIgbm90IGltcGxlbWVudGVkIil9LHN5bWxpbms6KHUsYyxwKT0+e3Rocm93IG5ldyBFcnJvcigic3ltbGluayBub3QgaW1wbGVtZW50ZWQiKX0scmVhZGxpbms6dT0+e3Rocm93IG5ldyBFcnJvcigic3ltbGluayBub3QgaW1wbGVtZW50ZWQiKX19LHRoaXMuc3RyZWFtX29wcz17b3Blbjp1PT57dGhpcy5GUy5pc0ZpbGUodS5ub2RlLm1vZGUpJiZ1Lm5vZGUuY29udGVudHMub3BlbigpfSxjbG9zZTp1PT57dGhpcy5GUy5pc0ZpbGUodS5ub2RlLm1vZGUpJiZ1Lm5vZGUuY29udGVudHMuY2xvc2UoKX0scmVhZDoodSxjLHAseSxrKT0+dS5ub2RlLmNvbnRlbnRzLnJlYWQoYyxwLHksayksd3JpdGU6KHUsYyxwLHksayk9PnUubm9kZS5jb250ZW50cy53cml0ZShjLHAseSxrKSxsbHNlZWs6KHUsYyxwKT0+e3ZhciB5PWM7aWYocD09PTE/eSs9dS5wb3NpdGlvbjpwPT09MiYmYS5pc0ZpbGUodS5ub2RlLm1vZGUpJiYoeSs9dS5ub2RlLmNvbnRlbnRzLmdldGF0dHIoKS5zaXplKSx5PDApdGhyb3cgbmV3IHRoaXMuRlMuRXJybm9FcnJvcigyOCk7cmV0dXJuIHl9LGFsbG9jYXRlOih1LGMscCk9Pnt1Lm5vZGUuY29udGVudHMuc2V0YXR0cih7c2l6ZTpjK3B9KX0sbW1hcDoodSxjLHAseSxrLHMpPT57dGhyb3cgbmV3IEVycm9yKCJtbWFwIG5vdCBpbXBsZW1lbnRlZCIpfSxtc3luYzoodSxjLHAseSxrKT0+e3Rocm93IG5ldyBFcnJvcigibXN5bmMgbm90IGltcGxlbWVudGVkIil9LGZzeW5jOih1LGMscCx5LGspPT57dS5ub2RlLmNvbnRlbnRzLmZzeW5jKCl9fX1tb3VudCgpe3JldHVybiB0aGlzLmNyZWF0ZU5vZGUobnVsbCwiLyIsMTY4OTUsMCl9bG9jayhhLGYpe2xldHtub2RlOnV9PXRoaXMuRlMubG9va3VwUGF0aChhKTtyZXR1cm4gdS5jb250ZW50cy5sb2NrKGYpfXVubG9jayhhLGYpe2xldHtub2RlOnV9PXRoaXMuRlMubG9va3VwUGF0aChhKTtyZXR1cm4gdS5jb250ZW50cy51bmxvY2soZil9Y3JlYXRlTm9kZShhLGYsdSxjKXtpZighKHRoaXMuRlMuaXNEaXIodSl8fHRoaXMuRlMuaXNGaWxlKHUpKSl0aHJvdyBuZXcgdGhpcy5GUy5FcnJub0Vycm9yKGZ0LkVQRVJNKTt2YXIgcD10aGlzLkZTLmNyZWF0ZU5vZGUoYSxmLHUsYyk7cmV0dXJuIHRoaXMuRlMuaXNEaXIocC5tb2RlKT8ocC5ub2RlX29wcz17bWtub2Q6dGhpcy5ub2RlX29wcy5ta25vZCxsb29rdXA6dGhpcy5ub2RlX29wcy5sb29rdXAsdW5saW5rOnRoaXMubm9kZV9vcHMudW5saW5rLHNldGF0dHI6dGhpcy5ub2RlX29wcy5zZXRhdHRyfSxwLnN0cmVhbV9vcHM9e30scC5jb250ZW50cz17fSk6dGhpcy5GUy5pc0ZpbGUocC5tb2RlKSYmKHAubm9kZV9vcHM9dGhpcy5ub2RlX29wcyxwLnN0cmVhbV9vcHM9dGhpcy5zdHJlYW1fb3BzLHAuY29udGVudHM9dGhpcy5iYWNrZW5kLmNyZWF0ZUZpbGUoZikpLGEmJihhLmNvbnRlbnRzW2ZdPXAsYS50aW1lc3RhbXA9cC50aW1lc3RhbXApLHB9fWNvbnN0IGp0PU90O2xldCBfZT17Tk9ORTowLFNIQVJFRDoxLFJFU0VSVkVEOjIsUEVORElORzozLEVYQ0xVU0lWRTo0fTtmdW5jdGlvbiAkZShFKXtsZXQgYT1FWzE2XSxmPUVbMTddO3JldHVybihhPDw4KStmfWZ1bmN0aW9uIFZ0KEUsYSl7aWYoRSE9bnVsbCYmYSE9bnVsbCl7bGV0IGY9bmV3IFVpbnQ4QXJyYXkoRSksdT1uZXcgVWludDhBcnJheShhKTtmb3IobGV0IGM9MjQ7Yzw0MDtjKyspaWYoZltjXSE9PXVbY10pcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIEU9PW51bGwmJmE9PW51bGx9ZnVuY3Rpb24gQ3QoRSxhLGYpe2xldCB1PVtdO2ZvcihsZXQgYz1FO2M8PWE7Yys9Zil1LnB1c2goYyk7cmV0dXJuIHV9ZnVuY3Rpb24gY3QoRSxhLGYpe2xldCB1PWEtYSVFLGM9Zi0xLShmLTEpJUU7cmV0dXJuIEN0KHUsYyxFKX1mdW5jdGlvbiBIdChFLGEsZil7bGV0IHU9bmV3IEFycmF5QnVmZmVyKGYtYSksYz1uZXcgVWludDhBcnJheSh1KTtmb3IobGV0IHA9MDtwPEUubGVuZ3RoO3ArKyl7bGV0IHk9RVtwXTtpZih5LmRhdGEuY29uc3RydWN0b3IubmFtZSE9PSJBcnJheUJ1ZmZlciIpdGhyb3cgbmV3IEVycm9yKCJDaHVuayBkYXRhIGlzIG5vdCBhbiBBcnJheUJ1ZmZlciIpO2xldCBrPTAscz15LmRhdGEuYnl0ZUxlbmd0aDtpZihhPnkucG9zJiYoaz1hLXkucG9zKSxmPHkucG9zK3kuZGF0YS5ieXRlTGVuZ3RoJiYocz1mLXkucG9zKSxrPnkuZGF0YS5ieXRlTGVuZ3RofHxzPDApY29udGludWU7bGV0IE09cy1rO2Muc2V0KG5ldyBVaW50OEFycmF5KHkuZGF0YSxrLE0pLHkucG9zLWErayl9cmV0dXJuIHV9ZnVuY3Rpb24gaHQoRSxhLGYsdSl7bGV0IGM9Y3QoYSxmLHUpLHA9MDtyZXR1cm4gYy5tYXAoeT0+e2xldCBrPTAscz1hO2Y+eSYmZjx5K2EmJihrPWYteSksdT55JiZ1PHkrYSYmKHM9dS15KTtsZXQgTT1zLWssVz1uZXcgQXJyYXlCdWZmZXIoYSk7aWYoZj55K2F8fHU8PXkpcmV0dXJuIG51bGw7bGV0IEk9RS5ieXRlT2Zmc2V0K3AsUj1FLmJ1ZmZlci5ieXRlTGVuZ3RoLUk7aWYoUjw9MClyZXR1cm4gbnVsbDtsZXQgeD1NYXRoLm1pbihNLFIpO3JldHVybiBuZXcgVWludDhBcnJheShXKS5zZXQobmV3IFVpbnQ4QXJyYXkoRS5idWZmZXIsSSx4KSxrKSxwKz14LHtwb3M6eSxkYXRhOlcsb2Zmc2V0OmssbGVuZ3RoOnh9fSkuZmlsdGVyKEJvb2xlYW4pfWNsYXNzICR0e2NvbnN0cnVjdG9yKGEsZix1PW51bGwpe3RoaXMuZmlsZW5hbWU9YSx0aGlzLmJ1ZmZlcj1uZXcgTWFwLHRoaXMub3BzPWYsdGhpcy5tZXRhPXUsdGhpcy5fbWV0YURpcnR5PSExLHRoaXMud3JpdGVMb2NrPSExLHRoaXMub3BlbkhhbmRsZXM9MH1idWZmZXJDaHVua3MoYSl7Zm9yKGxldCBmPTA7ZjxhLmxlbmd0aDtmKyspe2xldCB1PWFbZl07dGhpcy5idWZmZXIuc2V0KHUucG9zLHUpfX1vcGVuKCl7aWYodGhpcy5vcGVuSGFuZGxlcysrLHRoaXMub3BlbkhhbmRsZXM9PT0xKXt0aGlzLm9wcy5vcGVuKCk7bGV0IGE9dGhpcy5vcHMucmVhZE1ldGEoKTt0aGlzLm1ldGE9PW51bGwmJihhPT1udWxsJiYoYT17c2l6ZTowfSksdGhpcy5tZXRhPWEpfXJldHVybiB0aGlzLm1ldGF9Y2xvc2UoKXt0aGlzLmZzeW5jKCksdGhpcy5vcGVuSGFuZGxlcz1NYXRoLm1heCh0aGlzLm9wZW5IYW5kbGVzLTEsMCksdGhpcy5vcGVuSGFuZGxlcz09PTAmJnRoaXMub3BzLmNsb3NlKCl9ZGVsZXRlKCl7dGhpcy5vcHMuZGVsZXRlKCl9bG9hZChhKXtsZXQgZj1hLnJlZHVjZSgoYyxwKT0+e2xldCB5PXRoaXMuYnVmZmVyLmdldChwKTtyZXR1cm4geT9jLmNodW5rcy5wdXNoKHkpOmMubWlzc2luZy5wdXNoKHApLGN9LHtjaHVua3M6W10sbWlzc2luZzpbXX0pLHU9W107cmV0dXJuIGYubWlzc2luZy5sZW5ndGg+MCYmKHU9dGhpcy5vcHMucmVhZEJsb2NrcyhmLm1pc3NpbmcsdGhpcy5tZXRhLmJsb2NrU2l6ZSkpLGYuY2h1bmtzLmNvbmNhdCh1KX1yZWFkKGEsZix1LGMpe2xldCBwPWEuYnVmZmVyO2lmKHU8PTB8fGM8MClyZXR1cm4gMDtpZihjPj10aGlzLm1ldGEuc2l6ZSl7bGV0IHg9bmV3IFVpbnQ4QXJyYXkocCxmKTtmb3IobGV0IE89MDtPPHU7TysrKXhbT109MDtyZXR1cm4gdX1jPU1hdGgubWF4KGMsMCk7bGV0IHk9TWF0aC5taW4odSx0aGlzLm1ldGEuc2l6ZS1jKSxrPWMscz1jK3ksTT1jdCh0aGlzLm1ldGEuYmxvY2tTaXplLGsscyksVz10aGlzLmxvYWQoTSksST1IdChXLGsscyk7aWYocC5ieXRlTGVuZ3RoLWY8SS5ieXRlTGVuZ3RoKXRocm93IG5ldyBFcnJvcigiQnVmZmVyIGdpdmVuIHRvIGByZWFkYCBpcyB0b28gc21hbGwiKTtsZXQgUj1uZXcgVWludDhBcnJheShwKTtSLnNldChuZXcgVWludDhBcnJheShJKSxmKTtmb3IobGV0IHg9eTt4PHU7eCsrKVJbZit4XT0wO3JldHVybiB1fXdyaXRlKGEsZix1LGMpe2lmKHRoaXMubWV0YS5ibG9ja1NpemU9PW51bGwpe2xldCBJPSRlKG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLGEuYnl0ZU9mZnNldCtmKSk7aWYoIVs1MTIsMTAyNCwyMDQ4LDQwOTYsODE5MiwxNjM4NCwzMjc2OCw2NTUzNl0uaW5jbHVkZXMoSSkpdGhyb3cgbmV3IEVycm9yKCJGaWxlIGhhcyBpbnZhbGlkIHBhZ2Ugc2l6ZS4gKHRoZSBmaXJzdCBibG9jayBvZiBhIG5ldyBmaWxlIG11c3QgYmUgd3JpdHRlbiBmaXJzdCkiKTt0aGlzLnNldGF0dHIoe2Jsb2NrU2l6ZTpJfSl9bGV0IHA9YS5idWZmZXI7aWYodTw9MHx8YzwwfHxwLmJ5dGVMZW5ndGg9PT0wKXJldHVybiAwO3U9TWF0aC5taW4odSxwLmJ5dGVMZW5ndGgtZik7bGV0IHk9aHQobmV3IFVpbnQ4QXJyYXkocCxmLHUpLHRoaXMubWV0YS5ibG9ja1NpemUsYyxjK3UpLHtwYXJ0aWFsV3JpdGVzOmssZnVsbFdyaXRlczpzfT15LnJlZHVjZSgoSSxSKT0+KFIubGVuZ3RoIT09dGhpcy5tZXRhLmJsb2NrU2l6ZT9JLnBhcnRpYWxXcml0ZXMucHVzaChSKTpJLmZ1bGxXcml0ZXMucHVzaCh7cG9zOlIucG9zLGRhdGE6Ui5kYXRhfSksSSkse2Z1bGxXcml0ZXM6W10scGFydGlhbFdyaXRlczpbXX0pLE09W107ay5sZW5ndGg+MCYmKE09dGhpcy5sb2FkKGsubWFwKEk9PkkucG9zKSkpO2xldCBXPXMuY29uY2F0KE0ubWFwKEk9PntsZXQgUj1rLmZpbmQoeD0+eC5wb3M9PT1JLnBvcyk7cmV0dXJuIG5ldyBVaW50OEFycmF5KEkuZGF0YSkuc2V0KG5ldyBVaW50OEFycmF5KFIuZGF0YSxSLm9mZnNldCxSLmxlbmd0aCksUi5vZmZzZXQsUi5sZW5ndGgpLEl9KSk7cmV0dXJuIHRoaXMuYnVmZmVyQ2h1bmtzKFcpLGMrdT50aGlzLm1ldGEuc2l6ZSYmdGhpcy5zZXRhdHRyKHtzaXplOmMrdX0pLHV9YXN5bmMgcmVhZElmRmFsbGJhY2soKXtpZih0aGlzLm9wcy5yZWFkSWZGYWxsYmFjayl7bGV0IGE9YXdhaXQgdGhpcy5vcHMucmVhZElmRmFsbGJhY2soKTt0aGlzLm1ldGE9YXx8e3NpemU6MH19fWxvY2soYSl7cmV0dXJuIHRoaXMuX3JlY29yZGluZ0xvY2t8fCh0aGlzLl9yZWNvcmRpbmdMb2NrPSEwKSx0aGlzLm9wcy5sb2NrKGEpPyhhPj1fZS5SRVNFUlZFRCYmKHRoaXMud3JpdGVMb2NrPSEwKSwhMCk6ITF9dW5sb2NrKGEpe3JldHVybiBhPT09MCYmKHRoaXMuX3JlY29yZGluZ0xvY2s9ITEpLHRoaXMud3JpdGVMb2NrJiYodGhpcy5mc3luYygpLHRoaXMud3JpdGVMb2NrPSExKSx0aGlzLm9wcy51bmxvY2soYSl9ZnN5bmMoKXtpZih0aGlzLmJ1ZmZlci5zaXplPjApe2xldCBhPXRoaXMuYnVmZmVyLmdldCgwKTtpZihhKXtsZXQgZj0kZShuZXcgVWludDhBcnJheShhLmRhdGEpKTtpZihmIT09dGhpcy5tZXRhLmJsb2NrU2l6ZSl7bGV0IHU9dGhpcy5idWZmZXI7dGhpcy5idWZmZXI9bmV3IE1hcDtsZXQgYz1bLi4udS52YWx1ZXMoKV0scD1jLmxlbmd0aCp0aGlzLm1ldGEuYmxvY2tTaXplLHk9bmV3IEFycmF5QnVmZmVyKHApLGs9bmV3IFVpbnQ4QXJyYXkoeSk7Zm9yKGxldCBzIG9mIGMpay5zZXQobmV3IFVpbnQ4QXJyYXkocy5kYXRhKSxzLnBvcyk7dGhpcy5idWZmZXJDaHVua3MoaHQoayxmLDAscCkpLHRoaXMuc2V0YXR0cih7YmxvY2tTaXplOmZ9KX19dGhpcy5vcHMud3JpdGVCbG9ja3MoWy4uLnRoaXMuYnVmZmVyLnZhbHVlcygpXSx0aGlzLm1ldGEuYmxvY2tTaXplKX10aGlzLl9tZXRhRGlydHkmJih0aGlzLm9wcy53cml0ZU1ldGEoe3NpemU6dGhpcy5tZXRhLnNpemV9KSx0aGlzLl9tZXRhRGlydHk9ITEpLHRoaXMuYnVmZmVyPW5ldyBNYXB9c2V0YXR0cihhKXt0aGlzLm1ldGE9PW51bGwmJih0aGlzLm1ldGE9e30pLGEubW9kZSE9PXZvaWQgMCYmKHRoaXMubWV0YS5tb2RlPWEubW9kZSksYS5ibG9ja1NpemUhPT12b2lkIDAmJih0aGlzLm1ldGEuYmxvY2tTaXplPWEuYmxvY2tTaXplKSxhLnNpemUhPT12b2lkIDAmJih0aGlzLm1ldGEuc2l6ZT1hLnNpemUsdGhpcy5fbWV0YURpcnR5PSEwKX1nZXRhdHRyKCl7cmV0dXJuIHRoaXMubWV0YX19bGV0IGR0PTM3MzU5Mjg1NTksUT0wLHVlPTE7Y2xhc3MgSnR7Y29uc3RydWN0b3IoYSx7aW5pdGlhbE9mZnNldDpmPTQsdXNlQXRvbWljczp1PSEwLHN0cmVhbTpjPSEwLGRlYnVnOnAsbmFtZTp5fT17fSl7dGhpcy5idWZmZXI9YSx0aGlzLmF0b21pY1ZpZXc9bmV3IEludDMyQXJyYXkoYSksdGhpcy5vZmZzZXQ9Zix0aGlzLnVzZUF0b21pY3M9dSx0aGlzLnN0cmVhbT1jLHRoaXMuZGVidWc9cCx0aGlzLm5hbWU9eX1sb2coLi4uYSl7dGhpcy5kZWJ1ZyYmY29uc29sZS5sb2coYFtyZWFkZXI6ICR7dGhpcy5uYW1lfV1gLC4uLmEpfXdhaXRXcml0ZShhLGY9bnVsbCl7aWYodGhpcy51c2VBdG9taWNzKXtmb3IodGhpcy5sb2coYHdhaXRpbmcgZm9yICR7YX1gKTtBdG9taWNzLmxvYWQodGhpcy5hdG9taWNWaWV3LDApPT09UTspe2lmKGYhPW51bGwmJkF0b21pY3Mud2FpdCh0aGlzLmF0b21pY1ZpZXcsMCxRLGYpPT09InRpbWVkLW91dCIpdGhyb3cgbmV3IEVycm9yKCJ0aW1lb3V0Iik7QXRvbWljcy53YWl0KHRoaXMuYXRvbWljVmlldywwLFEsNTAwKX10aGlzLmxvZyhgcmVzdW1lZCBmb3IgJHthfWApfWVsc2UgaWYodGhpcy5hdG9taWNWaWV3WzBdIT09dWUpdGhyb3cgbmV3IEVycm9yKCJgd2FpdFdyaXRlYCBleHBlY3RlZCBhcnJheSB0byBiZSByZWFkYWJsZSIpfWZsaXAoKXtpZih0aGlzLmxvZygiZmxpcCIpLHRoaXMudXNlQXRvbWljcyl7aWYoQXRvbWljcy5jb21wYXJlRXhjaGFuZ2UodGhpcy5hdG9taWNWaWV3LDAsdWUsUSkhPT11ZSl0aHJvdyBuZXcgRXJyb3IoIlJlYWQgZGF0YSBvdXQgb2Ygc3luYyEgVGhpcyBpcyBkaXNhc3Ryb3VzIik7QXRvbWljcy5ub3RpZnkodGhpcy5hdG9taWNWaWV3LDApfWVsc2UgdGhpcy5hdG9taWNWaWV3WzBdPVE7dGhpcy5vZmZzZXQ9NH1kb25lKCl7dGhpcy53YWl0V3JpdGUoImRvbmUiKTtsZXQgZj1uZXcgRGF0YVZpZXcodGhpcy5idWZmZXIsdGhpcy5vZmZzZXQpLmdldFVpbnQzMigwKT09PWR0O3JldHVybiBmJiYodGhpcy5sb2coImRvbmUiKSx0aGlzLmZsaXAoKSksZn1wZWVrKGEpe3RoaXMucGVla09mZnNldD10aGlzLm9mZnNldDtsZXQgZj1hKCk7cmV0dXJuIHRoaXMub2Zmc2V0PXRoaXMucGVla09mZnNldCx0aGlzLnBlZWtPZmZzZXQ9bnVsbCxmfXN0cmluZyhhKXt0aGlzLndhaXRXcml0ZSgic3RyaW5nIixhKTtsZXQgZj10aGlzLl9pbnQzMigpLHU9Zi8yLGM9bmV3IERhdGFWaWV3KHRoaXMuYnVmZmVyLHRoaXMub2Zmc2V0LGYpLHA9W107Zm9yKGxldCBrPTA7azx1O2srKylwLnB1c2goYy5nZXRVaW50MTYoayoyKSk7bGV0IHk9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLHApO3JldHVybiB0aGlzLmxvZygic3RyaW5nIix5KSx0aGlzLm9mZnNldCs9Zix0aGlzLnBlZWtPZmZzZXQ9PW51bGwmJnRoaXMuZmxpcCgpLHl9X2ludDMyKCl7bGV0IGE9NCx1PW5ldyBEYXRhVmlldyh0aGlzLmJ1ZmZlcix0aGlzLm9mZnNldCkuZ2V0SW50MzIoKTtyZXR1cm4gdGhpcy5sb2coIl9pbnQzMiIsdSksdGhpcy5vZmZzZXQrPWEsdX1pbnQzMigpe3RoaXMud2FpdFdyaXRlKCJpbnQzMiIpO2xldCBhPXRoaXMuX2ludDMyKCk7cmV0dXJuIHRoaXMubG9nKCJpbnQzMiIsYSksdGhpcy5wZWVrT2Zmc2V0PT1udWxsJiZ0aGlzLmZsaXAoKSxhfWJ5dGVzKCl7dGhpcy53YWl0V3JpdGUoImJ5dGVzIik7bGV0IGE9dGhpcy5faW50MzIoKSxmPW5ldyBBcnJheUJ1ZmZlcihhKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZikuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyLHRoaXMub2Zmc2V0LGEpKSx0aGlzLmxvZygiYnl0ZXMiLGYpLHRoaXMub2Zmc2V0Kz1hLHRoaXMucGVla09mZnNldD09bnVsbCYmdGhpcy5mbGlwKCksZn19Y2xhc3MgS3R7Y29uc3RydWN0b3IoYSx7aW5pdGlhbE9mZnNldDpmPTQsdXNlQXRvbWljczp1PSEwLHN0cmVhbTpjPSEwLGRlYnVnOnAsbmFtZTp5fT17fSl7dGhpcy5idWZmZXI9YSx0aGlzLmF0b21pY1ZpZXc9bmV3IEludDMyQXJyYXkoYSksdGhpcy5vZmZzZXQ9Zix0aGlzLnVzZUF0b21pY3M9dSx0aGlzLnN0cmVhbT1jLHRoaXMuZGVidWc9cCx0aGlzLm5hbWU9eSx0aGlzLnVzZUF0b21pY3M/QXRvbWljcy5zdG9yZSh0aGlzLmF0b21pY1ZpZXcsMCxRKTp0aGlzLmF0b21pY1ZpZXdbMF09UX1sb2coLi4uYSl7dGhpcy5kZWJ1ZyYmY29uc29sZS5sb2coYFt3cml0ZXI6ICR7dGhpcy5uYW1lfV1gLC4uLmEpfXdhaXRSZWFkKGEpe2lmKHRoaXMudXNlQXRvbWljcyl7aWYodGhpcy5sb2coYHdhaXRpbmcgZm9yICR7YX1gKSxBdG9taWNzLmNvbXBhcmVFeGNoYW5nZSh0aGlzLmF0b21pY1ZpZXcsMCxRLHVlKSE9PVEpdGhyb3cgbmV3IEVycm9yKCJXcm90ZSBzb21ldGhpbmcgaW50byB1bndyaXRhYmxlIGJ1ZmZlciEgVGhpcyBpcyBkaXNhc3Ryb3VzIik7Zm9yKEF0b21pY3Mubm90aWZ5KHRoaXMuYXRvbWljVmlldywwKTtBdG9taWNzLmxvYWQodGhpcy5hdG9taWNWaWV3LDApPT09dWU7KUF0b21pY3Mud2FpdCh0aGlzLmF0b21pY1ZpZXcsMCx1ZSw1MDApO3RoaXMubG9nKGByZXN1bWVkIGZvciAke2F9YCl9ZWxzZSB0aGlzLmF0b21pY1ZpZXdbMF09dWU7dGhpcy5vZmZzZXQ9NH1maW5hbGl6ZSgpe3RoaXMubG9nKCJmaW5hbGl6aW5nIiksbmV3IERhdGFWaWV3KHRoaXMuYnVmZmVyLHRoaXMub2Zmc2V0KS5zZXRVaW50MzIoMCxkdCksdGhpcy53YWl0UmVhZCgiZmluYWxpemUiKX1zdHJpbmcoYSl7dGhpcy5sb2coInN0cmluZyIsYSk7bGV0IGY9YS5sZW5ndGgqMjt0aGlzLl9pbnQzMihmKTtsZXQgdT1uZXcgRGF0YVZpZXcodGhpcy5idWZmZXIsdGhpcy5vZmZzZXQsZik7Zm9yKGxldCBjPTA7YzxhLmxlbmd0aDtjKyspdS5zZXRVaW50MTYoYyoyLGEuY2hhckNvZGVBdChjKSk7dGhpcy5vZmZzZXQrPWYsdGhpcy53YWl0UmVhZCgic3RyaW5nIil9X2ludDMyKGEpe2xldCBmPTQ7bmV3IERhdGFWaWV3KHRoaXMuYnVmZmVyLHRoaXMub2Zmc2V0KS5zZXRJbnQzMigwLGEpLHRoaXMub2Zmc2V0Kz1mfWludDMyKGEpe3RoaXMubG9nKCJpbnQzMiIsYSksdGhpcy5faW50MzIoYSksdGhpcy53YWl0UmVhZCgiaW50MzIiKX1ieXRlcyhhKXt0aGlzLmxvZygiYnl0ZXMiLGEpO2xldCBmPWEuYnl0ZUxlbmd0aDt0aGlzLl9pbnQzMihmKSxuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcix0aGlzLm9mZnNldCkuc2V0KG5ldyBVaW50OEFycmF5KGEpKSx0aGlzLm9mZnNldCs9Zix0aGlzLndhaXRSZWFkKCJieXRlcyIpfX1mdW5jdGlvbiBwdChFLGEpe3JldHVybiBNYXRoLnJvdW5kKEUvYSl9ZnVuY3Rpb24gWHQoRSxhKXtzZWxmLnBvc3RNZXNzYWdlKHt0eXBlOiJfX2Fic3VyZDpzcGF3bi1pZGItd29ya2VyIixhcmdCdWZmZXI6YS5idWZmZXIscmVzdWx0QnVmZmVyOkUuYnVmZmVyfSksc2VsZi5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixmPT57c3dpdGNoKGYuZGF0YS50eXBlKXtjYXNlIl9fcGVyZi1kZWV0czpzdGFydC1wcm9maWxlIjphLnN0cmluZygicHJvZmlsZS1zdGFydCIpLGEuZmluYWxpemUoKSxFLmludDMyKCksRS5kb25lKCk7YnJlYWs7Y2FzZSJfX3BlcmYtZGVldHM6c3RvcC1wcm9maWxlIjphLnN0cmluZygicHJvZmlsZS1zdG9wIiksYS5maW5hbGl6ZSgpLEUuaW50MzIoKSxFLmRvbmUoKTticmVha319KX1jbGFzcyBRdHtjb25zdHJ1Y3RvcihhKXt0aGlzLmZpbGVuYW1lPWF9Z2V0U3RvcmVOYW1lKCl7cmV0dXJuIHRoaXMuZmlsZW5hbWUucmVwbGFjZSgvXC8vZywiLSIpfWludm9rZVdvcmtlcihhLGYpe2lmKHRoaXMucmVhZGVyPT1udWxsfHx0aGlzLndyaXRlcj09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCAke2F9IG9uICR7dGhpcy5maWxlbmFtZX0gYnV0IGZpbGUgbm90IG9wZW5gKTtsZXQgdT10aGlzLnJlYWRlcixjPXRoaXMud3JpdGVyO3N3aXRjaChhKXtjYXNlInJlYWRCbG9ja3MiOntsZXR7bmFtZTpwLHBvc2l0aW9uczp5LGJsb2NrU2l6ZTprfT1mLHM9W107Zm9yKGxldCBNIG9mIHkpe2Muc3RyaW5nKCJyZWFkQmxvY2siKSxjLnN0cmluZyhwKSxjLmludDMyKHB0KE0saykpLGMuZmluYWxpemUoKTtsZXQgVz11LmJ5dGVzKCk7dS5kb25lKCkscy5wdXNoKHtwb3M6TSxkYXRhOlcuYnl0ZUxlbmd0aD09PTA/bmV3IEFycmF5QnVmZmVyKGspOld9KX1yZXR1cm4gc31jYXNlIndyaXRlQmxvY2tzIjp7bGV0e25hbWU6cCx3cml0ZXM6eSxibG9ja1NpemU6a309ZjtjLnN0cmluZygid3JpdGVCbG9ja3MiKSxjLnN0cmluZyhwKTtmb3IobGV0IE0gb2YgeSljLmludDMyKHB0KE0ucG9zLGspKSxjLmJ5dGVzKE0uZGF0YSk7Yy5maW5hbGl6ZSgpO2xldCBzPXUuaW50MzIoKTtyZXR1cm4gdS5kb25lKCksc31jYXNlInJlYWRNZXRhIjp7Yy5zdHJpbmcoInJlYWRNZXRhIiksYy5zdHJpbmcoZi5uYW1lKSxjLmZpbmFsaXplKCk7bGV0IHA9dS5pbnQzMigpLHk9dS5pbnQzMigpO3JldHVybiB1LmRvbmUoKSxwPT09LTE/bnVsbDp7c2l6ZTpwLGJsb2NrU2l6ZTp5fX1jYXNlIndyaXRlTWV0YSI6e2xldHtuYW1lOnAsbWV0YTp5fT1mO2Muc3RyaW5nKCJ3cml0ZU1ldGEiKSxjLnN0cmluZyhwKSxjLmludDMyKHkuc2l6ZSksYy5maW5hbGl6ZSgpO2xldCBrPXUuaW50MzIoKTtyZXR1cm4gdS5kb25lKCksa31jYXNlImNsb3NlRmlsZSI6e2Muc3RyaW5nKCJjbG9zZUZpbGUiKSxjLnN0cmluZyhmLm5hbWUpLGMuZmluYWxpemUoKTtsZXQgcD11LmludDMyKCk7cmV0dXJuIHUuZG9uZSgpLHB9Y2FzZSJsb2NrRmlsZSI6e2Muc3RyaW5nKCJsb2NrRmlsZSIpLGMuc3RyaW5nKGYubmFtZSksYy5pbnQzMihmLmxvY2tUeXBlKSxjLmZpbmFsaXplKCk7bGV0IHA9dS5pbnQzMigpO3JldHVybiB1LmRvbmUoKSxwPT09MH1jYXNlInVubG9ja0ZpbGUiOntjLnN0cmluZygidW5sb2NrRmlsZSIpLGMuc3RyaW5nKGYubmFtZSksYy5pbnQzMihmLmxvY2tUeXBlKSxjLmZpbmFsaXplKCk7bGV0IHA9dS5pbnQzMigpO3JldHVybiB1LmRvbmUoKSxwPT09MH19fWxvY2soYSl7cmV0dXJuIHRoaXMuaW52b2tlV29ya2VyKCJsb2NrRmlsZSIse25hbWU6dGhpcy5nZXRTdG9yZU5hbWUoKSxsb2NrVHlwZTphfSl9dW5sb2NrKGEpe3JldHVybiB0aGlzLmludm9rZVdvcmtlcigidW5sb2NrRmlsZSIse25hbWU6dGhpcy5nZXRTdG9yZU5hbWUoKSxsb2NrVHlwZTphfSl9ZGVsZXRlKCl7KHRoaXMucmVhZGVyfHx0aGlzLndyaXRlcikmJnRoaXMuY2xvc2UoKTtsZXQgYT1nbG9iYWxUaGlzLmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZSh0aGlzLmdldFN0b3JlTmFtZSgpKTthLm9uZXJyb3I9KCk9Pntjb25zb2xlLndhcm4oYERlbGV0aW5nICR7dGhpcy5maWxlbmFtZX0gZGF0YWJhc2UgZmFpbGVkYCl9LGEub25zdWNjZXNzPSgpPT57fX1vcGVuKCl7bGV0IGE9bmV3IFNoYXJlZEFycmF5QnVmZmVyKDM2ODY0KTt0aGlzLndyaXRlcj1uZXcgS3QoYSx7bmFtZToiYXJncyAoYmFja2VuZCkiLGRlYnVnOiExfSk7bGV0IGY9bmV3IFNoYXJlZEFycmF5QnVmZmVyKDQwOTYqOSk7dGhpcy5yZWFkZXI9bmV3IEp0KGYse25hbWU6InJlc3VsdHMiLGRlYnVnOiExfSksWHQodGhpcy5yZWFkZXIsdGhpcy53cml0ZXIpfWNsb3NlKCl7dGhpcy5pbnZva2VXb3JrZXIoImNsb3NlRmlsZSIse25hbWU6dGhpcy5nZXRTdG9yZU5hbWUoKX0pLHRoaXMucmVhZGVyPW51bGwsdGhpcy53cml0ZXI9bnVsbCx0aGlzLndvcmtlcj1udWxsfXJlYWRNZXRhKCl7cmV0dXJuIHRoaXMuaW52b2tlV29ya2VyKCJyZWFkTWV0YSIse25hbWU6dGhpcy5nZXRTdG9yZU5hbWUoKX0pfXdyaXRlTWV0YShhKXtyZXR1cm4gdGhpcy5pbnZva2VXb3JrZXIoIndyaXRlTWV0YSIse25hbWU6dGhpcy5nZXRTdG9yZU5hbWUoKSxtZXRhOmF9KX1yZWFkQmxvY2tzKGEsZil7cmV0dXJuIHRoaXMuc3RhdHMmJih0aGlzLnN0YXRzLnJlYWQrPWEubGVuZ3RoKSx0aGlzLmludm9rZVdvcmtlcigicmVhZEJsb2NrcyIse25hbWU6dGhpcy5nZXRTdG9yZU5hbWUoKSxwb3NpdGlvbnM6YSxibG9ja1NpemU6Zn0pfXdyaXRlQmxvY2tzKGEsZil7cmV0dXJuIHRoaXMuc3RhdHMmJih0aGlzLnN0YXRzLndyaXRlcys9YS5sZW5ndGgpLHRoaXMuaW52b2tlV29ya2VyKCJ3cml0ZUJsb2NrcyIse25hbWU6dGhpcy5nZXRTdG9yZU5hbWUoKSx3cml0ZXM6YSxibG9ja1NpemU6Zn0pfX1mdW5jdGlvbiBZdCgpe2lmKCEoIW5hdmlnYXRvci51c2VyQWdlbnREYXRhJiYvU2FmYXJpXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkmJiEvQ2hyb20oZXxpdW0pXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpfHwhaW5kZXhlZERCLmRhdGFiYXNlcylyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7bGV0IGE7cmV0dXJuIG5ldyBQcm9taXNlKGY9Pntjb25zdCB1PSgpPT5pbmRleGVkREIuZGF0YWJhc2VzKCkuZmluYWxseShmKTthPXNldEludGVydmFsKHUsMTAwKSx1KCl9KS5maW5hbGx5KCgpPT5jbGVhckludGVydmFsKGEpKX1mdW5jdGlvbiBtdChFLGEpe3JldHVybiBNYXRoLnJvdW5kKEUvYSl9YXN5bmMgZnVuY3Rpb24gWnQoRSl7cmV0dXJuIGF3YWl0IFl0KCksbmV3IFByb21pc2UoKGEsZik9PntsZXQgdT1nbG9iYWxUaGlzLmluZGV4ZWREQi5vcGVuKEUsMik7dS5vbnN1Y2Nlc3M9Yz0+e2xldCBwPWMudGFyZ2V0LnJlc3VsdDtwLm9udmVyc2lvbmNoYW5nZT0oKT0+e2NvbnNvbGUubG9nKCJjbG9zaW5nIGJlY2F1c2UgdmVyc2lvbiBjaGFuZ2VkIikscC5jbG9zZSgpfSxwLm9uY2xvc2U9KCk9Pnt9LGEocCl9LHUub251cGdyYWRlbmVlZGVkPWM9PntsZXQgcD1jLnRhcmdldC5yZXN1bHQ7cC5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCJkYXRhIil8fHAuY3JlYXRlT2JqZWN0U3RvcmUoImRhdGEiKX0sdS5vbmJsb2NrZWQ9Yz0+Y29uc29sZS5sb2coImJsb2NrZWQiLGMpLHUub25lcnJvcj11Lm9uYWJvcnQ9Yz0+ZihjLnRhcmdldC5lcnJvcil9KX1jbGFzcyBHdHtjb25zdHJ1Y3RvcihhLGYpe3RoaXMuZGJOYW1lPWEsdGhpcy5fb3BlbkRiUHJvbWlzZT1udWxsLHRoaXMuaGFzQWxlcnRlZEZhaWx1cmU9ITEsdGhpcy5vbkZhbGxiYWNrRmFpbHVyZT1mfWdldERiKCl7cmV0dXJuIHRoaXMuX29wZW5EYlByb21pc2U/dGhpcy5fb3BlbkRiUHJvbWlzZToodGhpcy5fb3BlbkRiUHJvbWlzZT1adCh0aGlzLmRiTmFtZSksdGhpcy5fb3BlbkRiUHJvbWlzZSl9Y2xvc2VEYigpe3RoaXMuX29wZW5EYlByb21pc2UmJih0aGlzLl9vcGVuRGJQcm9taXNlLnRoZW4oYT0+YS5jbG9zZSgpKSx0aGlzLl9vcGVuRGJQcm9taXNlPW51bGwpfWFzeW5jIHJlYWRBbGwoKXtsZXQgYT1hd2FpdCB0aGlzLmdldERiKHRoaXMuZGJOYW1lKSxmPW5ldyBNYXAsYz1hLnRyYW5zYWN0aW9uKFsiZGF0YSJdLCJyZWFkb25seSIpLm9iamVjdFN0b3JlKCJkYXRhIik7cmV0dXJuIG5ldyBQcm9taXNlKChwLHkpPT57bGV0IGs9Yy5vcGVuQ3Vyc29yKElEQktleVJhbmdlLmxvd2VyQm91bmQoLTEpKTtrLm9uZXJyb3I9eSxrLm9uc3VjY2Vzcz1zPT57bGV0IE09cy50YXJnZXQucmVzdWx0O00/KGYuc2V0KE0ua2V5LE0udmFsdWUpLE0uY29udGludWUoKSk6cChmKX19KX1hc3luYyB3cml0ZShhLGYsdSl7bGV0IHA9KGF3YWl0IHRoaXMuZ2V0RGIodGhpcy5kYk5hbWUpKS50cmFuc2FjdGlvbihbImRhdGEiXSwicmVhZHdyaXRlIikseT1wLm9iamVjdFN0b3JlKCJkYXRhIik7YXdhaXQgbmV3IFByb21pc2UoKGsscyk9PntsZXQgTT15LmdldCgwKTtNLm9uc3VjY2Vzcz1XPT57aWYodSYmIVZ0KE0ucmVzdWx0LGYpKXt0aGlzLm9uRmFsbGJhY2tGYWlsdXJlJiYhdGhpcy5oYXNBbGVydGVkRmFpbHVyZSYmKHRoaXMuaGFzQWxlcnRlZEZhaWx1cmU9ITAsdGhpcy5vbkZhbGxiYWNrRmFpbHVyZSgpKSxzKG5ldyBFcnJvcigiRmFsbGJhY2sgbW9kZSB1bmFibGUgdG8gd3JpdGUgZmlsZSBjaGFuZ2VzIikpO3JldHVybn1mb3IobGV0IEkgb2YgYSl5LnB1dChJLnZhbHVlLEkua2V5KTtwLm9uc3VjY2Vzcz0oKT0+aygpLHAub25lcnJvcj0oKT0+cygpfSxNLm9uZXJyb3I9c30pfX1jbGFzcyBlcntjb25zdHJ1Y3RvcihhLGYpe3RoaXMuZmlsZW5hbWU9YSx0aGlzLmRiTmFtZT10aGlzLmZpbGVuYW1lLnJlcGxhY2UoL1wvL2csIi0iKSx0aGlzLmNhY2hlZEZpcnN0QmxvY2s9bnVsbCx0aGlzLndyaXRlUXVldWU9bnVsbCx0aGlzLmJsb2Nrcz1uZXcgTWFwLHRoaXMubG9ja1R5cGU9MCx0aGlzLnRyYW5zZmVyQmxvY2tPd25lcnNoaXA9ITEsdGhpcy5wZXJzaXN0YW5jZT1uZXcgR3QodGhpcy5kYk5hbWUsZil9YXN5bmMgcmVhZElmRmFsbGJhY2soKXtyZXR1cm4gdGhpcy50cmFuc2ZlckJsb2NrT3duZXJzaGlwPSEwLHRoaXMuYmxvY2tzPWF3YWl0IHRoaXMucGVyc2lzdGFuY2UucmVhZEFsbCgpLHRoaXMucmVhZE1ldGEoKX1sb2NrKGEpe3JldHVybiB0aGlzLmNhY2hlZEZpcnN0QmxvY2s9dGhpcy5ibG9ja3MuZ2V0KDApLHRoaXMubG9ja1R5cGU9YSwhMH11bmxvY2soYSl7cmV0dXJuIHRoaXMubG9ja1R5cGU+X2UuU0hBUkVEJiZhPT09X2UuU0hBUkVEJiZ0aGlzLmZsdXNoKCksdGhpcy5sb2NrVHlwZT1hLCEwfWRlbGV0ZSgpe2xldCBhPWdsb2JhbFRoaXMuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKHRoaXMuZGJOYW1lKTthLm9uZXJyb3I9KCk9Pntjb25zb2xlLndhcm4oYERlbGV0aW5nICR7dGhpcy5maWxlbmFtZX0gZGF0YWJhc2UgZmFpbGVkYCl9LGEub25zdWNjZXNzPSgpPT57fX1vcGVuKCl7dGhpcy53cml0ZVF1ZXVlPVtdLHRoaXMubG9ja1R5cGU9MH1jbG9zZSgpe3RoaXMuZmx1c2goKSx0aGlzLnRyYW5zZmVyQmxvY2tPd25lcnNoaXA/dGhpcy50cmFuc2ZlckJsb2NrT3duZXJzaGlwPSExOnRoaXMuYmxvY2tzPW5ldyBNYXAsdGhpcy5wZXJzaXN0YW5jZS5jbG9zZURiKCl9cmVhZE1ldGEoKXtsZXQgYT10aGlzLmJsb2Nrcy5nZXQoLTEpO2lmKGEpe2xldCBmPXRoaXMuYmxvY2tzLmdldCgwKTtyZXR1cm57c2l6ZTphLnNpemUsYmxvY2tTaXplOiRlKG5ldyBVaW50OEFycmF5KGYpKX19cmV0dXJuIG51bGx9d3JpdGVNZXRhKGEpe3RoaXMuYmxvY2tzLnNldCgtMSxhKSx0aGlzLnF1ZXVlV3JpdGUoLTEsYSl9cmVhZEJsb2NrcyhhLGYpe2xldCB1PVtdO2ZvcihsZXQgYyBvZiBhKXUucHVzaCh7cG9zOmMsZGF0YTp0aGlzLmJsb2Nrcy5nZXQobXQoYyxmKSl9KTtyZXR1cm4gdX13cml0ZUJsb2NrcyhhLGYpe2ZvcihsZXQgdSBvZiBhKXtsZXQgYz1tdCh1LnBvcyxmKTt0aGlzLmJsb2Nrcy5zZXQoYyx1LmRhdGEpLHRoaXMucXVldWVXcml0ZShjLHUuZGF0YSl9dGhpcy5sb2NrVHlwZTw9X2UuU0hBUkVEJiZ0aGlzLmZsdXNoKCl9cXVldWVXcml0ZShhLGYpe3RoaXMud3JpdGVRdWV1ZS5wdXNoKHtrZXk6YSx2YWx1ZTpmfSl9Zmx1c2goKXt0aGlzLndyaXRlUXVldWUubGVuZ3RoPjAmJih0aGlzLnBlcnNpc3RhbmNlLndyaXRlKHRoaXMud3JpdGVRdWV1ZSx0aGlzLmNhY2hlZEZpcnN0QmxvY2ssdGhpcy5sb2NrVHlwZT5fZS5TSEFSRUQpLHRoaXMud3JpdGVRdWV1ZT1bXSksdGhpcy5jYWNoZWRGaXJzdEJsb2NrPW51bGx9fWNsYXNzIHRye2NvbnN0cnVjdG9yKGEpe3RoaXMub25GYWxsYmFja0ZhaWx1cmU9YX1jcmVhdGVGaWxlKGEpe2xldCBmO3R5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciE9InVuZGVmaW5lZCI/Zj1uZXcgUXQoYSk6Zj1uZXcgZXIoYSx0aGlzLm9uRmFsbGJhY2tGYWlsdXJlKTtsZXQgdT1uZXcgJHQoYSxmKTtyZXR1cm57fS5QRVJGX0JVSUxEJiYodGhpcy5fZmlsZXM9PW51bGwmJih0aGlzLl9maWxlcz1uZXcgU2V0KSx0aGlzLl9maWxlcy5hZGQodSkpLHV9c3RhcnRQcm9maWxlKCl7Zm9yKGxldCBhIG9mIHRoaXMuX2ZpbGVzKWlmKGEub3BzLndyaXRlcil7bGV0IGY9YS5vcHMud3JpdGVyLHU9YS5vcHMucmVhZGVyO2Yuc3RyaW5nKCJwcm9maWxlLXN0YXJ0IiksZi5maW5hbGl6ZSgpLHUuaW50MzIoKSx1LmRvbmUoKX19c3RvcFByb2ZpbGUoKXtmb3IobGV0IGEgb2YgdGhpcy5fZmlsZXMpaWYoYS5vcHMud3JpdGVyKXtsZXQgZj1hLm9wcy53cml0ZXIsdT1hLm9wcy5yZWFkZXI7Zi5zdHJpbmcoInByb2ZpbGUtc3RvcCIpLGYuZmluYWxpemUoKSx1LmludDMyKCksdS5kb25lKCl9fX1mdW5jdGlvbiBycihFKXtpZihFLl9fZXNNb2R1bGUpcmV0dXJuIEU7dmFyIGE9T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTtyZXR1cm4gT2JqZWN0LmtleXMoRSkuZm9yRWFjaChmdW5jdGlvbihmKXt2YXIgdT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEUsZik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsZix1LmdldD91OntlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBFW2ZdfX0pfSksYX12YXIgd3Q9e2V4cG9ydHM6e319LG5yPXt9LGlyPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGRlZmF1bHQ6bnJ9KSxKZT1ycihpcik7KGZ1bmN0aW9uKEUsYSl7dmFyIGY9dm9pZCAwLHU9ZnVuY3Rpb24oYyl7cmV0dXJuIGZ8fChmPW5ldyBQcm9taXNlKGZ1bmN0aW9uKHAseSl7dmFyIHM9dHlwZW9mIGMhPSJ1bmRlZmluZWQiP2M6e30saz1zLm9uQWJvcnQ7cy5vbkFib3J0PWZ1bmN0aW9uKGUpe3kobmV3IEVycm9yKGUpKSxrJiZrKGUpfSxzLnBvc3RSdW49cy5wb3N0UnVufHxbXSxzLnBvc3RSdW4ucHVzaChmdW5jdGlvbigpe3Aocyl9KSxFPXZvaWQgMDt2YXIgcztzfHwocz10eXBlb2YgcyE9InVuZGVmaW5lZCI/czp7fSkscy5vblJ1bnRpbWVJbml0aWFsaXplZD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaCxiKXt0aGlzLkxhPWgsdGhpcy5kYj1iLHRoaXMuS2E9MSx0aGlzLnFiPVtdfWZ1bmN0aW9uIHQoaCxiKXtpZih0aGlzLmRiPWIsYj1mZShoKSsxLHRoaXMuYWI9amUoYiksdGhpcy5hYj09PW51bGwpdGhyb3cgRXJyb3IoIlVuYWJsZSB0byBhbGxvY2F0ZSBtZW1vcnkgZm9yIHRoZSBTUUwgc3RyaW5nIik7cmUoaCxLLHRoaXMuYWIsYiksdGhpcy5tYj10aGlzLmFiLHRoaXMuWWE9dGhpcy5HYj1udWxsfWZ1bmN0aW9uIHIoaCx7ZmlsZW5hbWU6Yj0hMX09e30pe2I9PT0hMT8odGhpcy5maWxlbmFtZT0iZGJmaWxlXyIrKDQyOTQ5NjcyOTUqTWF0aC5yYW5kb20oKT4+PjApLHRoaXMuTmM9ITAsaCE9bnVsbCYmbi50YigiLyIsdGhpcy5maWxlbmFtZSxoLCEwLCEwKSk6dGhpcy5maWxlbmFtZT1oLHRoaXMuaGFuZGxlRXJyb3IobCh0aGlzLmZpbGVuYW1lLGkpKSx0aGlzLmRiPUcoaSwiaTMyIiksV3IodGhpcy5kYiksdGhpcy5nYj17fSx0aGlzLlJhPXt9fXZhciBpPW9lKDQpLG89cy5jd3JhcCxsPW8oInNxbGl0ZTNfb3BlbiIsIm51bWJlciIsWyJzdHJpbmciLCJudW1iZXIiXSksZD1vKCJzcWxpdGUzX2Nsb3NlX3YyIiwibnVtYmVyIixbIm51bWJlciJdKSxtPW8oInNxbGl0ZTNfZXhlYyIsIm51bWJlciIsWyJudW1iZXIiLCJzdHJpbmciLCJudW1iZXIiLCJudW1iZXIiLCJudW1iZXIiXSksZz1vKCJzcWxpdGUzX2NoYW5nZXMiLCJudW1iZXIiLFsibnVtYmVyIl0pLHc9bygic3FsaXRlM19wcmVwYXJlX3YyIiwibnVtYmVyIixbIm51bWJlciIsInN0cmluZyIsIm51bWJlciIsIm51bWJlciIsIm51bWJlciJdKSxfPW8oInNxbGl0ZTNfc3FsIiwic3RyaW5nIixbIm51bWJlciJdKSxEPW8oInNxbGl0ZTNfbm9ybWFsaXplZF9zcWwiLCJzdHJpbmciLFsibnVtYmVyIl0pLE49bygic3FsaXRlM19wcmVwYXJlX3YyIiwibnVtYmVyIixbIm51bWJlciIsIm51bWJlciIsIm51bWJlciIsIm51bWJlciIsIm51bWJlciJdKSxUPW8oInNxbGl0ZTNfYmluZF90ZXh0IiwibnVtYmVyIixbIm51bWJlciIsIm51bWJlciIsIm51bWJlciIsIm51bWJlciIsIm51bWJlciJdKSxQPW8oInNxbGl0ZTNfYmluZF9ibG9iIiwibnVtYmVyIixbIm51bWJlciIsIm51bWJlciIsIm51bWJlciIsIm51bWJlciIsIm51bWJlciJdKSxzZT1vKCJzcWxpdGUzX2JpbmRfZG91YmxlIiwibnVtYmVyIixbIm51bWJlciIsIm51bWJlciIsIm51bWJlciJdKSxwZT1vKCJzcWxpdGUzX2JpbmRfaW50IiwibnVtYmVyIixbIm51bWJlciIsIm51bWJlciIsIm51bWJlciJdKSxhZT1vKCJzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4IiwibnVtYmVyIixbIm51bWJlciIsInN0cmluZyJdKSxsdD1vKCJzcWxpdGUzX3N0ZXAiLCJudW1iZXIiLFsibnVtYmVyIl0pLFU9bygic3FsaXRlM19lcnJtc2ciLCJzdHJpbmciLFsibnVtYmVyIl0pLF9yPW8oInNxbGl0ZTNfY29sdW1uX2NvdW50IiwibnVtYmVyIixbIm51bWJlciJdKSxncj1vKCJzcWxpdGUzX2RhdGFfY291bnQiLCJudW1iZXIiLFsibnVtYmVyIl0pLEVyPW8oInNxbGl0ZTNfY29sdW1uX2RvdWJsZSIsIm51bWJlciIsWyJudW1iZXIiLCJudW1iZXIiXSksdnI9bygic3FsaXRlM19jb2x1bW5fdGV4dCIsInN0cmluZyIsWyJudW1iZXIiLCJudW1iZXIiXSksa3I9bygic3FsaXRlM19jb2x1bW5fYmxvYiIsIm51bWJlciIsWyJudW1iZXIiLCJudW1iZXIiXSksQXI9bygic3FsaXRlM19jb2x1bW5fYnl0ZXMiLCJudW1iZXIiLFsibnVtYmVyIiwibnVtYmVyIl0pLHFyPW8oInNxbGl0ZTNfY29sdW1uX3R5cGUiLCJudW1iZXIiLFsibnVtYmVyIiwibnVtYmVyIl0pLFNyPW8oInNxbGl0ZTNfY29sdW1uX25hbWUiLCJzdHJpbmciLFsibnVtYmVyIiwibnVtYmVyIl0pLERyPW8oInNxbGl0ZTNfcmVzZXQiLCJudW1iZXIiLFsibnVtYmVyIl0pLE1yPW8oInNxbGl0ZTNfY2xlYXJfYmluZGluZ3MiLCJudW1iZXIiLFsibnVtYmVyIl0pLElyPW8oInNxbGl0ZTNfZmluYWxpemUiLCJudW1iZXIiLFsibnVtYmVyIl0pLEZyPW8oInNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyIiwibnVtYmVyIiwibnVtYmVyIHN0cmluZyBudW1iZXIgbnVtYmVyIG51bWJlciBudW1iZXIgbnVtYmVyIG51bWJlciBudW1iZXIiLnNwbGl0KCIgIikpLHpyPW8oInNxbGl0ZTNfdmFsdWVfdHlwZSIsIm51bWJlciIsWyJudW1iZXIiXSksUnI9bygic3FsaXRlM192YWx1ZV9ieXRlcyIsIm51bWJlciIsWyJudW1iZXIiXSksTnI9bygic3FsaXRlM192YWx1ZV90ZXh0Iiwic3RyaW5nIixbIm51bWJlciJdKSxQcj1vKCJzcWxpdGUzX3ZhbHVlX2Jsb2IiLCJudW1iZXIiLFsibnVtYmVyIl0pLExyPW8oInNxbGl0ZTNfdmFsdWVfZG91YmxlIiwibnVtYmVyIixbIm51bWJlciJdKSxCcj1vKCJzcWxpdGUzX3Jlc3VsdF9kb3VibGUiLCIiLFsibnVtYmVyIiwibnVtYmVyIl0pLHh0PW8oInNxbGl0ZTNfcmVzdWx0X251bGwiLCIiLFsibnVtYmVyIl0pLFRyPW8oInNxbGl0ZTNfcmVzdWx0X3RleHQiLCIiLFsibnVtYmVyIiwic3RyaW5nIiwibnVtYmVyIiwibnVtYmVyIl0pLHhyPW8oInNxbGl0ZTNfcmVzdWx0X2Jsb2IiLCIiLFsibnVtYmVyIiwibnVtYmVyIiwibnVtYmVyIiwibnVtYmVyIl0pLFVyPW8oInNxbGl0ZTNfcmVzdWx0X2ludCIsIiIsWyJudW1iZXIiLCJudW1iZXIiXSksVXQ9bygic3FsaXRlM19yZXN1bHRfZXJyb3IiLCIiLFsibnVtYmVyIiwic3RyaW5nIiwibnVtYmVyIl0pLFdyPW8oIlJlZ2lzdGVyRXh0ZW5zaW9uRnVuY3Rpb25zIiwibnVtYmVyIixbIm51bWJlciJdKTtlLnByb3RvdHlwZS5iaW5kPWZ1bmN0aW9uKGgpe2lmKCF0aGlzLkxhKXRocm93IlN0YXRlbWVudCBjbG9zZWQiO3JldHVybiB0aGlzLnJlc2V0KCksQXJyYXkuaXNBcnJheShoKT90aGlzLm5jKGgpOmghPW51bGwmJnR5cGVvZiBoPT0ib2JqZWN0Ij90aGlzLm9jKGgpOiEwfSxlLnByb3RvdHlwZS5zdGVwPWZ1bmN0aW9uKCl7aWYoIXRoaXMuTGEpdGhyb3ciU3RhdGVtZW50IGNsb3NlZCI7dGhpcy5LYT0xO3ZhciBoPWx0KHRoaXMuTGEpO3N3aXRjaChoKXtjYXNlIDEwMDpyZXR1cm4hMDtjYXNlIDEwMTpyZXR1cm4hMTtkZWZhdWx0OnRocm93IHRoaXMuZGIuaGFuZGxlRXJyb3IoaCl9fSxlLnByb3RvdHlwZS5IYz1mdW5jdGlvbihoKXtyZXR1cm4gaD09bnVsbCYmKGg9dGhpcy5LYSx0aGlzLkthKz0xKSxFcih0aGlzLkxhLGgpfSxlLnByb3RvdHlwZS5JYz1mdW5jdGlvbihoKXtyZXR1cm4gaD09bnVsbCYmKGg9dGhpcy5LYSx0aGlzLkthKz0xKSx2cih0aGlzLkxhLGgpfSxlLnByb3RvdHlwZS5nZXRCbG9iPWZ1bmN0aW9uKGgpe2g9PW51bGwmJihoPXRoaXMuS2EsdGhpcy5LYSs9MSk7dmFyIGI9QXIodGhpcy5MYSxoKTtoPWtyKHRoaXMuTGEsaCk7Zm9yKHZhciBBPW5ldyBVaW50OEFycmF5KGIpLFM9MDtTPGI7Uys9MSlBW1NdPUJbaCtTXTtyZXR1cm4gQX0sZS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGgpe2ghPW51bGwmJnRoaXMuYmluZChoKSYmdGhpcy5zdGVwKCksaD1bXTtmb3IodmFyIGI9Z3IodGhpcy5MYSksQT0wO0E8YjtBKz0xKXN3aXRjaChxcih0aGlzLkxhLEEpKXtjYXNlIDE6Y2FzZSAyOmgucHVzaCh0aGlzLkhjKEEpKTticmVhaztjYXNlIDM6aC5wdXNoKHRoaXMuSWMoQSkpO2JyZWFrO2Nhc2UgNDpoLnB1c2godGhpcy5nZXRCbG9iKEEpKTticmVhaztkZWZhdWx0OmgucHVzaChudWxsKX1yZXR1cm4gaH0sZS5wcm90b3R5cGUuZ2V0Q29sdW1uTmFtZXM9ZnVuY3Rpb24oKXtmb3IodmFyIGg9W10sYj1fcih0aGlzLkxhKSxBPTA7QTxiO0ErPTEpaC5wdXNoKFNyKHRoaXMuTGEsQSkpO3JldHVybiBofSxlLnByb3RvdHlwZS5nZXRBc09iamVjdD1mdW5jdGlvbihoKXtoPXRoaXMuZ2V0KGgpO2Zvcih2YXIgYj10aGlzLmdldENvbHVtbk5hbWVzKCksQT17fSxTPTA7UzxiLmxlbmd0aDtTKz0xKUFbYltTXV09aFtTXTtyZXR1cm4gQX0sZS5wcm90b3R5cGUuZ2V0U1FMPWZ1bmN0aW9uKCl7cmV0dXJuIF8odGhpcy5MYSl9LGUucHJvdG90eXBlLmdldE5vcm1hbGl6ZWRTUUw9ZnVuY3Rpb24oKXtyZXR1cm4gRCh0aGlzLkxhKX0sZS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKGgpe3JldHVybiBoIT1udWxsJiZ0aGlzLmJpbmQoaCksdGhpcy5zdGVwKCksdGhpcy5yZXNldCgpfSxlLnByb3RvdHlwZS5yYz1mdW5jdGlvbihoLGIpe2I9PW51bGwmJihiPXRoaXMuS2EsdGhpcy5LYSs9MSksaD1PZShoKTt2YXIgQT1aZShoKTt0aGlzLnFiLnB1c2goQSksdGhpcy5kYi5oYW5kbGVFcnJvcihUKHRoaXMuTGEsYixBLGgubGVuZ3RoLTEsMCkpfSxlLnByb3RvdHlwZS5tYz1mdW5jdGlvbihoLGIpe2I9PW51bGwmJihiPXRoaXMuS2EsdGhpcy5LYSs9MSk7dmFyIEE9WmUoaCk7dGhpcy5xYi5wdXNoKEEpLHRoaXMuZGIuaGFuZGxlRXJyb3IoUCh0aGlzLkxhLGIsQSxoLmxlbmd0aCwwKSl9LGUucHJvdG90eXBlLnFjPWZ1bmN0aW9uKGgsYil7Yj09bnVsbCYmKGI9dGhpcy5LYSx0aGlzLkthKz0xKSx0aGlzLmRiLmhhbmRsZUVycm9yKChoPT09KGh8MCk/cGU6c2UpKHRoaXMuTGEsYixoKSl9LGUucHJvdG90eXBlLnBjPWZ1bmN0aW9uKGgpe2g9PW51bGwmJihoPXRoaXMuS2EsdGhpcy5LYSs9MSksUCh0aGlzLkxhLGgsMCwwLDApfSxlLnByb3RvdHlwZS5OYj1mdW5jdGlvbihoLGIpe3N3aXRjaChiPT1udWxsJiYoYj10aGlzLkthLHRoaXMuS2ErPTEpLHR5cGVvZiBoKXtjYXNlInN0cmluZyI6dGhpcy5yYyhoLGIpO3JldHVybjtjYXNlIm51bWJlciI6Y2FzZSJib29sZWFuIjp0aGlzLnFjKGgrMCxiKTtyZXR1cm47Y2FzZSJvYmplY3QiOmlmKGg9PT1udWxsKXt0aGlzLnBjKGIpO3JldHVybn1pZihoLmxlbmd0aCE9bnVsbCl7dGhpcy5tYyhoLGIpO3JldHVybn19dGhyb3ciV3JvbmcgQVBJIHVzZSA6IHRyaWVkIHRvIGJpbmQgYSB2YWx1ZSBvZiBhbiB1bmtub3duIHR5cGUgKCIraCsiKS4ifSxlLnByb3RvdHlwZS5vYz1mdW5jdGlvbihoKXt2YXIgYj10aGlzO3JldHVybiBPYmplY3Qua2V5cyhoKS5mb3JFYWNoKGZ1bmN0aW9uKEEpe3ZhciBTPWFlKGIuTGEsQSk7UyE9PTAmJmIuTmIoaFtBXSxTKX0pLCEwfSxlLnByb3RvdHlwZS5uYz1mdW5jdGlvbihoKXtmb3IodmFyIGI9MDtiPGgubGVuZ3RoO2IrPTEpdGhpcy5OYihoW2JdLGIrMSk7cmV0dXJuITB9LGUucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIE1yKHRoaXMuTGEpPT09MCYmRHIodGhpcy5MYSk9PT0wfSxlLnByb3RvdHlwZS5mcmVlbWVtPWZ1bmN0aW9uKCl7Zm9yKHZhciBoOyhoPXRoaXMucWIucG9wKCkpIT09dm9pZCAwOylWZShoKX0sZS5wcm90b3R5cGUuZnJlZT1mdW5jdGlvbigpe3ZhciBoPUlyKHRoaXMuTGEpPT09MDtyZXR1cm4gZGVsZXRlIHRoaXMuZGIuZ2JbdGhpcy5MYV0sdGhpcy5MYT0wLGh9LHQucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtpZih0aGlzLmFiPT09bnVsbClyZXR1cm57ZG9uZTohMH07aWYodGhpcy5ZYSE9PW51bGwmJih0aGlzLllhLmZyZWUoKSx0aGlzLllhPW51bGwpLCF0aGlzLmRiLmRiKXRocm93IHRoaXMudmIoKSxFcnJvcigiRGF0YWJhc2UgY2xvc2VkIik7dmFyIGg9U2UoKSxiPW9lKDQpO3FlKGkpLHFlKGIpO3RyeXt0aGlzLmRiLmhhbmRsZUVycm9yKE4odGhpcy5kYi5kYix0aGlzLm1iLC0xLGksYikpLHRoaXMubWI9RyhiLCJpMzIiKTt2YXIgQT1HKGksImkzMiIpO3JldHVybiBBPT09MD8odGhpcy52YigpLHtkb25lOiEwfSk6KHRoaXMuWWE9bmV3IGUoQSx0aGlzLmRiKSx0aGlzLmRiLmdiW0FdPXRoaXMuWWEse3ZhbHVlOnRoaXMuWWEsZG9uZTohMX0pfWNhdGNoKFMpe3Rocm93IHRoaXMuR2I9TCh0aGlzLm1iKSx0aGlzLnZiKCksU31maW5hbGx5e0RlKGgpfX0sdC5wcm90b3R5cGUudmI9ZnVuY3Rpb24oKXtWZSh0aGlzLmFiKSx0aGlzLmFiPW51bGx9LHQucHJvdG90eXBlLmdldFJlbWFpbmluZ1NRTD1mdW5jdGlvbigpe3JldHVybiB0aGlzLkdiIT09bnVsbD90aGlzLkdiOkwodGhpcy5tYil9LHR5cGVvZiBTeW1ib2w9PSJmdW5jdGlvbiImJnR5cGVvZiBTeW1ib2wuaXRlcmF0b3I9PSJzeW1ib2wiJiYodC5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSksci5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKGgsYil7aWYoIXRoaXMuZGIpdGhyb3ciRGF0YWJhc2UgY2xvc2VkIjtpZihiKXtoPXRoaXMucHJlcGFyZShoLGIpO3RyeXtoLnN0ZXAoKX1maW5hbGx5e2guZnJlZSgpfX1lbHNlIHRoaXMuaGFuZGxlRXJyb3IobSh0aGlzLmRiLGgsMCwwLGkpKTtyZXR1cm4gdGhpc30sci5wcm90b3R5cGUuZXhlYz1mdW5jdGlvbihoLGIpe2lmKCF0aGlzLmRiKXRocm93IkRhdGFiYXNlIGNsb3NlZCI7dmFyIEE9U2UoKSxTPW51bGw7dHJ5e3ZhciB6PWZlKGgpKzEsWD1vZSh6KTtyZShoLEIsWCx6KTt2YXIgaj1YLGJlPW9lKDQpO2ZvcihoPVtdO0coaiwiaTgiKSE9PTA7KXtxZShpKSxxZShiZSksdGhpcy5oYW5kbGVFcnJvcihOKHRoaXMuZGIsaiwtMSxpLGJlKSk7dmFyIHllPUcoaSwiaTMyIik7aWYoaj1HKGJlLCJpMzIiKSx5ZSE9PTApe2Zvcih6PW51bGwsUz1uZXcgZSh5ZSx0aGlzKSxiIT1udWxsJiZTLmJpbmQoYik7Uy5zdGVwKCk7KXo9PT1udWxsJiYoej17Y29sdW1uczpTLmdldENvbHVtbk5hbWVzKCksdmFsdWVzOltdfSxoLnB1c2goeikpLHoudmFsdWVzLnB1c2goUy5nZXQoKSk7Uy5mcmVlKCl9fXJldHVybiBofWNhdGNoKFYpe3Rocm93IFMmJlMuZnJlZSgpLFZ9ZmluYWxseXtEZShBKX19LHIucHJvdG90eXBlLmVhY2g9ZnVuY3Rpb24oaCxiLEEsUyl7dHlwZW9mIGI9PSJmdW5jdGlvbiImJihTPUEsQT1iLGI9dm9pZCAwKSxoPXRoaXMucHJlcGFyZShoLGIpO3RyeXtmb3IoO2guc3RlcCgpOylBKGguZ2V0QXNPYmplY3QoKSl9ZmluYWxseXtoLmZyZWUoKX1pZih0eXBlb2YgUz09ImZ1bmN0aW9uIilyZXR1cm4gUygpfSxyLnByb3RvdHlwZS5wcmVwYXJlPWZ1bmN0aW9uKGgsYil7aWYocWUoaSksdGhpcy5oYW5kbGVFcnJvcih3KHRoaXMuZGIsaCwtMSxpLDApKSxoPUcoaSwiaTMyIiksaD09PTApdGhyb3ciTm90aGluZyB0byBwcmVwYXJlIjt2YXIgQT1uZXcgZShoLHRoaXMpO3JldHVybiBiIT1udWxsJiZBLmJpbmQoYiksdGhpcy5nYltoXT1BfSxyLnByb3RvdHlwZS5pdGVyYXRlU3RhdGVtZW50cz1mdW5jdGlvbihoKXtyZXR1cm4gbmV3IHQoaCx0aGlzKX0sci5wcm90b3R5cGUuZXhwb3J0PWZ1bmN0aW9uKCl7T2JqZWN0LnZhbHVlcyh0aGlzLmdiKS5mb3JFYWNoKGZ1bmN0aW9uKGIpe2IuZnJlZSgpfSksT2JqZWN0LnZhbHVlcyh0aGlzLlJhKS5mb3JFYWNoKFFlKSx0aGlzLlJhPXt9LHRoaXMuaGFuZGxlRXJyb3IoZCh0aGlzLmRiKSk7dmFyIGg9bi5yZWFkRmlsZSh0aGlzLmZpbGVuYW1lLHtlbmNvZGluZzoiYmluYXJ5In0pO3JldHVybiB0aGlzLmhhbmRsZUVycm9yKGwodGhpcy5maWxlbmFtZSxpKSksdGhpcy5kYj1HKGksImkzMiIpLGh9LHIucHJvdG90eXBlLmNsb3NlPWZ1bmN0aW9uKCl7dGhpcy5kYiE9PW51bGwmJihPYmplY3QudmFsdWVzKHRoaXMuZ2IpLmZvckVhY2goZnVuY3Rpb24oaCl7aC5mcmVlKCl9KSxPYmplY3QudmFsdWVzKHRoaXMuUmEpLmZvckVhY2goUWUpLHRoaXMuUmE9e30sdGhpcy5oYW5kbGVFcnJvcihkKHRoaXMuZGIpKSx0aGlzLk5jJiZuLnVubGluaygiLyIrdGhpcy5maWxlbmFtZSksdGhpcy5kYj1udWxsKX0sci5wcm90b3R5cGUuaGFuZGxlRXJyb3I9ZnVuY3Rpb24oaCl7aWYoaD09PTApcmV0dXJuIG51bGw7dGhyb3cgaD1VKHRoaXMuZGIpLEVycm9yKGgpfSxyLnByb3RvdHlwZS5nZXRSb3dzTW9kaWZpZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gZyh0aGlzLmRiKX0sci5wcm90b3R5cGUuY3JlYXRlX2Z1bmN0aW9uPWZ1bmN0aW9uKGgsYil7T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuUmEsaCkmJihRZSh0aGlzLlJhW2hdKSxkZWxldGUgdGhpcy5SYVtoXSk7dmFyIEE9TmUoZnVuY3Rpb24oUyx6LFgpe2Zvcih2YXIgaixiZT1bXSx5ZT0wO3llPHo7eWUrPTEpe3ZhciBWPUcoWCs0KnllLCJpMzIiKSxlZT16cihWKTtpZihlZT09PTF8fGVlPT09MilWPUxyKFYpO2Vsc2UgaWYoZWU9PT0zKVY9TnIoVik7ZWxzZSBpZihlZT09PTQpe2VlPVYsVj1ScihlZSksZWU9UHIoZWUpO2Zvcih2YXIgV3Q9bmV3IFVpbnQ4QXJyYXkoViksSGU9MDtIZTxWO0hlKz0xKVd0W0hlXT1CW2VlK0hlXTtWPVd0fWVsc2UgVj1udWxsO2JlLnB1c2goVil9dHJ5e2o9Yi5hcHBseShudWxsLGJlKX1jYXRjaChPcil7VXQoUyxPciwtMSk7cmV0dXJufXN3aXRjaCh0eXBlb2Ygail7Y2FzZSJib29sZWFuIjpVcihTLGo/MTowKTticmVhaztjYXNlIm51bWJlciI6QnIoUyxqKTticmVhaztjYXNlInN0cmluZyI6VHIoUyxqLC0xLC0xKTticmVhaztjYXNlIm9iamVjdCI6aj09PW51bGw/eHQoUyk6ai5sZW5ndGghPW51bGw/KHo9WmUoaikseHIoUyx6LGoubGVuZ3RoLC0xKSxWZSh6KSk6VXQoUywiV3JvbmcgQVBJIHVzZSA6IHRyaWVkIHRvIHJldHVybiBhIHZhbHVlIG9mIGFuIHVua25vd24gdHlwZSAoIitqKyIpLiIsLTEpO2JyZWFrO2RlZmF1bHQ6eHQoUyl9fSwidmlpaSIpO3JldHVybiB0aGlzLlJhW2hdPUEsdGhpcy5oYW5kbGVFcnJvcihGcih0aGlzLmRiLGgsYi5sZW5ndGgsMSwwLEEsMCwwLDApKSx0aGlzfSxzLkRhdGFiYXNlPXI7dmFyIE1lPW5ldyBNYXA7cy5yZWdpc3Rlcl9mb3JfaWRiPWg9PntsZXQgYj1OZShmdW5jdGlvbih6LFgpe3JldHVybiB6PU1lLmdldCh6KSxoLmxvY2soeixYKT8wOjV9LCJpaWkiKSxBPU5lKGZ1bmN0aW9uKHosWCl7cmV0dXJuIHo9TWUuZ2V0KHopLGgudW5sb2NrKHosWCksMH0sImlpaSIpLFM9TmUoZnVuY3Rpb24oeixYKXt6PUwoeiksTWUuc2V0KFgseil9LCJ2aWkiKTtzLl9yZWdpc3Rlcl9mb3JfaWRiKGIsQSxTKX0scy5jbGVhbnVwX2ZpbGU9aD0+e2xldCBiPVsuLi5NZS5lbnRyaWVzKCldLmZpbmQoQT0+QVsxXT09PWgpO01lLmRlbGV0ZShiWzBdKX0scy5yZXNldF9maWxlc3lzdGVtPSgpPT57bi5yb290PW51bGwsbi5lYygpfX07dmFyIE09T2JqZWN0LmFzc2lnbih7fSxzKSxXPSIuL3RoaXMucHJvZ3JhbSIsST10eXBlb2Ygd2luZG93PT0ib2JqZWN0IixSPXR5cGVvZiBpbXBvcnRTY3JpcHRzPT0iZnVuY3Rpb24iLHg9dHlwZW9mIHByb2Nlc3M9PSJvYmplY3QiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucz09Im9iamVjdCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PSJzdHJpbmciLE89IiIsRWUsdmUsSWUsRmUsemUsS2U7eD8oTz1SP0plLmRpcm5hbWUoTykrIi8iOl9fZGlybmFtZSsiLyIsS2U9KCk9Pnt6ZXx8KEZlPUplLHplPUplKX0sRWU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gS2UoKSxlPXplLm5vcm1hbGl6ZShlKSxGZS5yZWFkRmlsZVN5bmMoZSx0P3ZvaWQgMDoidXRmOCIpfSxJZT1lPT4oZT1FZShlLCEwKSxlLmJ1ZmZlcnx8KGU9bmV3IFVpbnQ4QXJyYXkoZSkpLGUpLHZlPShlLHQscik9PntLZSgpLGU9emUubm9ybWFsaXplKGUpLEZlLnJlYWRGaWxlKGUsZnVuY3Rpb24oaSxvKXtpP3IoaSk6dChvLmJ1ZmZlcil9KX0sMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYoVz1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFwvZywiLyIpKSxwcm9jZXNzLmFyZ3Yuc2xpY2UoMiksRS5leHBvcnRzPXMscy5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdIn0pOihJfHxSKSYmKFI/Tz1zZWxmLmxvY2F0aW9uLmhyZWY6dHlwZW9mIGRvY3VtZW50IT0idW5kZWZpbmVkIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKE89ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLE89Ty5pbmRleE9mKCJibG9iOiIpIT09MD9PLnN1YnN0cigwLE8ucmVwbGFjZSgvWz8jXS4qLywiIikubGFzdEluZGV4T2YoIi8iKSsxKToiIixFZT1lPT57dmFyIHQ9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB0Lm9wZW4oIkdFVCIsZSwhMSksdC5zZW5kKG51bGwpLHQucmVzcG9uc2VUZXh0fSxSJiYoSWU9ZT0+e3ZhciB0PW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gdC5vcGVuKCJHRVQiLGUsITEpLHQucmVzcG9uc2VUeXBlPSJhcnJheWJ1ZmZlciIsdC5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KHQucmVzcG9uc2UpfSksdmU9KGUsdCxyKT0+e3ZhciBpPW5ldyBYTUxIdHRwUmVxdWVzdDtpLm9wZW4oIkdFVCIsZSwhMCksaS5yZXNwb25zZVR5cGU9ImFycmF5YnVmZmVyIixpLm9ubG9hZD0oKT0+e2kuc3RhdHVzPT0yMDB8fGkuc3RhdHVzPT0wJiZpLnJlc3BvbnNlP3QoaS5yZXNwb25zZSk6cigpfSxpLm9uZXJyb3I9cixpLnNlbmQobnVsbCl9KTt2YXIgUmU9cy5wcmludHx8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSx0ZT1zLnByaW50RXJyfHxjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtPYmplY3QuYXNzaWduKHMsTSksTT1udWxsLHMudGhpc1Byb2dyYW0mJihXPXMudGhpc1Byb2dyYW0pO2Z1bmN0aW9uIF90KGUpe3JldHVybiAxMjg+ZT9bZV06W2UlMTI4fDEyOCxlPj43XX12YXIgWGU9W10sbGU7ZnVuY3Rpb24gTmUoZSx0KXtpZighbGUpe2xlPW5ldyBXZWFrTWFwO2Zvcih2YXIgcj1ZLmxlbmd0aCxpPTA7aTwwK3I7aSsrKXt2YXIgbz1CZShpKTtvJiZsZS5zZXQobyxpKX19aWYobGUuaGFzKGUpKXJldHVybiBsZS5nZXQoZSk7aWYoWGUubGVuZ3RoKXI9WGUucG9wKCk7ZWxzZXt0cnl7WS5ncm93KDEpfWNhdGNoKG0pe3Rocm93IG0gaW5zdGFuY2VvZiBSYW5nZUVycm9yPyJVbmFibGUgdG8gZ3JvdyB3YXNtIHRhYmxlLiBTZXQgQUxMT1dfVEFCTEVfR1JPV1RILiI6bX1yPVkubGVuZ3RoLTF9dHJ5e2k9cixZLnNldChpLGUpLHdlW2ldPVkuZ2V0KGkpfWNhdGNoKG0pe2lmKCEobSBpbnN0YW5jZW9mIFR5cGVFcnJvcikpdGhyb3cgbTtpZih0eXBlb2YgV2ViQXNzZW1ibHkuRnVuY3Rpb249PSJmdW5jdGlvbiIpe289e2k6ImkzMiIsajoiaTY0IixmOiJmMzIiLGQ6ImY2NCIscDoiaTMyIn07dmFyIGw9e3BhcmFtZXRlcnM6W10scmVzdWx0czp0WzBdPT0idiI/W106W29bdFswXV1dfTtmb3IoaT0xO2k8dC5sZW5ndGg7KytpKWwucGFyYW1ldGVycy5wdXNoKG9bdFtpXV0pO3Q9bmV3IFdlYkFzc2VtYmx5LkZ1bmN0aW9uKGwsZSl9ZWxzZXtvPVsxLDk2XSxsPXQuc2xpY2UoMCwxKSx0PXQuc2xpY2UoMSk7dmFyIGQ9e2k6MTI3LHA6MTI3LGo6MTI2LGY6MTI1LGQ6MTI0fTtmb3Iobz1vLmNvbmNhdChfdCh0Lmxlbmd0aCkpLGk9MDtpPHQubGVuZ3RoOysraSlvLnB1c2goZFt0W2ldXSk7bD09InYiP28ucHVzaCgwKTpvPW8uY29uY2F0KFsxLGRbbF1dKSxvPVsxXS5jb25jYXQoX3Qoby5sZW5ndGgpLG8pLHQ9bmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwXS5jb25jYXQobyxbMiw3LDEsMSwxMDEsMSwxMDIsMCwwLDcsNSwxLDEsMTAyLDAsMF0pKSx0PW5ldyBXZWJBc3NlbWJseS5Nb2R1bGUodCksdD1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UodCx7ZTp7ZjplfX0pLmV4cG9ydHMuZn1pPXIsWS5zZXQoaSx0KSx3ZVtpXT1ZLmdldChpKX1yZXR1cm4gbGUuc2V0KGUscikscn1mdW5jdGlvbiBRZShlKXtsZS5kZWxldGUoQmUoZSkpLFhlLnB1c2goZSl9dmFyIGtlO3Mud2FzbUJpbmFyeSYmKGtlPXMud2FzbUJpbmFyeSkscy5ub0V4aXRSdW50aW1lLHR5cGVvZiBXZWJBc3NlbWJseSE9Im9iamVjdCImJlooIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWQiKTt2YXIgWWUsZ3Q9ITE7ZnVuY3Rpb24gYXIoZSx0LHIsaSl7dmFyIG89e3N0cmluZzpmdW5jdGlvbih3KXt2YXIgXz0wO2lmKHchPW51bGwmJnchPT0wKXt2YXIgRD0ody5sZW5ndGg8PDIpKzE7Xz1vZShEKSxyZSh3LEssXyxEKX1yZXR1cm4gX30sYXJyYXk6ZnVuY3Rpb24odyl7dmFyIF89b2Uody5sZW5ndGgpO3JldHVybiBCLnNldCh3LF8pLF99fTtlPXNbIl8iK2VdO3ZhciBsPVtdLGQ9MDtpZihpKWZvcih2YXIgbT0wO208aS5sZW5ndGg7bSsrKXt2YXIgZz1vW3JbbV1dO2c/KGQ9PT0wJiYoZD1TZSgpKSxsW21dPWcoaVttXSkpOmxbbV09aVttXX1yZXR1cm4gcj1lLmFwcGx5KG51bGwsbCkscj1mdW5jdGlvbih3KXtyZXR1cm4gZCE9PTAmJkRlKGQpLHQ9PT0ic3RyaW5nIj9MKHcpOnQ9PT0iYm9vbGVhbiI/ISF3Ond9KHIpfWZ1bmN0aW9uIFplKGUpe3ZhciB0PWplKGUubGVuZ3RoKTtyZXR1cm4gZS5zdWJhcnJheXx8ZS5zbGljZXx8KGU9bmV3IFVpbnQ4QXJyYXkoZSkpLEsuc2V0KGUsdCksdH12YXIgRXQ9dHlwZW9mIFRleHREZWNvZGVyIT0idW5kZWZpbmVkIj9uZXcgVGV4dERlY29kZXIoInV0ZjgiKTp2b2lkIDA7ZnVuY3Rpb24gbWUoZSx0LHIpe3ZhciBpPXQrcjtmb3Iocj10O2Vbcl0mJiEocj49aSk7KSsrcjtpZigxNjxyLXQmJmUuYnVmZmVyJiZFdClyZXR1cm4gRXQuZGVjb2RlKGUuc3ViYXJyYXkodCxyKSk7Zm9yKGk9IiI7dDxyOyl7dmFyIG89ZVt0KytdO2lmKG8mMTI4KXt2YXIgbD1lW3QrK10mNjM7aWYoKG8mMjI0KT09MTkyKWkrPVN0cmluZy5mcm9tQ2hhckNvZGUoKG8mMzEpPDw2fGwpO2Vsc2V7dmFyIGQ9ZVt0KytdJjYzO289KG8mMjQwKT09MjI0PyhvJjE1KTw8MTJ8bDw8NnxkOihvJjcpPDwxOHxsPDwxMnxkPDw2fGVbdCsrXSY2Myw2NTUzNj5vP2krPVN0cmluZy5mcm9tQ2hhckNvZGUobyk6KG8tPTY1NTM2LGkrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8bz4+MTAsNTYzMjB8byYxMDIzKSl9fWVsc2UgaSs9U3RyaW5nLmZyb21DaGFyQ29kZShvKX1yZXR1cm4gaX1mdW5jdGlvbiBMKGUsdCl7cmV0dXJuIGU/bWUoSyxlLHQpOiIifWZ1bmN0aW9uIHJlKGUsdCxyLGkpe2lmKCEoMDxpKSlyZXR1cm4gMDt2YXIgbz1yO2k9citpLTE7Zm9yKHZhciBsPTA7bDxlLmxlbmd0aDsrK2wpe3ZhciBkPWUuY2hhckNvZGVBdChsKTtpZig1NTI5Njw9ZCYmNTczNDM+PWQpe3ZhciBtPWUuY2hhckNvZGVBdCgrK2wpO2Q9NjU1MzYrKChkJjEwMjMpPDwxMCl8bSYxMDIzfWlmKDEyNz49ZCl7aWYocj49aSlicmVhazt0W3IrK109ZH1lbHNle2lmKDIwNDc+PWQpe2lmKHIrMT49aSlicmVhazt0W3IrK109MTkyfGQ+PjZ9ZWxzZXtpZig2NTUzNT49ZCl7aWYocisyPj1pKWJyZWFrO3RbcisrXT0yMjR8ZD4+MTJ9ZWxzZXtpZihyKzM+PWkpYnJlYWs7dFtyKytdPTI0MHxkPj4xOCx0W3IrK109MTI4fGQ+PjEyJjYzfXRbcisrXT0xMjh8ZD4+NiY2M310W3IrK109MTI4fGQmNjN9fXJldHVybiB0W3JdPTAsci1vfWZ1bmN0aW9uIGZlKGUpe2Zvcih2YXIgdD0wLHI9MDtyPGUubGVuZ3RoOysrcil7dmFyIGk9ZS5jaGFyQ29kZUF0KHIpOzU1Mjk2PD1pJiY1NzM0Mz49aSYmKGk9NjU1MzYrKChpJjEwMjMpPDwxMCl8ZS5jaGFyQ29kZUF0KCsrcikmMTAyMyksMTI3Pj1pPysrdDp0PTIwNDc+PWk/dCsyOjY1NTM1Pj1pP3QrMzp0KzR9cmV0dXJuIHR9ZnVuY3Rpb24gdnQoZSl7dmFyIHQ9ZmUoZSkrMSxyPWplKHQpO3JldHVybiByJiZyZShlLEIscix0KSxyfXZhciBHZSxCLEssUGUsdixDLGV0LHR0O2Z1bmN0aW9uIGt0KCl7dmFyIGU9WWUuYnVmZmVyO0dlPWUscy5IRUFQOD1CPW5ldyBJbnQ4QXJyYXkoZSkscy5IRUFQMTY9UGU9bmV3IEludDE2QXJyYXkoZSkscy5IRUFQMzI9dj1uZXcgSW50MzJBcnJheShlKSxzLkhFQVBVOD1LPW5ldyBVaW50OEFycmF5KGUpLHMuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkoZSkscy5IRUFQVTMyPUM9bmV3IFVpbnQzMkFycmF5KGUpLHMuSEVBUEYzMj1ldD1uZXcgRmxvYXQzMkFycmF5KGUpLHMuSEVBUEY2ND10dD1uZXcgRmxvYXQ2NEFycmF5KGUpfXZhciBZLEF0PVtdLHF0PVtdLFN0PVtdO2Z1bmN0aW9uIHVyKCl7dmFyIGU9cy5wcmVSdW4uc2hpZnQoKTtBdC51bnNoaWZ0KGUpfXZhciBjZT0wLEFlPW51bGw7ZnVuY3Rpb24gcnQoKXtjZSsrLHMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmcy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKGNlKX1mdW5jdGlvbiBMZSgpe2lmKGNlLS0scy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZzLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoY2UpLGNlPT0wJiZBZSl7dmFyIGU9QWU7QWU9bnVsbCxlKCl9fWZ1bmN0aW9uIFooZSl7dGhyb3cgcy5vbkFib3J0JiZzLm9uQWJvcnQoZSksZT0iQWJvcnRlZCgiK2UrIikiLHRlKGUpLGd0PSEwLG5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoZSsiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLiIpfWZ1bmN0aW9uIER0KCl7cmV0dXJuIEguc3RhcnRzV2l0aCgiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCIpfXZhciBIO2lmKEg9InNxbC13YXNtLndhc20iLCFEdCgpKXt2YXIgTXQ9SDtIPXMubG9jYXRlRmlsZT9zLmxvY2F0ZUZpbGUoTXQsTyk6TytNdH1mdW5jdGlvbiBJdCgpe3ZhciBlPUg7dHJ5e2lmKGU9PUgmJmtlKXJldHVybiBuZXcgVWludDhBcnJheShrZSk7aWYoSWUpcmV0dXJuIEllKGUpO3Rocm93ImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkIn1jYXRjaCh0KXtaKHQpfX1mdW5jdGlvbiBscigpe2lmKCFrZSYmKEl8fFIpKXtpZih0eXBlb2YgZmV0Y2g9PSJmdW5jdGlvbiImJiFILnN0YXJ0c1dpdGgoImZpbGU6Ly8iKSlyZXR1cm4gZmV0Y2goSCx7Y3JlZGVudGlhbHM6InNhbWUtb3JpZ2luIn0pLnRoZW4oZnVuY3Rpb24oZSl7aWYoIWUub2spdGhyb3ciZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnIitIKyInIjtyZXR1cm4gZS5hcnJheUJ1ZmZlcigpfSkuY2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gSXQoKX0pO2lmKHZlKXJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihlLHQpe3ZlKEgsZnVuY3Rpb24ocil7ZShuZXcgVWludDhBcnJheShyKSl9LHQpfSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gSXQoKX0pfXZhciBGLCQ7ZnVuY3Rpb24gbnQoZSl7Zm9yKDswPGUubGVuZ3RoOyl7dmFyIHQ9ZS5zaGlmdCgpO2lmKHR5cGVvZiB0PT0iZnVuY3Rpb24iKXQocyk7ZWxzZXt2YXIgcj10LmNkO3R5cGVvZiByPT0ibnVtYmVyIj90LnNiPT09dm9pZCAwP0JlKHIpKCk6QmUocikodC5zYik6cih0LnNiPT09dm9pZCAwP251bGw6dC5zYil9fX1mdW5jdGlvbiBHKGUsdD0iaTgiKXtzd2l0Y2godC5lbmRzV2l0aCgiKiIpJiYodD0idTMyIiksdCl7Y2FzZSJpMSI6cmV0dXJuIEJbZT4+MF07Y2FzZSJpOCI6cmV0dXJuIEJbZT4+MF07Y2FzZSJpMTYiOnJldHVybiBQZVtlPj4xXTtjYXNlImkzMiI6cmV0dXJuIHZbZT4+Ml07Y2FzZSJpNjQiOnJldHVybiB2W2U+PjJdO2Nhc2UiZmxvYXQiOnJldHVybiBldFtlPj4yXTtjYXNlImRvdWJsZSI6cmV0dXJuIE51bWJlcih0dFtlPj4zXSk7ZGVmYXVsdDpaKCJpbnZhbGlkIHR5cGUgZm9yIGdldFZhbHVlOiAiK3QpfXJldHVybiBudWxsfXZhciB3ZT1bXTtmdW5jdGlvbiBCZShlKXt2YXIgdD13ZVtlXTtyZXR1cm4gdHx8KGU+PXdlLmxlbmd0aCYmKHdlLmxlbmd0aD1lKzEpLHdlW2VdPXQ9WS5nZXQoZSkpLHR9ZnVuY3Rpb24gcWUoZSl7dmFyIHQ9ImkzMiI7c3dpdGNoKHQuZW5kc1dpdGgoIioiKSYmKHQ9InUzMiIpLHQpe2Nhc2UiaTEiOkJbZT4+MF09MDticmVhaztjYXNlImk4IjpCW2U+PjBdPTA7YnJlYWs7Y2FzZSJpMTYiOlBlW2U+PjFdPTA7YnJlYWs7Y2FzZSJpMzIiOnZbZT4+Ml09MDticmVhaztjYXNlImk2NCI6JD1bMCwoRj0wLDE8PStNYXRoLmFicyhGKT8wPEY/KE1hdGgubWluKCtNYXRoLmZsb29yKEYvNDI5NDk2NzI5NiksNDI5NDk2NzI5NSl8MCk+Pj4wOn5+K01hdGguY2VpbCgoRi0rKH5+Rj4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCldLHZbZT4+Ml09JFswXSx2W2UrND4+Ml09JFsxXTticmVhaztjYXNlImZsb2F0IjpldFtlPj4yXT0wO2JyZWFrO2Nhc2UiZG91YmxlIjp0dFtlPj4zXT0wO2JyZWFrO2RlZmF1bHQ6WigiaW52YWxpZCB0eXBlIGZvciBzZXRWYWx1ZTogIit0KX19dmFyIGl0PShlLHQpPT57Zm9yKHZhciByPTAsaT1lLmxlbmd0aC0xOzA8PWk7aS0tKXt2YXIgbz1lW2ldO289PT0iLiI/ZS5zcGxpY2UoaSwxKTpvPT09Ii4uIj8oZS5zcGxpY2UoaSwxKSxyKyspOnImJihlLnNwbGljZShpLDEpLHItLSl9aWYodClmb3IoO3I7ci0tKWUudW5zaGlmdCgiLi4iKTtyZXR1cm4gZX0sSj1lPT57dmFyIHQ9ZS5jaGFyQXQoMCk9PT0iLyIscj1lLnN1YnN0cigtMSk9PT0iLyI7cmV0dXJuKGU9aXQoZS5zcGxpdCgiLyIpLmZpbHRlcihpPT4hIWkpLCF0KS5qb2luKCIvIikpfHx0fHwoZT0iLiIpLGUmJnImJihlKz0iLyIpLCh0PyIvIjoiIikrZX0sVGU9ZT0+e3ZhciB0PS9eKFwvP3wpKFtcc1xTXSo/KSgoPzpcLnsxLDJ9fFteXC9dKz98KShcLlteLlwvXSp8KSkoPzpbXC9dKikkLy5leGVjKGUpLnNsaWNlKDEpO3JldHVybiBlPXRbMF0sdD10WzFdLCFlJiYhdD8iLiI6KHQmJih0PXQuc3Vic3RyKDAsdC5sZW5ndGgtMSkpLGUrdCl9LG5lPWU9PntpZihlPT09Ii8iKXJldHVybiIvIjtlPUooZSksZT1lLnJlcGxhY2UoL1wvJC8sIiIpO3ZhciB0PWUubGFzdEluZGV4T2YoIi8iKTtyZXR1cm4gdD09PS0xP2U6ZS5zdWJzdHIodCsxKX0sZnI9KGUsdCk9PkooZSsiLyIrdCk7ZnVuY3Rpb24gY3IoKXtpZih0eXBlb2YgY3J5cHRvPT0ib2JqZWN0IiYmdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXM9PSJmdW5jdGlvbiIpe3ZhciBlPW5ldyBVaW50OEFycmF5KDEpO3JldHVybiBmdW5jdGlvbigpe3JldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGUpLGVbMF19fWlmKHgpdHJ5e3ZhciB0PXJlcXVpcmUoImNyeXB0byIpO3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LnJhbmRvbUJ5dGVzKDEpWzBdfX1jYXRjaHt9cmV0dXJuIGZ1bmN0aW9uKCl7WigicmFuZG9tRGV2aWNlIil9fWZ1bmN0aW9uIGhlKCl7Zm9yKHZhciBlPSIiLHQ9ITEscj1hcmd1bWVudHMubGVuZ3RoLTE7LTE8PXImJiF0O3ItLSl7aWYodD0wPD1yP2FyZ3VtZW50c1tyXTpuLmN3ZCgpLHR5cGVvZiB0IT0ic3RyaW5nIil0aHJvdyBuZXcgVHlwZUVycm9yKCJBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncyIpO2lmKCF0KXJldHVybiIiO2U9dCsiLyIrZSx0PXQuY2hhckF0KDApPT09Ii8ifXJldHVybiBlPWl0KGUuc3BsaXQoIi8iKS5maWx0ZXIoaT0+ISFpKSwhdCkuam9pbigiLyIpLCh0PyIvIjoiIikrZXx8Ii4ifXZhciBGdD0oZSx0KT0+e2Z1bmN0aW9uIHIoZCl7Zm9yKHZhciBtPTA7bTxkLmxlbmd0aCYmZFttXT09PSIiO20rKyk7Zm9yKHZhciBnPWQubGVuZ3RoLTE7MDw9ZyYmZFtnXT09PSIiO2ctLSk7cmV0dXJuIG0+Zz9bXTpkLnNsaWNlKG0sZy1tKzEpfWU9aGUoZSkuc3Vic3RyKDEpLHQ9aGUodCkuc3Vic3RyKDEpLGU9cihlLnNwbGl0KCIvIikpLHQ9cih0LnNwbGl0KCIvIikpO2Zvcih2YXIgaT1NYXRoLm1pbihlLmxlbmd0aCx0Lmxlbmd0aCksbz1pLGw9MDtsPGk7bCsrKWlmKGVbbF0hPT10W2xdKXtvPWw7YnJlYWt9Zm9yKGk9W10sbD1vO2w8ZS5sZW5ndGg7bCsrKWkucHVzaCgiLi4iKTtyZXR1cm4gaT1pLmNvbmNhdCh0LnNsaWNlKG8pKSxpLmpvaW4oIi8iKX0senQ9W107ZnVuY3Rpb24gUnQoZSx0KXt6dFtlXT17aW5wdXQ6W10sb3V0cHV0OltdLCRhOnR9LG4uS2IoZSxocil9dmFyIGhyPXtvcGVuOmZ1bmN0aW9uKGUpe3ZhciB0PXp0W2Uubm9kZS5yZGV2XTtpZighdCl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDQzKTtlLnR0eT10LGUuc2Vla2FibGU9ITF9LGNsb3NlOmZ1bmN0aW9uKGUpe2UudHR5LiRhLmZsdXNoKGUudHR5KX0sZmx1c2g6ZnVuY3Rpb24oZSl7ZS50dHkuJGEuZmx1c2goZS50dHkpfSxyZWFkOmZ1bmN0aW9uKGUsdCxyLGkpe2lmKCFlLnR0eXx8IWUudHR5LiRhLlliKXRocm93IG5ldyBuLkVycm5vRXJyb3IoNjApO2Zvcih2YXIgbz0wLGw9MDtsPGk7bCsrKXt0cnl7dmFyIGQ9ZS50dHkuJGEuWWIoZS50dHkpfWNhdGNoe3Rocm93IG5ldyBuLkVycm5vRXJyb3IoMjkpfWlmKGQ9PT12b2lkIDAmJm89PT0wKXRocm93IG5ldyBuLkVycm5vRXJyb3IoNik7aWYoZD09bnVsbClicmVhaztvKyssdFtyK2xdPWR9cmV0dXJuIG8mJihlLm5vZGUudGltZXN0YW1wPURhdGUubm93KCkpLG99LHdyaXRlOmZ1bmN0aW9uKGUsdCxyLGkpe2lmKCFlLnR0eXx8IWUudHR5LiRhLkhiKXRocm93IG5ldyBuLkVycm5vRXJyb3IoNjApO3RyeXtmb3IodmFyIG89MDtvPGk7bysrKWUudHR5LiRhLkhiKGUudHR5LHRbcitvXSl9Y2F0Y2h7dGhyb3cgbmV3IG4uRXJybm9FcnJvcigyOSl9cmV0dXJuIGkmJihlLm5vZGUudGltZXN0YW1wPURhdGUubm93KCkpLG99fSxkcj17WWI6ZnVuY3Rpb24oZSl7aWYoIWUuaW5wdXQubGVuZ3RoKXt2YXIgdD1udWxsO2lmKHgpe3ZhciByPUJ1ZmZlci5hbGxvYygyNTYpLGk9MDt0cnl7aT1GZS5yZWFkU3luYyhwcm9jZXNzLnN0ZGluLmZkLHIsMCwyNTYsLTEpfWNhdGNoKG8pe2lmKG8udG9TdHJpbmcoKS5pbmNsdWRlcygiRU9GIikpaT0wO2Vsc2UgdGhyb3cgb30wPGk/dD1yLnNsaWNlKDAsaSkudG9TdHJpbmcoInV0Zi04Iik6dD1udWxsfWVsc2UgdHlwZW9mIHdpbmRvdyE9InVuZGVmaW5lZCImJnR5cGVvZiB3aW5kb3cucHJvbXB0PT0iZnVuY3Rpb24iPyh0PXdpbmRvdy5wcm9tcHQoIklucHV0OiAiKSx0IT09bnVsbCYmKHQrPWAKYCkpOnR5cGVvZiByZWFkbGluZT09ImZ1bmN0aW9uIiYmKHQ9cmVhZGxpbmUoKSx0IT09bnVsbCYmKHQrPWAKYCkpO2lmKCF0KXJldHVybiBudWxsO2UuaW5wdXQ9T2UodCwhMCl9cmV0dXJuIGUuaW5wdXQuc2hpZnQoKX0sSGI6ZnVuY3Rpb24oZSx0KXt0PT09bnVsbHx8dD09PTEwPyhSZShtZShlLm91dHB1dCwwKSksZS5vdXRwdXQ9W10pOnQhPTAmJmUub3V0cHV0LnB1c2godCl9LGZsdXNoOmZ1bmN0aW9uKGUpe2Uub3V0cHV0JiYwPGUub3V0cHV0Lmxlbmd0aCYmKFJlKG1lKGUub3V0cHV0LDApKSxlLm91dHB1dD1bXSl9fSxwcj17SGI6ZnVuY3Rpb24oZSx0KXt0PT09bnVsbHx8dD09PTEwPyh0ZShtZShlLm91dHB1dCwwKSksZS5vdXRwdXQ9W10pOnQhPTAmJmUub3V0cHV0LnB1c2godCl9LGZsdXNoOmZ1bmN0aW9uKGUpe2Uub3V0cHV0JiYwPGUub3V0cHV0Lmxlbmd0aCYmKHRlKG1lKGUub3V0cHV0LDApKSxlLm91dHB1dD1bXSl9fSxxPXtQYTpudWxsLG1vdW50OmZ1bmN0aW9uKCl7cmV0dXJuIHEuY3JlYXRlTm9kZShudWxsLCIvIiwxNjg5NSwwKX0sY3JlYXRlTm9kZTpmdW5jdGlvbihlLHQscixpKXtpZihuLkpjKHIpfHxuLmlzRklGTyhyKSl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDYzKTtyZXR1cm4gcS5QYXx8KHEuUGE9e2Rpcjp7bm9kZTp7Z2V0YXR0cjpxLm5vZGVfb3BzLmdldGF0dHIsc2V0YXR0cjpxLm5vZGVfb3BzLnNldGF0dHIsbG9va3VwOnEubm9kZV9vcHMubG9va3VwLG1rbm9kOnEubm9kZV9vcHMubWtub2QscmVuYW1lOnEubm9kZV9vcHMucmVuYW1lLHVubGluazpxLm5vZGVfb3BzLnVubGluayxybWRpcjpxLm5vZGVfb3BzLnJtZGlyLHJlYWRkaXI6cS5ub2RlX29wcy5yZWFkZGlyLHN5bWxpbms6cS5ub2RlX29wcy5zeW1saW5rfSxzdHJlYW06e2xsc2VlazpxLnN0cmVhbV9vcHMubGxzZWVrfX0sZmlsZTp7bm9kZTp7Z2V0YXR0cjpxLm5vZGVfb3BzLmdldGF0dHIsc2V0YXR0cjpxLm5vZGVfb3BzLnNldGF0dHJ9LHN0cmVhbTp7bGxzZWVrOnEuc3RyZWFtX29wcy5sbHNlZWsscmVhZDpxLnN0cmVhbV9vcHMucmVhZCx3cml0ZTpxLnN0cmVhbV9vcHMud3JpdGUsYWxsb2NhdGU6cS5zdHJlYW1fb3BzLmFsbG9jYXRlLG1tYXA6cS5zdHJlYW1fb3BzLm1tYXAsbXN5bmM6cS5zdHJlYW1fb3BzLm1zeW5jfX0sbGluazp7bm9kZTp7Z2V0YXR0cjpxLm5vZGVfb3BzLmdldGF0dHIsc2V0YXR0cjpxLm5vZGVfb3BzLnNldGF0dHIscmVhZGxpbms6cS5ub2RlX29wcy5yZWFkbGlua30sc3RyZWFtOnt9fSxQYjp7bm9kZTp7Z2V0YXR0cjpxLm5vZGVfb3BzLmdldGF0dHIsc2V0YXR0cjpxLm5vZGVfb3BzLnNldGF0dHJ9LHN0cmVhbTpuLnZjfX0pLHI9bi5jcmVhdGVOb2RlKGUsdCxyLGkpLG4uaXNEaXIoci5tb2RlKT8oci5ub2RlX29wcz1xLlBhLmRpci5ub2RlLHIuc3RyZWFtX29wcz1xLlBhLmRpci5zdHJlYW0sci5JYT17fSk6bi5pc0ZpbGUoci5tb2RlKT8oci5ub2RlX29wcz1xLlBhLmZpbGUubm9kZSxyLnN0cmVhbV9vcHM9cS5QYS5maWxlLnN0cmVhbSxyLk1hPTAsci5JYT1udWxsKTpuLlphKHIubW9kZSk/KHIubm9kZV9vcHM9cS5QYS5saW5rLm5vZGUsci5zdHJlYW1fb3BzPXEuUGEubGluay5zdHJlYW0pOm4uamIoci5tb2RlKSYmKHIubm9kZV9vcHM9cS5QYS5QYi5ub2RlLHIuc3RyZWFtX29wcz1xLlBhLlBiLnN0cmVhbSksci50aW1lc3RhbXA9RGF0ZS5ub3coKSxlJiYoZS5JYVt0XT1yLGUudGltZXN0YW1wPXIudGltZXN0YW1wKSxyfSxlZDpmdW5jdGlvbihlKXtyZXR1cm4gZS5JYT9lLklhLnN1YmFycmF5P2UuSWEuc3ViYXJyYXkoMCxlLk1hKTpuZXcgVWludDhBcnJheShlLklhKTpuZXcgVWludDhBcnJheSgwKX0sVWI6ZnVuY3Rpb24oZSx0KXt2YXIgcj1lLklhP2UuSWEubGVuZ3RoOjA7cj49dHx8KHQ9TWF0aC5tYXgodCxyKigxMDQ4NTc2PnI/MjoxLjEyNSk+Pj4wKSxyIT0wJiYodD1NYXRoLm1heCh0LDI1NikpLHI9ZS5JYSxlLklhPW5ldyBVaW50OEFycmF5KHQpLDA8ZS5NYSYmZS5JYS5zZXQoci5zdWJhcnJheSgwLGUuTWEpLDApKX0sVmM6ZnVuY3Rpb24oZSx0KXtpZihlLk1hIT10KWlmKHQ9PTApZS5JYT1udWxsLGUuTWE9MDtlbHNle3ZhciByPWUuSWE7ZS5JYT1uZXcgVWludDhBcnJheSh0KSxyJiZlLklhLnNldChyLnN1YmFycmF5KDAsTWF0aC5taW4odCxlLk1hKSkpLGUuTWE9dH19LG5vZGVfb3BzOntnZXRhdHRyOmZ1bmN0aW9uKGUpe3ZhciB0PXt9O3JldHVybiB0LmRldj1uLmpiKGUubW9kZSk/ZS5pZDoxLHQuaW5vPWUuaWQsdC5tb2RlPWUubW9kZSx0Lm5saW5rPTEsdC51aWQ9MCx0LmdpZD0wLHQucmRldj1lLnJkZXYsbi5pc0RpcihlLm1vZGUpP3Quc2l6ZT00MDk2Om4uaXNGaWxlKGUubW9kZSk/dC5zaXplPWUuTWE6bi5aYShlLm1vZGUpP3Quc2l6ZT1lLmxpbmsubGVuZ3RoOnQuc2l6ZT0wLHQuYXRpbWU9bmV3IERhdGUoZS50aW1lc3RhbXApLHQubXRpbWU9bmV3IERhdGUoZS50aW1lc3RhbXApLHQuY3RpbWU9bmV3IERhdGUoZS50aW1lc3RhbXApLHQuc2M9NDA5Nix0LmJsb2Nrcz1NYXRoLmNlaWwodC5zaXplL3Quc2MpLHR9LHNldGF0dHI6ZnVuY3Rpb24oZSx0KXt0Lm1vZGUhPT12b2lkIDAmJihlLm1vZGU9dC5tb2RlKSx0LnRpbWVzdGFtcCE9PXZvaWQgMCYmKGUudGltZXN0YW1wPXQudGltZXN0YW1wKSx0LnNpemUhPT12b2lkIDAmJnEuVmMoZSx0LnNpemUpfSxsb29rdXA6ZnVuY3Rpb24oKXt0aHJvdyBuLnhiWzQ0XX0sbWtub2Q6ZnVuY3Rpb24oZSx0LHIsaSl7cmV0dXJuIHEuY3JlYXRlTm9kZShlLHQscixpKX0scmVuYW1lOmZ1bmN0aW9uKGUsdCxyKXtpZihuLmlzRGlyKGUubW9kZSkpe3RyeXt2YXIgaT1uLmxvb2t1cE5vZGUodCxyKX1jYXRjaHt9aWYoaSlmb3IodmFyIG8gaW4gaS5JYSl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDU1KX1kZWxldGUgZS5wYXJlbnQuSWFbZS5uYW1lXSxlLnBhcmVudC50aW1lc3RhbXA9RGF0ZS5ub3coKSxlLm5hbWU9cix0LklhW3JdPWUsdC50aW1lc3RhbXA9ZS5wYXJlbnQudGltZXN0YW1wLGUucGFyZW50PXR9LHVubGluazpmdW5jdGlvbihlLHQpe2RlbGV0ZSBlLklhW3RdLGUudGltZXN0YW1wPURhdGUubm93KCl9LHJtZGlyOmZ1bmN0aW9uKGUsdCl7dmFyIHI9bi5sb29rdXBOb2RlKGUsdCksaTtmb3IoaSBpbiByLklhKXRocm93IG5ldyBuLkVycm5vRXJyb3IoNTUpO2RlbGV0ZSBlLklhW3RdLGUudGltZXN0YW1wPURhdGUubm93KCl9LHJlYWRkaXI6ZnVuY3Rpb24oZSl7dmFyIHQ9WyIuIiwiLi4iXSxyO2ZvcihyIGluIGUuSWEpZS5JYS5oYXNPd25Qcm9wZXJ0eShyKSYmdC5wdXNoKHIpO3JldHVybiB0fSxzeW1saW5rOmZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZT1xLmNyZWF0ZU5vZGUoZSx0LDQxNDcxLDApLGUubGluaz1yLGV9LHJlYWRsaW5rOmZ1bmN0aW9uKGUpe2lmKCFuLlphKGUubW9kZSkpdGhyb3cgbmV3IG4uRXJybm9FcnJvcigyOCk7cmV0dXJuIGUubGlua319LHN0cmVhbV9vcHM6e3JlYWQ6ZnVuY3Rpb24oZSx0LHIsaSxvKXt2YXIgbD1lLm5vZGUuSWE7aWYobz49ZS5ub2RlLk1hKXJldHVybiAwO2lmKGU9TWF0aC5taW4oZS5ub2RlLk1hLW8saSksODxlJiZsLnN1YmFycmF5KXQuc2V0KGwuc3ViYXJyYXkobyxvK2UpLHIpO2Vsc2UgZm9yKGk9MDtpPGU7aSsrKXRbcitpXT1sW28raV07cmV0dXJuIGV9LHdyaXRlOmZ1bmN0aW9uKGUsdCxyLGksbyxsKXtpZih0LmJ1ZmZlcj09PUIuYnVmZmVyJiYobD0hMSksIWkpcmV0dXJuIDA7aWYoZT1lLm5vZGUsZS50aW1lc3RhbXA9RGF0ZS5ub3coKSx0LnN1YmFycmF5JiYoIWUuSWF8fGUuSWEuc3ViYXJyYXkpKXtpZihsKXJldHVybiBlLklhPXQuc3ViYXJyYXkocixyK2kpLGUuTWE9aTtpZihlLk1hPT09MCYmbz09PTApcmV0dXJuIGUuSWE9dC5zbGljZShyLHIraSksZS5NYT1pO2lmKG8raTw9ZS5NYSlyZXR1cm4gZS5JYS5zZXQodC5zdWJhcnJheShyLHIraSksbyksaX1pZihxLlViKGUsbytpKSxlLklhLnN1YmFycmF5JiZ0LnN1YmFycmF5KWUuSWEuc2V0KHQuc3ViYXJyYXkocixyK2kpLG8pO2Vsc2UgZm9yKGw9MDtsPGk7bCsrKWUuSWFbbytsXT10W3IrbF07cmV0dXJuIGUuTWE9TWF0aC5tYXgoZS5NYSxvK2kpLGl9LGxsc2VlazpmdW5jdGlvbihlLHQscil7aWYocj09PTE/dCs9ZS5wb3NpdGlvbjpyPT09MiYmbi5pc0ZpbGUoZS5ub2RlLm1vZGUpJiYodCs9ZS5ub2RlLk1hKSwwPnQpdGhyb3cgbmV3IG4uRXJybm9FcnJvcigyOCk7cmV0dXJuIHR9LGFsbG9jYXRlOmZ1bmN0aW9uKGUsdCxyKXtxLlViKGUubm9kZSx0K3IpLGUubm9kZS5NYT1NYXRoLm1heChlLm5vZGUuTWEsdCtyKX0sbW1hcDpmdW5jdGlvbihlLHQscixpLG8pe2lmKCFuLmlzRmlsZShlLm5vZGUubW9kZSkpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig0Myk7aWYoZT1lLm5vZGUuSWEsbyYyfHxlLmJ1ZmZlciE9PUdlKXtpZigoMDxyfHxyK3Q8ZS5sZW5ndGgpJiYoZS5zdWJhcnJheT9lPWUuc3ViYXJyYXkocixyK3QpOmU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZSxyLHIrdCkpLHI9ITAsdD02NTUzNipNYXRoLmNlaWwodC82NTUzNiksKG89VHQoNjU1MzYsdCkpPyhLLmZpbGwoMCxvLG8rdCksdD1vKTp0PTAsIXQpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig0OCk7Qi5zZXQoZSx0KX1lbHNlIHI9ITEsdD1lLmJ5dGVPZmZzZXQ7cmV0dXJue1VjOnQsbGM6cn19LG1zeW5jOmZ1bmN0aW9uKGUsdCxyLGksbyl7aWYoIW4uaXNGaWxlKGUubm9kZS5tb2RlKSl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDQzKTtyZXR1cm4gbyYyfHxxLnN0cmVhbV9vcHMud3JpdGUoZSx0LDAsaSxyLCExKSwwfX19O2Z1bmN0aW9uIG1yKGUsdCxyKXt2YXIgaT0iYWwgIitlO3ZlKGUsZnVuY3Rpb24obyl7b3x8WignTG9hZGluZyBkYXRhIGZpbGUgIicrZSsnIiBmYWlsZWQgKG5vIGFycmF5QnVmZmVyKS4nKSx0KG5ldyBVaW50OEFycmF5KG8pKSxpJiZMZSgpfSxmdW5jdGlvbigpe2lmKHIpcigpO2Vsc2UgdGhyb3cnTG9hZGluZyBkYXRhIGZpbGUgIicrZSsnIiBmYWlsZWQuJ30pLGkmJnJ0KCl9dmFyIG49e3Jvb3Q6bnVsbCxmYjpbXSxTYjp7fSxzdHJlYW1zOltdLFBjOjEsT2E6bnVsbCxSYjoiLyIsQmI6ITEsYmM6ITAsRXJybm9FcnJvcjpudWxsLHhiOnt9LERjOm51bGwsb2I6MCxsb29rdXBQYXRoOihlLHQ9e30pPT57aWYoZT1oZShuLmN3ZCgpLGUpLCFlKXJldHVybntwYXRoOiIiLG5vZGU6bnVsbH07aWYodD1PYmplY3QuYXNzaWduKHt3YjohMCxKYjowfSx0KSw4PHQuSmIpdGhyb3cgbmV3IG4uRXJybm9FcnJvcigzMik7ZT1pdChlLnNwbGl0KCIvIikuZmlsdGVyKGQ9PiEhZCksITEpO2Zvcih2YXIgcj1uLnJvb3QsaT0iLyIsbz0wO288ZS5sZW5ndGg7bysrKXt2YXIgbD1vPT09ZS5sZW5ndGgtMTtpZihsJiZ0LnBhcmVudClicmVhaztpZihyPW4ubG9va3VwTm9kZShyLGVbb10pLGk9SihpKyIvIitlW29dKSxuLlZhKHIpJiYoIWx8fGwmJnQud2IpJiYocj1yLmViLnJvb3QpLCFsfHx0Lk5hKXtmb3IobD0wO24uWmEoci5tb2RlKTspaWYocj1uLnJlYWRsaW5rKGkpLGk9aGUoVGUoaSkscikscj1uLmxvb2t1cFBhdGgoaSx7SmI6dC5KYisxfSkubm9kZSw0MDxsKyspdGhyb3cgbmV3IG4uRXJybm9FcnJvcigzMil9fXJldHVybntwYXRoOmksbm9kZTpyfX0sU2E6ZT0+e2Zvcih2YXIgdDs7KXtpZihuLmlzUm9vdChlKSlyZXR1cm4gZT1lLm1vdW50LmRjLHQ/ZVtlLmxlbmd0aC0xXSE9PSIvIj9lKyIvIit0OmUrdDplO3Q9dD9lLm5hbWUrIi8iK3Q6ZS5uYW1lLGU9ZS5wYXJlbnR9fSxBYjooZSx0KT0+e2Zvcih2YXIgcj0wLGk9MDtpPHQubGVuZ3RoO2krKylyPShyPDw1KS1yK3QuY2hhckNvZGVBdChpKXwwO3JldHVybihlK3I+Pj4wKSVuLk9hLmxlbmd0aH0sJGI6ZT0+e3ZhciB0PW4uQWIoZS5wYXJlbnQuaWQsZS5uYW1lKTtlLlhhPW4uT2FbdF0sbi5PYVt0XT1lfSxhYzplPT57dmFyIHQ9bi5BYihlLnBhcmVudC5pZCxlLm5hbWUpO2lmKG4uT2FbdF09PT1lKW4uT2FbdF09ZS5YYTtlbHNlIGZvcih0PW4uT2FbdF07dDspe2lmKHQuWGE9PT1lKXt0LlhhPWUuWGE7YnJlYWt9dD10LlhhfX0sbG9va3VwTm9kZTooZSx0KT0+e3ZhciByPW4uTGMoZSk7aWYocil0aHJvdyBuZXcgbi5FcnJub0Vycm9yKHIsZSk7Zm9yKHI9bi5PYVtuLkFiKGUuaWQsdCldO3I7cj1yLlhhKXt2YXIgaT1yLm5hbWU7aWYoci5wYXJlbnQuaWQ9PT1lLmlkJiZpPT09dClyZXR1cm4gcn1yZXR1cm4gbi5sb29rdXAoZSx0KX0sY3JlYXRlTm9kZTooZSx0LHIsaSk9PihlPW5ldyBuLkZTTm9kZShlLHQscixpKSxuLiRiKGUpLGUpLHViOmU9PntuLmFjKGUpfSxpc1Jvb3Q6ZT0+ZT09PWUucGFyZW50LFZhOmU9PiEhZS5lYixpc0ZpbGU6ZT0+KGUmNjE0NDApPT09MzI3NjgsaXNEaXI6ZT0+KGUmNjE0NDApPT09MTYzODQsWmE6ZT0+KGUmNjE0NDApPT09NDA5NjAsamI6ZT0+KGUmNjE0NDApPT09ODE5MixKYzplPT4oZSY2MTQ0MCk9PT0yNDU3Nixpc0ZJRk86ZT0+KGUmNjE0NDApPT09NDA5Nixpc1NvY2tldDplPT4oZSY0OTE1Mik9PT00OTE1MixFYzp7cjowLCJyKyI6Mix3OjU3NywidysiOjU3OCxhOjEwODksImErIjoxMDkwfSxPYzplPT57dmFyIHQ9bi5FY1tlXTtpZih0eXBlb2YgdD09InVuZGVmaW5lZCIpdGhyb3cgRXJyb3IoIlVua25vd24gZmlsZSBvcGVuIG1vZGU6ICIrZSk7cmV0dXJuIHR9LFZiOmU9Pnt2YXIgdD1bInIiLCJ3IiwicnciXVtlJjNdO3JldHVybiBlJjUxMiYmKHQrPSJ3IiksdH0sVWE6KGUsdCk9PntpZihuLmJjKXJldHVybiAwO2lmKCF0LmluY2x1ZGVzKCJyIil8fGUubW9kZSYyOTIpe2lmKHQuaW5jbHVkZXMoInciKSYmIShlLm1vZGUmMTQ2KXx8dC5pbmNsdWRlcygieCIpJiYhKGUubW9kZSY3MykpcmV0dXJuIDJ9ZWxzZSByZXR1cm4gMjtyZXR1cm4gMH0sTGM6ZT0+e3ZhciB0PW4uVWEoZSwieCIpO3JldHVybiB0fHwoZS5ub2RlX29wcy5sb29rdXA/MDoyKX0sRmI6KGUsdCk9Pnt0cnl7cmV0dXJuIG4ubG9va3VwTm9kZShlLHQpLDIwfWNhdGNoe31yZXR1cm4gbi5VYShlLCJ3eCIpfSxrYjooZSx0LHIpPT57dHJ5e3ZhciBpPW4ubG9va3VwTm9kZShlLHQpfWNhdGNoKG8pe3JldHVybiBvLkphfWlmKGU9bi5VYShlLCJ3eCIpKXJldHVybiBlO2lmKHIpe2lmKCFuLmlzRGlyKGkubW9kZSkpcmV0dXJuIDU0O2lmKG4uaXNSb290KGkpfHxuLlNhKGkpPT09bi5jd2QoKSlyZXR1cm4gMTB9ZWxzZSBpZihuLmlzRGlyKGkubW9kZSkpcmV0dXJuIDMxO3JldHVybiAwfSxNYzooZSx0KT0+ZT9uLlphKGUubW9kZSk/MzI6bi5pc0RpcihlLm1vZGUpJiYobi5WYih0KSE9PSJyInx8dCY1MTIpPzMxOm4uVWEoZSxuLlZiKHQpKTo0NCxpYzo0MDk2LFFjOihlPTAsdD1uLmljKT0+e2Zvcig7ZTw9dDtlKyspaWYoIW4uc3RyZWFtc1tlXSlyZXR1cm4gZTt0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDMzKX0sVGE6ZT0+bi5zdHJlYW1zW2VdLFFiOihlLHQscik9PihuLnBifHwobi5wYj1mdW5jdGlvbigpe3RoaXMubmI9e319LG4ucGIucHJvdG90eXBlPXtvYmplY3Q6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGV9LHNldDpmdW5jdGlvbihpKXt0aGlzLm5vZGU9aX19LGZsYWdzOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYi5mbGFnc30sc2V0OmZ1bmN0aW9uKGkpe3RoaXMubmIuZmxhZ3M9aX19LHBvc2l0aW9uOntnZXQgZGQoKXtyZXR1cm4gdGhpcy5uYi5wb3NpdGlvbn0sc2V0OmZ1bmN0aW9uKGkpe3RoaXMubmIucG9zaXRpb249aX19fSksZT1PYmplY3QuYXNzaWduKG5ldyBuLnBiLGUpLHQ9bi5RYyh0LHIpLGUuZmQ9dCxuLnN0cmVhbXNbdF09ZSksd2M6ZT0+e24uc3RyZWFtc1tlXT1udWxsfSx2Yzp7b3BlbjplPT57ZS5zdHJlYW1fb3BzPW4uR2MoZS5ub2RlLnJkZXYpLnN0cmVhbV9vcHMsZS5zdHJlYW1fb3BzLm9wZW4mJmUuc3RyZWFtX29wcy5vcGVuKGUpfSxsbHNlZWs6KCk9Pnt0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDcwKX19LEViOmU9PmU+PjgsamQ6ZT0+ZSYyNTUsV2E6KGUsdCk9PmU8PDh8dCxLYjooZSx0KT0+e24uU2JbZV09e3N0cmVhbV9vcHM6dH19LEdjOmU9Pm4uU2JbZV0sWGI6ZT0+e3ZhciB0PVtdO2ZvcihlPVtlXTtlLmxlbmd0aDspe3ZhciByPWUucG9wKCk7dC5wdXNoKHIpLGUucHVzaC5hcHBseShlLHIuZmIpfXJldHVybiB0fSxmYzooZSx0KT0+e2Z1bmN0aW9uIHIoZCl7cmV0dXJuIG4ub2ItLSx0KGQpfWZ1bmN0aW9uIGkoZCl7aWYoZCl7aWYoIWkuQ2MpcmV0dXJuIGkuQ2M9ITAscihkKX1lbHNlKytsPj1vLmxlbmd0aCYmcihudWxsKX10eXBlb2YgZT09ImZ1bmN0aW9uIiYmKHQ9ZSxlPSExKSxuLm9iKyssMTxuLm9iJiZ0ZSgid2FybmluZzogIituLm9iKyIgRlMuc3luY2ZzIG9wZXJhdGlvbnMgaW4gZmxpZ2h0IGF0IG9uY2UsIHByb2JhYmx5IGp1c3QgZG9pbmcgZXh0cmEgd29yayIpO3ZhciBvPW4uWGIobi5yb290Lm1vdW50KSxsPTA7by5mb3JFYWNoKGQ9PntpZighZC50eXBlLmZjKXJldHVybiBpKG51bGwpO2QudHlwZS5mYyhkLGUsaSl9KX0sbW91bnQ6KGUsdCxyKT0+e3ZhciBpPXI9PT0iLyIsbz0hcjtpZihpJiZuLnJvb3QpdGhyb3cgbmV3IG4uRXJybm9FcnJvcigxMCk7aWYoIWkmJiFvKXt2YXIgbD1uLmxvb2t1cFBhdGgocix7d2I6ITF9KTtpZihyPWwucGF0aCxsPWwubm9kZSxuLlZhKGwpKXRocm93IG5ldyBuLkVycm5vRXJyb3IoMTApO2lmKCFuLmlzRGlyKGwubW9kZSkpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig1NCl9cmV0dXJuIHQ9e3R5cGU6ZSxtZDp0LGRjOnIsZmI6W119LGU9ZS5tb3VudCh0KSxlLm1vdW50PXQsdC5yb290PWUsaT9uLnJvb3Q9ZTpsJiYobC5lYj10LGwubW91bnQmJmwubW91bnQuZmIucHVzaCh0KSksZX0scGQ6ZT0+e2lmKGU9bi5sb29rdXBQYXRoKGUse3diOiExfSksIW4uVmEoZS5ub2RlKSl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDI4KTtlPWUubm9kZTt2YXIgdD1lLmViLHI9bi5YYih0KTtPYmplY3Qua2V5cyhuLk9hKS5mb3JFYWNoKGk9Pntmb3IoaT1uLk9hW2ldO2k7KXt2YXIgbz1pLlhhO3IuaW5jbHVkZXMoaS5tb3VudCkmJm4udWIoaSksaT1vfX0pLGUuZWI9bnVsbCxlLm1vdW50LmZiLnNwbGljZShlLm1vdW50LmZiLmluZGV4T2YodCksMSl9LGxvb2t1cDooZSx0KT0+ZS5ub2RlX29wcy5sb29rdXAoZSx0KSxta25vZDooZSx0LHIpPT57dmFyIGk9bi5sb29rdXBQYXRoKGUse3BhcmVudDohMH0pLm5vZGU7aWYoZT1uZShlKSwhZXx8ZT09PSIuInx8ZT09PSIuLiIpdGhyb3cgbmV3IG4uRXJybm9FcnJvcigyOCk7dmFyIG89bi5GYihpLGUpO2lmKG8pdGhyb3cgbmV3IG4uRXJybm9FcnJvcihvKTtpZighaS5ub2RlX29wcy5ta25vZCl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDYzKTtyZXR1cm4gaS5ub2RlX29wcy5ta25vZChpLGUsdCxyKX0sY3JlYXRlOihlLHQpPT5uLm1rbm9kKGUsKHQhPT12b2lkIDA/dDo0MzgpJjQwOTV8MzI3NjgsMCksbWtkaXI6KGUsdCk9Pm4ubWtub2QoZSwodCE9PXZvaWQgMD90OjUxMSkmMTAyM3wxNjM4NCwwKSxrZDooZSx0KT0+e2U9ZS5zcGxpdCgiLyIpO2Zvcih2YXIgcj0iIixpPTA7aTxlLmxlbmd0aDsrK2kpaWYoZVtpXSl7cis9Ii8iK2VbaV07dHJ5e24ubWtkaXIocix0KX1jYXRjaChvKXtpZihvLkphIT0yMCl0aHJvdyBvfX19LGxiOihlLHQscik9Pih0eXBlb2Ygcj09InVuZGVmaW5lZCImJihyPXQsdD00MzgpLG4ubWtub2QoZSx0fDgxOTIscikpLHN5bWxpbms6KGUsdCk9PntpZighaGUoZSkpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig0NCk7dmFyIHI9bi5sb29rdXBQYXRoKHQse3BhcmVudDohMH0pLm5vZGU7aWYoIXIpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig0NCk7dD1uZSh0KTt2YXIgaT1uLkZiKHIsdCk7aWYoaSl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKGkpO2lmKCFyLm5vZGVfb3BzLnN5bWxpbmspdGhyb3cgbmV3IG4uRXJybm9FcnJvcig2Myk7cmV0dXJuIHIubm9kZV9vcHMuc3ltbGluayhyLHQsZSl9LHJlbmFtZTooZSx0KT0+e3ZhciByPVRlKGUpLGk9VGUodCksbz1uZShlKSxsPW5lKHQpLGQ9bi5sb29rdXBQYXRoKGUse3BhcmVudDohMH0pLG09ZC5ub2RlO2lmKGQ9bi5sb29rdXBQYXRoKHQse3BhcmVudDohMH0pLGQ9ZC5ub2RlLCFtfHwhZCl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDQ0KTtpZihtLm1vdW50IT09ZC5tb3VudCl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDc1KTt2YXIgZz1uLmxvb2t1cE5vZGUobSxvKTtpZihlPUZ0KGUsaSksZS5jaGFyQXQoMCkhPT0iLiIpdGhyb3cgbmV3IG4uRXJybm9FcnJvcigyOCk7aWYoZT1GdCh0LHIpLGUuY2hhckF0KDApIT09Ii4iKXRocm93IG5ldyBuLkVycm5vRXJyb3IoNTUpO3RyeXt2YXIgdz1uLmxvb2t1cE5vZGUoZCxsKX1jYXRjaHt9aWYoZyE9PXcpe2lmKHQ9bi5pc0RpcihnLm1vZGUpLG89bi5rYihtLG8sdCkpdGhyb3cgbmV3IG4uRXJybm9FcnJvcihvKTtpZihvPXc/bi5rYihkLGwsdCk6bi5GYihkLGwpKXRocm93IG5ldyBuLkVycm5vRXJyb3Iobyk7aWYoIW0ubm9kZV9vcHMucmVuYW1lKXRocm93IG5ldyBuLkVycm5vRXJyb3IoNjMpO2lmKG4uVmEoZyl8fHcmJm4uVmEodykpdGhyb3cgbmV3IG4uRXJybm9FcnJvcigxMCk7aWYoZCE9PW0mJihvPW4uVWEobSwidyIpKSl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKG8pO24uYWMoZyk7dHJ5e20ubm9kZV9vcHMucmVuYW1lKGcsZCxsKX1jYXRjaChfKXt0aHJvdyBffWZpbmFsbHl7bi4kYihnKX19fSxybWRpcjplPT57dmFyIHQ9bi5sb29rdXBQYXRoKGUse3BhcmVudDohMH0pLm5vZGU7ZT1uZShlKTt2YXIgcj1uLmxvb2t1cE5vZGUodCxlKSxpPW4ua2IodCxlLCEwKTtpZihpKXRocm93IG5ldyBuLkVycm5vRXJyb3IoaSk7aWYoIXQubm9kZV9vcHMucm1kaXIpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig2Myk7aWYobi5WYShyKSl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDEwKTt0Lm5vZGVfb3BzLnJtZGlyKHQsZSksbi51YihyKX0scmVhZGRpcjplPT57aWYoZT1uLmxvb2t1cFBhdGgoZSx7TmE6ITB9KS5ub2RlLCFlLm5vZGVfb3BzLnJlYWRkaXIpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig1NCk7cmV0dXJuIGUubm9kZV9vcHMucmVhZGRpcihlKX0sdW5saW5rOmU9Pnt2YXIgdD1uLmxvb2t1cFBhdGgoZSx7cGFyZW50OiEwfSkubm9kZTtpZighdCl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDQ0KTtlPW5lKGUpO3ZhciByPW4ubG9va3VwTm9kZSh0LGUpLGk9bi5rYih0LGUsITEpO2lmKGkpdGhyb3cgbmV3IG4uRXJybm9FcnJvcihpKTtpZighdC5ub2RlX29wcy51bmxpbmspdGhyb3cgbmV3IG4uRXJybm9FcnJvcig2Myk7aWYobi5WYShyKSl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDEwKTt0Lm5vZGVfb3BzLnVubGluayh0LGUpLG4udWIocil9LHJlYWRsaW5rOmU9PntpZihlPW4ubG9va3VwUGF0aChlKS5ub2RlLCFlKXRocm93IG5ldyBuLkVycm5vRXJyb3IoNDQpO2lmKCFlLm5vZGVfb3BzLnJlYWRsaW5rKXRocm93IG5ldyBuLkVycm5vRXJyb3IoMjgpO3JldHVybiBoZShuLlNhKGUucGFyZW50KSxlLm5vZGVfb3BzLnJlYWRsaW5rKGUpKX0sc3RhdDooZSx0KT0+e2lmKGU9bi5sb29rdXBQYXRoKGUse05hOiF0fSkubm9kZSwhZSl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDQ0KTtpZighZS5ub2RlX29wcy5nZXRhdHRyKXRocm93IG5ldyBuLkVycm5vRXJyb3IoNjMpO3JldHVybiBlLm5vZGVfb3BzLmdldGF0dHIoZSl9LGxzdGF0OmU9Pm4uc3RhdChlLCEwKSxjaG1vZDooZSx0LHIpPT57aWYoZT10eXBlb2YgZT09InN0cmluZyI/bi5sb29rdXBQYXRoKGUse05hOiFyfSkubm9kZTplLCFlLm5vZGVfb3BzLnNldGF0dHIpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig2Myk7ZS5ub2RlX29wcy5zZXRhdHRyKGUse21vZGU6dCY0MDk1fGUubW9kZSYtNDA5Nix0aW1lc3RhbXA6RGF0ZS5ub3coKX0pfSxsY2htb2Q6KGUsdCk9PntuLmNobW9kKGUsdCwhMCl9LGZjaG1vZDooZSx0KT0+e2lmKGU9bi5UYShlKSwhZSl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDgpO24uY2htb2QoZS5ub2RlLHQpfSxjaG93bjooZSx0LHIsaSk9PntpZihlPXR5cGVvZiBlPT0ic3RyaW5nIj9uLmxvb2t1cFBhdGgoZSx7TmE6IWl9KS5ub2RlOmUsIWUubm9kZV9vcHMuc2V0YXR0cil0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDYzKTtlLm5vZGVfb3BzLnNldGF0dHIoZSx7dGltZXN0YW1wOkRhdGUubm93KCl9KX0sbGNob3duOihlLHQscik9PntuLmNob3duKGUsdCxyLCEwKX0sZmNob3duOihlLHQscik9PntpZihlPW4uVGEoZSksIWUpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig4KTtuLmNob3duKGUubm9kZSx0LHIpfSx0cnVuY2F0ZTooZSx0KT0+e2lmKDA+dCl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDI4KTtpZihlPXR5cGVvZiBlPT0ic3RyaW5nIj9uLmxvb2t1cFBhdGgoZSx7TmE6ITB9KS5ub2RlOmUsIWUubm9kZV9vcHMuc2V0YXR0cil0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDYzKTtpZihuLmlzRGlyKGUubW9kZSkpdGhyb3cgbmV3IG4uRXJybm9FcnJvcigzMSk7aWYoIW4uaXNGaWxlKGUubW9kZSkpdGhyb3cgbmV3IG4uRXJybm9FcnJvcigyOCk7dmFyIHI9bi5VYShlLCJ3Iik7aWYocil0aHJvdyBuZXcgbi5FcnJub0Vycm9yKHIpO2Uubm9kZV9vcHMuc2V0YXR0cihlLHtzaXplOnQsdGltZXN0YW1wOkRhdGUubm93KCl9KX0sRmM6KGUsdCk9PntpZihlPW4uVGEoZSksIWUpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig4KTtpZigoZS5mbGFncyYyMDk3MTU1KT09PTApdGhyb3cgbmV3IG4uRXJybm9FcnJvcigyOCk7bi50cnVuY2F0ZShlLm5vZGUsdCl9LFljOihlLHQscik9PntlPW4ubG9va3VwUGF0aChlLHtOYTohMH0pLm5vZGUsZS5ub2RlX29wcy5zZXRhdHRyKGUse3RpbWVzdGFtcDpNYXRoLm1heCh0LHIpfSl9LG9wZW46KGUsdCxyKT0+e2lmKGU9PT0iIil0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDQ0KTtpZih0PXR5cGVvZiB0PT0ic3RyaW5nIj9uLk9jKHQpOnQscj10JjY0Pyh0eXBlb2Ygcj09InVuZGVmaW5lZCI/NDM4OnIpJjQwOTV8MzI3Njg6MCx0eXBlb2YgZT09Im9iamVjdCIpdmFyIGk9ZTtlbHNle2U9SihlKTt0cnl7aT1uLmxvb2t1cFBhdGgoZSx7TmE6ISh0JjEzMTA3Mil9KS5ub2RlfWNhdGNoe319dmFyIG89ITE7aWYodCY2NClpZihpKXtpZih0JjEyOCl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDIwKX1lbHNlIGk9bi5ta25vZChlLHIsMCksbz0hMDtpZighaSl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDQ0KTtpZihuLmpiKGkubW9kZSkmJih0Jj0tNTEzKSx0JjY1NTM2JiYhbi5pc0RpcihpLm1vZGUpKXRocm93IG5ldyBuLkVycm5vRXJyb3IoNTQpO2lmKCFvJiYocj1uLk1jKGksdCkpKXRocm93IG5ldyBuLkVycm5vRXJyb3Iocik7cmV0dXJuIHQmNTEyJiYhbyYmbi50cnVuY2F0ZShpLDApLHQmPS0xMzE3MTMsaT1uLlFiKHtub2RlOmkscGF0aDpuLlNhKGkpLGZsYWdzOnQsc2Vla2FibGU6ITAscG9zaXRpb246MCxzdHJlYW1fb3BzOmkuc3RyZWFtX29wcyxYYzpbXSxlcnJvcjohMX0pLGkuc3RyZWFtX29wcy5vcGVuJiZpLnN0cmVhbV9vcHMub3BlbihpKSwhcy5sb2dSZWFkRmlsZXN8fHQmMXx8KG4uSWJ8fChuLkliPXt9KSxlIGluIG4uSWJ8fChuLkliW2VdPTEpKSxpfSxjbG9zZTplPT57aWYobi5jYihlKSl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDgpO2UuemImJihlLnpiPW51bGwpO3RyeXtlLnN0cmVhbV9vcHMuY2xvc2UmJmUuc3RyZWFtX29wcy5jbG9zZShlKX1jYXRjaCh0KXt0aHJvdyB0fWZpbmFsbHl7bi53YyhlLmZkKX1lLmZkPW51bGx9LGNiOmU9PmUuZmQ9PT1udWxsLGxsc2VlazooZSx0LHIpPT57aWYobi5jYihlKSl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDgpO2lmKCFlLnNlZWthYmxlfHwhZS5zdHJlYW1fb3BzLmxsc2Vlayl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDcwKTtpZihyIT0wJiZyIT0xJiZyIT0yKXRocm93IG5ldyBuLkVycm5vRXJyb3IoMjgpO3JldHVybiBlLnBvc2l0aW9uPWUuc3RyZWFtX29wcy5sbHNlZWsoZSx0LHIpLGUuWGM9W10sZS5wb3NpdGlvbn0scmVhZDooZSx0LHIsaSxvKT0+e2lmKDA+aXx8MD5vKXRocm93IG5ldyBuLkVycm5vRXJyb3IoMjgpO2lmKG4uY2IoZSkpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig4KTtpZigoZS5mbGFncyYyMDk3MTU1KT09PTEpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig4KTtpZihuLmlzRGlyKGUubm9kZS5tb2RlKSl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDMxKTtpZighZS5zdHJlYW1fb3BzLnJlYWQpdGhyb3cgbmV3IG4uRXJybm9FcnJvcigyOCk7dmFyIGw9dHlwZW9mIG8hPSJ1bmRlZmluZWQiO2lmKCFsKW89ZS5wb3NpdGlvbjtlbHNlIGlmKCFlLnNlZWthYmxlKXRocm93IG5ldyBuLkVycm5vRXJyb3IoNzApO3JldHVybiB0PWUuc3RyZWFtX29wcy5yZWFkKGUsdCxyLGksbyksbHx8KGUucG9zaXRpb24rPXQpLHR9LHdyaXRlOihlLHQscixpLG8sbCk9PntpZigwPml8fDA+byl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDI4KTtpZihuLmNiKGUpKXRocm93IG5ldyBuLkVycm5vRXJyb3IoOCk7aWYoKGUuZmxhZ3MmMjA5NzE1NSk9PT0wKXRocm93IG5ldyBuLkVycm5vRXJyb3IoOCk7aWYobi5pc0RpcihlLm5vZGUubW9kZSkpdGhyb3cgbmV3IG4uRXJybm9FcnJvcigzMSk7aWYoIWUuc3RyZWFtX29wcy53cml0ZSl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDI4KTtlLnNlZWthYmxlJiZlLmZsYWdzJjEwMjQmJm4ubGxzZWVrKGUsMCwyKTt2YXIgZD10eXBlb2YgbyE9InVuZGVmaW5lZCI7aWYoIWQpbz1lLnBvc2l0aW9uO2Vsc2UgaWYoIWUuc2Vla2FibGUpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig3MCk7cmV0dXJuIHQ9ZS5zdHJlYW1fb3BzLndyaXRlKGUsdCxyLGksbyxsKSxkfHwoZS5wb3NpdGlvbis9dCksdH0sYWxsb2NhdGU6KGUsdCxyKT0+e2lmKG4uY2IoZSkpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig4KTtpZigwPnR8fDA+PXIpdGhyb3cgbmV3IG4uRXJybm9FcnJvcigyOCk7aWYoKGUuZmxhZ3MmMjA5NzE1NSk9PT0wKXRocm93IG5ldyBuLkVycm5vRXJyb3IoOCk7aWYoIW4uaXNGaWxlKGUubm9kZS5tb2RlKSYmIW4uaXNEaXIoZS5ub2RlLm1vZGUpKXRocm93IG5ldyBuLkVycm5vRXJyb3IoNDMpO2lmKCFlLnN0cmVhbV9vcHMuYWxsb2NhdGUpdGhyb3cgbmV3IG4uRXJybm9FcnJvcigxMzgpO2Uuc3RyZWFtX29wcy5hbGxvY2F0ZShlLHQscil9LG1tYXA6KGUsdCxyLGksbyk9PntpZigoaSYyKSE9PTAmJihvJjIpPT09MCYmKGUuZmxhZ3MmMjA5NzE1NSkhPT0yKXRocm93IG5ldyBuLkVycm5vRXJyb3IoMik7aWYoKGUuZmxhZ3MmMjA5NzE1NSk9PT0xKXRocm93IG5ldyBuLkVycm5vRXJyb3IoMik7aWYoIWUuc3RyZWFtX29wcy5tbWFwKXRocm93IG5ldyBuLkVycm5vRXJyb3IoNDMpO3JldHVybiBlLnN0cmVhbV9vcHMubW1hcChlLHQscixpLG8pfSxtc3luYzooZSx0LHIsaSxvKT0+ZSYmZS5zdHJlYW1fb3BzLm1zeW5jP2Uuc3RyZWFtX29wcy5tc3luYyhlLHQscixpLG8pOjAsbGQ6KCk9PjAsY2M6KGUsdCxyKT0+e2lmKCFlLnN0cmVhbV9vcHMuY2MpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig1OSk7cmV0dXJuIGUuc3RyZWFtX29wcy5jYyhlLHQscil9LHJlYWRGaWxlOihlLHQ9e30pPT57aWYodC5mbGFncz10LmZsYWdzfHwwLHQuZW5jb2Rpbmc9dC5lbmNvZGluZ3x8ImJpbmFyeSIsdC5lbmNvZGluZyE9PSJ1dGY4IiYmdC5lbmNvZGluZyE9PSJiaW5hcnkiKXRocm93IEVycm9yKCdJbnZhbGlkIGVuY29kaW5nIHR5cGUgIicrdC5lbmNvZGluZysnIicpO3ZhciByLGk9bi5vcGVuKGUsdC5mbGFncyk7ZT1uLnN0YXQoZSkuc2l6ZTt2YXIgbz1uZXcgVWludDhBcnJheShlKTtyZXR1cm4gbi5yZWFkKGksbywwLGUsMCksdC5lbmNvZGluZz09PSJ1dGY4Ij9yPW1lKG8sMCk6dC5lbmNvZGluZz09PSJiaW5hcnkiJiYocj1vKSxuLmNsb3NlKGkpLHJ9LHdyaXRlRmlsZTooZSx0LHI9e30pPT57aWYoci5mbGFncz1yLmZsYWdzfHw1NzcsZT1uLm9wZW4oZSxyLmZsYWdzLHIubW9kZSksdHlwZW9mIHQ9PSJzdHJpbmciKXt2YXIgaT1uZXcgVWludDhBcnJheShmZSh0KSsxKTt0PXJlKHQsaSwwLGkubGVuZ3RoKSxuLndyaXRlKGUsaSwwLHQsdm9pZCAwLHIudWMpfWVsc2UgaWYoQXJyYXlCdWZmZXIuaXNWaWV3KHQpKW4ud3JpdGUoZSx0LDAsdC5ieXRlTGVuZ3RoLHZvaWQgMCxyLnVjKTtlbHNlIHRocm93IEVycm9yKCJVbnN1cHBvcnRlZCBkYXRhIHR5cGUiKTtuLmNsb3NlKGUpfSxjd2Q6KCk9Pm4uUmIsY2hkaXI6ZT0+e2lmKGU9bi5sb29rdXBQYXRoKGUse05hOiEwfSksZS5ub2RlPT09bnVsbCl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDQ0KTtpZighbi5pc0RpcihlLm5vZGUubW9kZSkpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig1NCk7dmFyIHQ9bi5VYShlLm5vZGUsIngiKTtpZih0KXRocm93IG5ldyBuLkVycm5vRXJyb3IodCk7bi5SYj1lLnBhdGh9LHljOigpPT57bi5ta2RpcigiL3RtcCIpLG4ubWtkaXIoIi9ob21lIiksbi5ta2RpcigiL2hvbWUvd2ViX3VzZXIiKX0seGM6KCk9PntuLm1rZGlyKCIvZGV2Iiksbi5LYihuLldhKDEsMykse3JlYWQ6KCk9PjAsd3JpdGU6KHQscixpLG8pPT5vfSksbi5sYigiL2Rldi9udWxsIixuLldhKDEsMykpLFJ0KG4uV2EoNSwwKSxkciksUnQobi5XYSg2LDApLHByKSxuLmxiKCIvZGV2L3R0eSIsbi5XYSg1LDApKSxuLmxiKCIvZGV2L3R0eTEiLG4uV2EoNiwwKSk7dmFyIGU9Y3IoKTtuLlFhKCIvZGV2IiwicmFuZG9tIixlKSxuLlFhKCIvZGV2IiwidXJhbmRvbSIsZSksbi5ta2RpcigiL2Rldi9zaG0iKSxuLm1rZGlyKCIvZGV2L3NobS90bXAiKX0sQWM6KCk9PntuLm1rZGlyKCIvcHJvYyIpO3ZhciBlPW4ubWtkaXIoIi9wcm9jL3NlbGYiKTtuLm1rZGlyKCIvcHJvYy9zZWxmL2ZkIiksbi5tb3VudCh7bW91bnQ6KCk9Pnt2YXIgdD1uLmNyZWF0ZU5vZGUoZSwiZmQiLDE2ODk1LDczKTtyZXR1cm4gdC5ub2RlX29wcz17bG9va3VwOihyLGkpPT57dmFyIG89bi5UYSgraSk7aWYoIW8pdGhyb3cgbmV3IG4uRXJybm9FcnJvcig4KTtyZXR1cm4gcj17cGFyZW50Om51bGwsbW91bnQ6e2RjOiJmYWtlIn0sbm9kZV9vcHM6e3JlYWRsaW5rOigpPT5vLnBhdGh9fSxyLnBhcmVudD1yfX0sdH19LHt9LCIvcHJvYy9zZWxmL2ZkIil9LEJjOigpPT57cy5zdGRpbj9uLlFhKCIvZGV2Iiwic3RkaW4iLHMuc3RkaW4pOm4uc3ltbGluaygiL2Rldi90dHkiLCIvZGV2L3N0ZGluIikscy5zdGRvdXQ/bi5RYSgiL2RldiIsInN0ZG91dCIsbnVsbCxzLnN0ZG91dCk6bi5zeW1saW5rKCIvZGV2L3R0eSIsIi9kZXYvc3Rkb3V0Iikscy5zdGRlcnI/bi5RYSgiL2RldiIsInN0ZGVyciIsbnVsbCxzLnN0ZGVycik6bi5zeW1saW5rKCIvZGV2L3R0eTEiLCIvZGV2L3N0ZGVyciIpLG4ub3BlbigiL2Rldi9zdGRpbiIsMCksbi5vcGVuKCIvZGV2L3N0ZG91dCIsMSksbi5vcGVuKCIvZGV2L3N0ZGVyciIsMSl9LFRiOigpPT57bi5FcnJub0Vycm9yfHwobi5FcnJub0Vycm9yPWZ1bmN0aW9uKGUsdCl7dGhpcy5ub2RlPXQsdGhpcy5XYz1mdW5jdGlvbihyKXt0aGlzLkphPXJ9LHRoaXMuV2MoZSksdGhpcy5tZXNzYWdlPSJGUyBlcnJvciJ9LG4uRXJybm9FcnJvci5wcm90b3R5cGU9RXJyb3IoKSxuLkVycm5vRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yPW4uRXJybm9FcnJvcixbNDRdLmZvckVhY2goZT0+e24ueGJbZV09bmV3IG4uRXJybm9FcnJvcihlKSxuLnhiW2VdLnN0YWNrPSI8Z2VuZXJpYyBlcnJvciwgbm8gc3RhY2s+In0pKX0sZWM6KCk9PntuLlRiKCksbi5PYT1BcnJheSg0MDk2KSxuLm1vdW50KHEse30sIi8iKSxuLnljKCksbi54YygpLG4uQWMoKSxuLkRjPXtNRU1GUzpxfX0saWI6KGUsdCxyKT0+e24uaWIuQmI9ITAsbi5UYigpLHMuc3RkaW49ZXx8cy5zdGRpbixzLnN0ZG91dD10fHxzLnN0ZG91dCxzLnN0ZGVycj1yfHxzLnN0ZGVycixuLkJjKCl9LG5kOigpPT57bi5pYi5CYj0hMTtmb3IodmFyIGU9MDtlPG4uc3RyZWFtcy5sZW5ndGg7ZSsrKXt2YXIgdD1uLnN0cmVhbXNbZV07dCYmbi5jbG9zZSh0KX19LHliOihlLHQpPT57dmFyIHI9MDtyZXR1cm4gZSYmKHJ8PTM2NSksdCYmKHJ8PTE0Nikscn0sYmQ6KGUsdCk9PihlPW4ucmIoZSx0KSxlLmV4aXN0cz9lLm9iamVjdDpudWxsKSxyYjooZSx0KT0+e3RyeXt2YXIgcj1uLmxvb2t1cFBhdGgoZSx7TmE6IXR9KTtlPXIucGF0aH1jYXRjaHt9dmFyIGk9e2lzUm9vdDohMSxleGlzdHM6ITEsZXJyb3I6MCxuYW1lOm51bGwscGF0aDpudWxsLG9iamVjdDpudWxsLFJjOiExLFRjOm51bGwsU2M6bnVsbH07dHJ5e3I9bi5sb29rdXBQYXRoKGUse3BhcmVudDohMH0pLGkuUmM9ITAsaS5UYz1yLnBhdGgsaS5TYz1yLm5vZGUsaS5uYW1lPW5lKGUpLHI9bi5sb29rdXBQYXRoKGUse05hOiF0fSksaS5leGlzdHM9ITAsaS5wYXRoPXIucGF0aCxpLm9iamVjdD1yLm5vZGUsaS5uYW1lPXIubm9kZS5uYW1lLGkuaXNSb290PXIucGF0aD09PSIvIn1jYXRjaChvKXtpLmVycm9yPW8uSmF9cmV0dXJuIGl9LCRjOihlLHQpPT57Zm9yKGU9dHlwZW9mIGU9PSJzdHJpbmciP2U6bi5TYShlKSx0PXQuc3BsaXQoIi8iKS5yZXZlcnNlKCk7dC5sZW5ndGg7KXt2YXIgcj10LnBvcCgpO2lmKHIpe3ZhciBpPUooZSsiLyIrcik7dHJ5e24ubWtkaXIoaSl9Y2F0Y2h7fWU9aX19cmV0dXJuIGl9LHpjOihlLHQscixpLG8pPT4oZT10eXBlb2YgZT09InN0cmluZyI/ZTpuLlNhKGUpLHQ9SihlKyIvIit0KSxuLmNyZWF0ZSh0LG4ueWIoaSxvKSkpLHRiOihlLHQscixpLG8sbCk9Pnt2YXIgZD10O2lmKGUmJihlPXR5cGVvZiBlPT0ic3RyaW5nIj9lOm4uU2EoZSksZD10P0ooZSsiLyIrdCk6ZSksZT1uLnliKGksbyksZD1uLmNyZWF0ZShkLGUpLHIpe2lmKHR5cGVvZiByPT0ic3RyaW5nIil7Zm9yKHQ9QXJyYXkoci5sZW5ndGgpLGk9MCxvPXIubGVuZ3RoO2k8bzsrK2kpdFtpXT1yLmNoYXJDb2RlQXQoaSk7cj10fW4uY2htb2QoZCxlfDE0NiksdD1uLm9wZW4oZCw1NzcpLG4ud3JpdGUodCxyLDAsci5sZW5ndGgsMCxsKSxuLmNsb3NlKHQpLG4uY2htb2QoZCxlKX1yZXR1cm4gZH0sUWE6KGUsdCxyLGkpPT57ZT1mcih0eXBlb2YgZT09InN0cmluZyI/ZTpuLlNhKGUpLHQpLHQ9bi55YighIXIsISFpKSxuLlFhLkVifHwobi5RYS5FYj02NCk7dmFyIG89bi5XYShuLlFhLkViKyssMCk7cmV0dXJuIG4uS2Iobyx7b3BlbjpsPT57bC5zZWVrYWJsZT0hMX0sY2xvc2U6KCk9PntpJiZpLmJ1ZmZlciYmaS5idWZmZXIubGVuZ3RoJiZpKDEwKX0scmVhZDoobCxkLG0sZyk9Pntmb3IodmFyIHc9MCxfPTA7XzxnO18rKyl7dHJ5e3ZhciBEPXIoKX1jYXRjaHt0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDI5KX1pZihEPT09dm9pZCAwJiZ3PT09MCl0aHJvdyBuZXcgbi5FcnJub0Vycm9yKDYpO2lmKEQ9PW51bGwpYnJlYWs7dysrLGRbbStfXT1EfXJldHVybiB3JiYobC5ub2RlLnRpbWVzdGFtcD1EYXRlLm5vdygpKSx3fSx3cml0ZToobCxkLG0sZyk9Pntmb3IodmFyIHc9MDt3PGc7dysrKXRyeXtpKGRbbSt3XSl9Y2F0Y2h7dGhyb3cgbmV3IG4uRXJybm9FcnJvcigyOSl9cmV0dXJuIGcmJihsLm5vZGUudGltZXN0YW1wPURhdGUubm93KCkpLHd9fSksbi5sYihlLHQsbyl9LFdiOmU9PntpZihlLkNifHxlLktjfHxlLmxpbmt8fGUuSWEpcmV0dXJuITA7aWYodHlwZW9mIFhNTEh0dHBSZXF1ZXN0IT0idW5kZWZpbmVkIil0aHJvdyBFcnJvcigiTGF6eSBsb2FkaW5nIHNob3VsZCBoYXZlIGJlZW4gcGVyZm9ybWVkIChjb250ZW50cyBzZXQpIGluIGNyZWF0ZUxhenlGaWxlLCBidXQgaXQgd2FzIG5vdC4gTGF6eSBsb2FkaW5nIG9ubHkgd29ya3MgaW4gd2ViIHdvcmtlcnMuIFVzZSAtLWVtYmVkLWZpbGUgb3IgLS1wcmVsb2FkLWZpbGUgaW4gZW1jYyBvbiB0aGUgbWFpbiB0aHJlYWQuIik7aWYoRWUpdHJ5e2UuSWE9T2UoRWUoZS51cmwpLCEwKSxlLk1hPWUuSWEubGVuZ3RofWNhdGNoe3Rocm93IG5ldyBuLkVycm5vRXJyb3IoMjkpfWVsc2UgdGhyb3cgRXJyb3IoIkNhbm5vdCBsb2FkIHdpdGhvdXQgcmVhZCgpIG9yIFhNTEh0dHBSZXF1ZXN0LiIpfSxaYzooZSx0LHIsaSxvKT0+e2Z1bmN0aW9uIGwoKXt0aGlzLkRiPSExLHRoaXMuaGI9W119aWYobC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHcpe2lmKCEodz50aGlzLmxlbmd0aC0xfHwwPncpKXt2YXIgXz13JXRoaXMuY2h1bmtTaXplO3JldHVybiB0aGlzLlpiKHcvdGhpcy5jaHVua1NpemV8MClbX119fSxsLnByb3RvdHlwZS5oYz1mdW5jdGlvbih3KXt0aGlzLlpiPXd9LGwucHJvdG90eXBlLk9iPWZ1bmN0aW9uKCl7dmFyIHc9bmV3IFhNTEh0dHBSZXF1ZXN0O2lmKHcub3BlbigiSEVBRCIsciwhMSksdy5zZW5kKG51bGwpLCEoMjAwPD13LnN0YXR1cyYmMzAwPncuc3RhdHVzfHx3LnN0YXR1cz09PTMwNCkpdGhyb3cgRXJyb3IoIkNvdWxkbid0IGxvYWQgIityKyIuIFN0YXR1czogIit3LnN0YXR1cyk7dmFyIF89TnVtYmVyKHcuZ2V0UmVzcG9uc2VIZWFkZXIoIkNvbnRlbnQtbGVuZ3RoIikpLEQsTj0oRD13LmdldFJlc3BvbnNlSGVhZGVyKCJBY2NlcHQtUmFuZ2VzIikpJiZEPT09ImJ5dGVzIjt3PShEPXcuZ2V0UmVzcG9uc2VIZWFkZXIoIkNvbnRlbnQtRW5jb2RpbmciKSkmJkQ9PT0iZ3ppcCI7dmFyIFQ9MTA0ODU3NjtOfHwoVD1fKTt2YXIgUD10aGlzO1AuaGMoc2U9Pnt2YXIgcGU9c2UqVCxhZT0oc2UrMSkqVC0xO2lmKGFlPU1hdGgubWluKGFlLF8tMSksdHlwZW9mIFAuaGJbc2VdPT0idW5kZWZpbmVkIil7dmFyIGx0PVAuaGI7aWYocGU+YWUpdGhyb3cgRXJyb3IoImludmFsaWQgcmFuZ2UgKCIrcGUrIiwgIithZSsiKSBvciBubyBieXRlcyByZXF1ZXN0ZWQhIik7aWYoYWU+Xy0xKXRocm93IEVycm9yKCJvbmx5ICIrXysiIGJ5dGVzIGF2YWlsYWJsZSEgcHJvZ3JhbW1lciBlcnJvciEiKTt2YXIgVT1uZXcgWE1MSHR0cFJlcXVlc3Q7aWYoVS5vcGVuKCJHRVQiLHIsITEpLF8hPT1UJiZVLnNldFJlcXVlc3RIZWFkZXIoIlJhbmdlIiwiYnl0ZXM9IitwZSsiLSIrYWUpLFUucmVzcG9uc2VUeXBlPSJhcnJheWJ1ZmZlciIsVS5vdmVycmlkZU1pbWVUeXBlJiZVLm92ZXJyaWRlTWltZVR5cGUoInRleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQiKSxVLnNlbmQobnVsbCksISgyMDA8PVUuc3RhdHVzJiYzMDA+VS5zdGF0dXN8fFUuc3RhdHVzPT09MzA0KSl0aHJvdyBFcnJvcigiQ291bGRuJ3QgbG9hZCAiK3IrIi4gU3RhdHVzOiAiK1Uuc3RhdHVzKTtwZT1VLnJlc3BvbnNlIT09dm9pZCAwP25ldyBVaW50OEFycmF5KFUucmVzcG9uc2V8fFtdKTpPZShVLnJlc3BvbnNlVGV4dHx8IiIsITApLGx0W3NlXT1wZX1pZih0eXBlb2YgUC5oYltzZV09PSJ1bmRlZmluZWQiKXRocm93IEVycm9yKCJkb1hIUiBmYWlsZWQhIik7cmV0dXJuIFAuaGJbc2VdfSksKHd8fCFfKSYmKFQ9Xz0xLFQ9Xz10aGlzLlpiKDApLmxlbmd0aCxSZSgiTGF6eUZpbGVzIG9uIGd6aXAgZm9yY2VzIGRvd25sb2FkIG9mIHRoZSB3aG9sZSBmaWxlIHdoZW4gbGVuZ3RoIGlzIGFjY2Vzc2VkIikpLHRoaXMua2M9Xyx0aGlzLmpjPVQsdGhpcy5EYj0hMH0sdHlwZW9mIFhNTEh0dHBSZXF1ZXN0IT0idW5kZWZpbmVkIil7aWYoIVIpdGhyb3ciQ2Fubm90IGRvIHN5bmNocm9ub3VzIGJpbmFyeSBYSFJzIG91dHNpZGUgd2Vid29ya2VycyBpbiBtb2Rlcm4gYnJvd3NlcnMuIFVzZSAtLWVtYmVkLWZpbGUgb3IgLS1wcmVsb2FkLWZpbGUgaW4gZW1jYyI7dmFyIGQ9bmV3IGw7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZCx7bGVuZ3RoOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5EYnx8dGhpcy5PYigpLHRoaXMua2N9fSxjaHVua1NpemU6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLkRifHx0aGlzLk9iKCksdGhpcy5qY319fSksZD17Q2I6ITEsSWE6ZH19ZWxzZSBkPXtDYjohMSx1cmw6cn07dmFyIG09bi56YyhlLHQsZCxpLG8pO2QuSWE/bS5JYT1kLklhOmQudXJsJiYobS5JYT1udWxsLG0udXJsPWQudXJsKSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhtLHtNYTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuSWEubGVuZ3RofX19KTt2YXIgZz17fTtyZXR1cm4gT2JqZWN0LmtleXMobS5zdHJlYW1fb3BzKS5mb3JFYWNoKHc9Pnt2YXIgXz1tLnN0cmVhbV9vcHNbd107Z1t3XT1mdW5jdGlvbigpe3JldHVybiBuLldiKG0pLF8uYXBwbHkobnVsbCxhcmd1bWVudHMpfX0pLGcucmVhZD0odyxfLEQsTixUKT0+e2lmKG4uV2IobSksdz13Lm5vZGUuSWEsVD49dy5sZW5ndGgpcmV0dXJuIDA7aWYoTj1NYXRoLm1pbih3Lmxlbmd0aC1ULE4pLHcuc2xpY2UpZm9yKHZhciBQPTA7UDxOO1ArKylfW0QrUF09d1tUK1BdO2Vsc2UgZm9yKFA9MDtQPE47UCsrKV9bRCtQXT13LmdldChUK1ApO3JldHVybiBOfSxtLnN0cmVhbV9vcHM9ZyxtfSxhZDooZSx0LHIsaSxvLGwsZCxtLGcsdyk9PntmdW5jdGlvbiBfKE4pe2Z1bmN0aW9uIFQoUCl7dyYmdygpLG18fG4udGIoZSx0LFAsaSxvLGcpLGwmJmwoKSxMZSgpfWJyLmdkKE4sRCxULCgpPT57ZCYmZCgpLExlKCl9KXx8VChOKX12YXIgRD10P2hlKEooZSsiLyIrdCkpOmU7cnQoKSx0eXBlb2Ygcj09InN0cmluZyI/bXIocixOPT5fKE4pLGQpOl8ocil9LGluZGV4ZWREQjooKT0+d2luZG93LmluZGV4ZWREQnx8d2luZG93Lm1vekluZGV4ZWREQnx8d2luZG93LndlYmtpdEluZGV4ZWREQnx8d2luZG93Lm1zSW5kZXhlZERCLExiOigpPT4iRU1fRlNfIit3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsTWI6MjAsYmI6IkZJTEVfREFUQSIsb2Q6KGUsdCxyKT0+e3Q9dHx8KCgpPT57fSkscj1yfHwoKCk9Pnt9KTt2YXIgaT1uLmluZGV4ZWREQigpO3RyeXt2YXIgbz1pLm9wZW4obi5MYigpLG4uTWIpfWNhdGNoKGwpe3JldHVybiByKGwpfW8ub251cGdyYWRlbmVlZGVkPSgpPT57UmUoImNyZWF0aW5nIGRiIiksby5yZXN1bHQuY3JlYXRlT2JqZWN0U3RvcmUobi5iYil9LG8ub25zdWNjZXNzPSgpPT57dmFyIGw9by5yZXN1bHQudHJhbnNhY3Rpb24oW24uYmJdLCJyZWFkd3JpdGUiKSxkPWwub2JqZWN0U3RvcmUobi5iYiksbT0wLGc9MCx3PWUubGVuZ3RoO2UuZm9yRWFjaChfPT57Xz1kLnB1dChuLnJiKF8pLm9iamVjdC5JYSxfKSxfLm9uc3VjY2Vzcz0oKT0+e20rKyxtK2c9PXcmJihnPT0wP3QoKTpyKCkpfSxfLm9uZXJyb3I9KCk9PntnKyssbStnPT13JiYoZz09MD90KCk6cigpKX19KSxsLm9uZXJyb3I9cn0sby5vbmVycm9yPXJ9LGhkOihlLHQscik9Pnt0PXR8fCgoKT0+e30pLHI9cnx8KCgpPT57fSk7dmFyIGk9bi5pbmRleGVkREIoKTt0cnl7dmFyIG89aS5vcGVuKG4uTGIoKSxuLk1iKX1jYXRjaChsKXtyZXR1cm4gcihsKX1vLm9udXBncmFkZW5lZWRlZD1yLG8ub25zdWNjZXNzPSgpPT57dmFyIGw9by5yZXN1bHQ7dHJ5e3ZhciBkPWwudHJhbnNhY3Rpb24oW24uYmJdLCJyZWFkb25seSIpfWNhdGNoKEQpe3IoRCk7cmV0dXJufXZhciBtPWQub2JqZWN0U3RvcmUobi5iYiksZz0wLHc9MCxfPWUubGVuZ3RoO2UuZm9yRWFjaChEPT57dmFyIE49bS5nZXQoRCk7Ti5vbnN1Y2Nlc3M9KCk9PntuLnJiKEQpLmV4aXN0cyYmbi51bmxpbmsoRCksbi50YihUZShEKSxuZShEKSxOLnJlc3VsdCwhMCwhMCwhMCksZysrLGcrdz09XyYmKHc9PTA/dCgpOnIoKSl9LE4ub25lcnJvcj0oKT0+e3crKyxnK3c9PV8mJih3PT0wP3QoKTpyKCkpfX0pLGQub25lcnJvcj1yfSxvLm9uZXJyb3I9cn19O2Z1bmN0aW9uIGRlKGUsdCxyKXtpZih0LmNoYXJBdCgwKT09PSIvIilyZXR1cm4gdDtpZihlPT09LTEwMCllPW4uY3dkKCk7ZWxzZXtpZihlPW4uVGEoZSksIWUpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig4KTtlPWUucGF0aH1pZih0Lmxlbmd0aD09MCl7aWYoIXIpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig0NCk7cmV0dXJuIGV9cmV0dXJuIEooZSsiLyIrdCl9ZnVuY3Rpb24geGUoZSx0LHIpe3RyeXt2YXIgaT1lKHQpfWNhdGNoKG8pe2lmKG8mJm8ubm9kZSYmSih0KSE9PUoobi5TYShvLm5vZGUpKSlyZXR1cm4tNTQ7dGhyb3cgb31yZXR1cm4gdltyPj4yXT1pLmRldix2W3IrND4+Ml09MCx2W3IrOD4+Ml09aS5pbm8sdltyKzEyPj4yXT1pLm1vZGUsdltyKzE2Pj4yXT1pLm5saW5rLHZbcisyMD4+Ml09aS51aWQsdltyKzI0Pj4yXT1pLmdpZCx2W3IrMjg+PjJdPWkucmRldix2W3IrMzI+PjJdPTAsJD1baS5zaXplPj4+MCwoRj1pLnNpemUsMTw9K01hdGguYWJzKEYpPzA8Rj8oTWF0aC5taW4oK01hdGguZmxvb3IoRi80Mjk0OTY3Mjk2KSw0Mjk0OTY3Mjk1KXwwKT4+PjA6fn4rTWF0aC5jZWlsKChGLSsofn5GPj4+MCkpLzQyOTQ5NjcyOTYpPj4+MDowKV0sdltyKzQwPj4yXT0kWzBdLHZbcis0ND4+Ml09JFsxXSx2W3IrNDg+PjJdPTQwOTYsdltyKzUyPj4yXT1pLmJsb2Nrcyx2W3IrNTY+PjJdPWkuYXRpbWUuZ2V0VGltZSgpLzFlM3wwLHZbcis2MD4+Ml09MCx2W3IrNjQ+PjJdPWkubXRpbWUuZ2V0VGltZSgpLzFlM3wwLHZbcis2OD4+Ml09MCx2W3IrNzI+PjJdPWkuY3RpbWUuZ2V0VGltZSgpLzFlM3wwLHZbcis3Nj4+Ml09MCwkPVtpLmlubz4+PjAsKEY9aS5pbm8sMTw9K01hdGguYWJzKEYpPzA8Rj8oTWF0aC5taW4oK01hdGguZmxvb3IoRi80Mjk0OTY3Mjk2KSw0Mjk0OTY3Mjk1KXwwKT4+PjA6fn4rTWF0aC5jZWlsKChGLSsofn5GPj4+MCkpLzQyOTQ5NjcyOTYpPj4+MDowKV0sdltyKzgwPj4yXT0kWzBdLHZbcis4ND4+Ml09JFsxXSwwfXZhciBVZT12b2lkIDA7ZnVuY3Rpb24gV2UoKXtyZXR1cm4gVWUrPTQsdltVZS00Pj4yXX1mdW5jdGlvbiBpZShlKXtpZihlPW4uVGEoZSksIWUpdGhyb3cgbmV3IG4uRXJybm9FcnJvcig4KTtyZXR1cm4gZX1mdW5jdGlvbiB3cihlLHQscil7ZnVuY3Rpb24gaShnKXtyZXR1cm4oZz1nLnRvVGltZVN0cmluZygpLm1hdGNoKC9cKChbQS1aYS16IF0rKVwpJC8pKT9nWzFdOiJHTVQifXZhciBvPW5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSxsPW5ldyBEYXRlKG8sMCwxKSxkPW5ldyBEYXRlKG8sNiwxKTtvPWwuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgbT1kLmdldFRpbWV6b25lT2Zmc2V0KCk7dltlPj4yXT02MCpNYXRoLm1heChvLG0pLHZbdD4+Ml09TnVtYmVyKG8hPW0pLGU9aShsKSx0PWkoZCksZT12dChlKSx0PXZ0KHQpLG08bz8oQ1tyPj4yXT1lLENbcis0Pj4yXT10KTooQ1tyPj4yXT10LENbcis0Pj4yXT1lKX1mdW5jdGlvbiBvdChlLHQscil7b3QudGN8fChvdC50Yz0hMCx3cihlLHQscikpfXZhciBOdDtOdD14PygpPT57dmFyIGU9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gMWUzKmVbMF0rZVsxXS8xZTZ9OigpPT5wZXJmb3JtYW5jZS5ub3coKTt2YXIgc3Q9e307ZnVuY3Rpb24gUHQoKXtpZighYXQpe3ZhciBlPXtVU0VSOiJ3ZWJfdXNlciIsTE9HTkFNRToid2ViX3VzZXIiLFBBVEg6Ii8iLFBXRDoiLyIsSE9NRToiL2hvbWUvd2ViX3VzZXIiLExBTkc6KHR5cGVvZiBuYXZpZ2F0b3I9PSJvYmplY3QiJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHwiQyIpLnJlcGxhY2UoIi0iLCJfIikrIi5VVEYtOCIsXzpXfHwiLi90aGlzLnByb2dyYW0ifSx0O2Zvcih0IGluIHN0KXN0W3RdPT09dm9pZCAwP2RlbGV0ZSBlW3RdOmVbdF09c3RbdF07dmFyIHI9W107Zm9yKHQgaW4gZSlyLnB1c2godCsiPSIrZVt0XSk7YXQ9cn1yZXR1cm4gYXR9dmFyIGF0O2Z1bmN0aW9uIEx0KGUsdCxyLGkpe2V8fChlPXRoaXMpLHRoaXMucGFyZW50PWUsdGhpcy5tb3VudD1lLm1vdW50LHRoaXMuZWI9bnVsbCx0aGlzLmlkPW4uUGMrKyx0aGlzLm5hbWU9dCx0aGlzLm1vZGU9cix0aGlzLm5vZGVfb3BzPXt9LHRoaXMuc3RyZWFtX29wcz17fSx0aGlzLnJkZXY9aX1PYmplY3QuZGVmaW5lUHJvcGVydGllcyhMdC5wcm90b3R5cGUse3JlYWQ6e2dldDpmdW5jdGlvbigpe3JldHVybih0aGlzLm1vZGUmMzY1KT09PTM2NX0sc2V0OmZ1bmN0aW9uKGUpe2U/dGhpcy5tb2RlfD0zNjU6dGhpcy5tb2RlJj0tMzY2fX0sd3JpdGU6e2dldDpmdW5jdGlvbigpe3JldHVybih0aGlzLm1vZGUmMTQ2KT09PTE0Nn0sc2V0OmZ1bmN0aW9uKGUpe2U/dGhpcy5tb2RlfD0xNDY6dGhpcy5tb2RlJj0tMTQ3fX0sS2M6e2dldDpmdW5jdGlvbigpe3JldHVybiBuLmlzRGlyKHRoaXMubW9kZSl9fSxDYjp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4uamIodGhpcy5tb2RlKX19fSksbi5GU05vZGU9THQsbi5lYygpO3ZhciBicjtmdW5jdGlvbiBPZShlLHQpe3ZhciByPUFycmF5KGZlKGUpKzEpO3JldHVybiBlPXJlKGUsciwwLHIubGVuZ3RoKSx0JiYoci5sZW5ndGg9ZSkscn12YXIgeXI9e2E6ZnVuY3Rpb24oZSx0LHIsaSl7WigiQXNzZXJ0aW9uIGZhaWxlZDogIitMKGUpKyIsIGF0OiAiK1t0P0wodCk6InVua25vd24gZmlsZW5hbWUiLHIsaT9MKGkpOiJ1bmtub3duIGZ1bmN0aW9uIl0pfSxnOmZ1bmN0aW9uKGUsdCl7dHJ5e3JldHVybiBlPUwoZSksbi5jaG1vZChlLHQpLDB9Y2F0Y2gocil7aWYodHlwZW9mIG49PSJ1bmRlZmluZWQifHwhKHIgaW5zdGFuY2VvZiBuLkVycm5vRXJyb3IpKXRocm93IHI7cmV0dXJuLXIuSmF9fSxJOmZ1bmN0aW9uKGUsdCxyKXt0cnl7aWYodD1MKHQpLHQ9ZGUoZSx0KSxyJi04KXJldHVybi0yODt2YXIgaT1uLmxvb2t1cFBhdGgodCx7TmE6ITB9KS5ub2RlO3JldHVybiBpPyhlPSIiLHImNCYmKGUrPSJyIiksciYyJiYoZSs9InciKSxyJjEmJihlKz0ieCIpLGUmJm4uVWEoaSxlKT8tMjowKTotNDR9Y2F0Y2gobyl7aWYodHlwZW9mIG49PSJ1bmRlZmluZWQifHwhKG8gaW5zdGFuY2VvZiBuLkVycm5vRXJyb3IpKXRocm93IG87cmV0dXJuLW8uSmF9fSxoOmZ1bmN0aW9uKGUsdCl7dHJ5e3JldHVybiBuLmZjaG1vZChlLHQpLDB9Y2F0Y2gocil7aWYodHlwZW9mIG49PSJ1bmRlZmluZWQifHwhKHIgaW5zdGFuY2VvZiBuLkVycm5vRXJyb3IpKXRocm93IHI7cmV0dXJuLXIuSmF9fSxIOmZ1bmN0aW9uKGUsdCxyKXt0cnl7cmV0dXJuIG4uZmNob3duKGUsdCxyKSwwfWNhdGNoKGkpe2lmKHR5cGVvZiBuPT0idW5kZWZpbmVkInx8IShpIGluc3RhbmNlb2Ygbi5FcnJub0Vycm9yKSl0aHJvdyBpO3JldHVybi1pLkphfX0sYjpmdW5jdGlvbihlLHQscil7VWU9cjt0cnl7dmFyIGk9aWUoZSk7c3dpdGNoKHQpe2Nhc2UgMDp2YXIgbz1XZSgpO3JldHVybiAwPm8/LTI4Om4uUWIoaSxvKS5mZDtjYXNlIDE6Y2FzZSAyOnJldHVybiAwO2Nhc2UgMzpyZXR1cm4gaS5mbGFncztjYXNlIDQ6cmV0dXJuIG89V2UoKSxpLmZsYWdzfD1vLDA7Y2FzZSA1OnJldHVybiBvPVdlKCksUGVbbyswPj4xXT0yLDA7Y2FzZSA2OmNhc2UgNzpyZXR1cm4gMDtjYXNlIDE2OmNhc2UgODpyZXR1cm4tMjg7Y2FzZSA5OnJldHVybiB2W0J0KCk+PjJdPTI4LC0xO2RlZmF1bHQ6cmV0dXJuLTI4fX1jYXRjaChsKXtpZih0eXBlb2Ygbj09InVuZGVmaW5lZCJ8fCEobCBpbnN0YW5jZW9mIG4uRXJybm9FcnJvcikpdGhyb3cgbDtyZXR1cm4tbC5KYX19LEc6ZnVuY3Rpb24oZSx0KXt0cnl7dmFyIHI9aWUoZSk7cmV0dXJuIHhlKG4uc3RhdCxyLnBhdGgsdCl9Y2F0Y2goaSl7aWYodHlwZW9mIG49PSJ1bmRlZmluZWQifHwhKGkgaW5zdGFuY2VvZiBuLkVycm5vRXJyb3IpKXRocm93IGk7cmV0dXJuLWkuSmF9fSxsOmZ1bmN0aW9uKGUsdCxyKXt0cnl7cmV0dXJuIHQ9cisyMDk3MTUyPj4+MDw0MTk0MzA1LSEhdD8odD4+PjApKzQyOTQ5NjcyOTYqcjpOYU4saXNOYU4odCk/LTYxOihuLkZjKGUsdCksMCl9Y2F0Y2goaSl7aWYodHlwZW9mIG49PSJ1bmRlZmluZWQifHwhKGkgaW5zdGFuY2VvZiBuLkVycm5vRXJyb3IpKXRocm93IGk7cmV0dXJuLWkuSmF9fSxCOmZ1bmN0aW9uKGUsdCl7dHJ5e2lmKHQ9PT0wKXJldHVybi0yODt2YXIgcj1uLmN3ZCgpLGk9ZmUocikrMTtyZXR1cm4gdDxpPy02ODoocmUocixLLGUsdCksaSl9Y2F0Y2gobyl7aWYodHlwZW9mIG49PSJ1bmRlZmluZWQifHwhKG8gaW5zdGFuY2VvZiBuLkVycm5vRXJyb3IpKXRocm93IG87cmV0dXJuLW8uSmF9fSxFOmZ1bmN0aW9uKGUsdCl7dHJ5e3JldHVybiBlPUwoZSkseGUobi5sc3RhdCxlLHQpfWNhdGNoKHIpe2lmKHR5cGVvZiBuPT0idW5kZWZpbmVkInx8IShyIGluc3RhbmNlb2Ygbi5FcnJub0Vycm9yKSl0aHJvdyByO3JldHVybi1yLkphfX0seTpmdW5jdGlvbihlLHQscil7dHJ5e3JldHVybiB0PUwodCksdD1kZShlLHQpLHQ9Sih0KSx0W3QubGVuZ3RoLTFdPT09Ii8iJiYodD10LnN1YnN0cigwLHQubGVuZ3RoLTEpKSxuLm1rZGlyKHQsciwwKSwwfWNhdGNoKGkpe2lmKHR5cGVvZiBuPT0idW5kZWZpbmVkInx8IShpIGluc3RhbmNlb2Ygbi5FcnJub0Vycm9yKSl0aHJvdyBpO3JldHVybi1pLkphfX0sRDpmdW5jdGlvbihlLHQscixpKXt0cnl7dD1MKHQpO3ZhciBvPWkmMjU2O3JldHVybiB0PWRlKGUsdCxpJjQwOTYpLHhlKG8/bi5sc3RhdDpuLnN0YXQsdCxyKX1jYXRjaChsKXtpZih0eXBlb2Ygbj09InVuZGVmaW5lZCJ8fCEobCBpbnN0YW5jZW9mIG4uRXJybm9FcnJvcikpdGhyb3cgbDtyZXR1cm4tbC5KYX19LHY6ZnVuY3Rpb24oZSx0LHIsaSl7VWU9aTt0cnl7dD1MKHQpLHQ9ZGUoZSx0KTt2YXIgbz1pP1dlKCk6MDtyZXR1cm4gbi5vcGVuKHQscixvKS5mZH1jYXRjaChsKXtpZih0eXBlb2Ygbj09InVuZGVmaW5lZCJ8fCEobCBpbnN0YW5jZW9mIG4uRXJybm9FcnJvcikpdGhyb3cgbDtyZXR1cm4tbC5KYX19LHQ6ZnVuY3Rpb24oZSx0LHIsaSl7dHJ5e2lmKHQ9TCh0KSx0PWRlKGUsdCksMD49aSlyZXR1cm4tMjg7dmFyIG89bi5yZWFkbGluayh0KSxsPU1hdGgubWluKGksZmUobykpLGQ9QltyK2xdO3JldHVybiByZShvLEsscixpKzEpLEJbcitsXT1kLGx9Y2F0Y2gobSl7aWYodHlwZW9mIG49PSJ1bmRlZmluZWQifHwhKG0gaW5zdGFuY2VvZiBuLkVycm5vRXJyb3IpKXRocm93IG07cmV0dXJuLW0uSmF9fSxzOmZ1bmN0aW9uKGUpe3RyeXtyZXR1cm4gZT1MKGUpLG4ucm1kaXIoZSksMH1jYXRjaCh0KXtpZih0eXBlb2Ygbj09InVuZGVmaW5lZCJ8fCEodCBpbnN0YW5jZW9mIG4uRXJybm9FcnJvcikpdGhyb3cgdDtyZXR1cm4tdC5KYX19LEY6ZnVuY3Rpb24oZSx0KXt0cnl7cmV0dXJuIGU9TChlKSx4ZShuLnN0YXQsZSx0KX1jYXRjaChyKXtpZih0eXBlb2Ygbj09InVuZGVmaW5lZCJ8fCEociBpbnN0YW5jZW9mIG4uRXJybm9FcnJvcikpdGhyb3cgcjtyZXR1cm4tci5KYX19LHA6ZnVuY3Rpb24oZSx0LHIpe3RyeXtyZXR1cm4gdD1MKHQpLHQ9ZGUoZSx0KSxyPT09MD9uLnVubGluayh0KTpyPT09NTEyP24ucm1kaXIodCk6WigiSW52YWxpZCBmbGFncyBwYXNzZWQgdG8gdW5saW5rYXQiKSwwfWNhdGNoKGkpe2lmKHR5cGVvZiBuPT0idW5kZWZpbmVkInx8IShpIGluc3RhbmNlb2Ygbi5FcnJub0Vycm9yKSl0aHJvdyBpO3JldHVybi1pLkphfX0sbjpmdW5jdGlvbihlLHQscil7dHJ5e2lmKHQ9TCh0KSx0PWRlKGUsdCwhMCkscil7dmFyIGk9dltyPj4yXSxvPXZbcis0Pj4yXTtsPTFlMyppK28vMWU2LHIrPTgsaT12W3I+PjJdLG89dltyKzQ+PjJdLGQ9MWUzKmkrby8xZTZ9ZWxzZSB2YXIgbD1EYXRlLm5vdygpLGQ9bDtyZXR1cm4gbi5ZYyh0LGwsZCksMH1jYXRjaChtKXtpZih0eXBlb2Ygbj09InVuZGVmaW5lZCJ8fCEobSBpbnN0YW5jZW9mIG4uRXJybm9FcnJvcikpdGhyb3cgbTtyZXR1cm4tbS5KYX19LGU6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX0saTpmdW5jdGlvbihlLHQpe2U9bmV3IERhdGUoMWUzKnZbZT4+Ml0pLHZbdD4+Ml09ZS5nZXRTZWNvbmRzKCksdlt0KzQ+PjJdPWUuZ2V0TWludXRlcygpLHZbdCs4Pj4yXT1lLmdldEhvdXJzKCksdlt0KzEyPj4yXT1lLmdldERhdGUoKSx2W3QrMTY+PjJdPWUuZ2V0TW9udGgoKSx2W3QrMjA+PjJdPWUuZ2V0RnVsbFllYXIoKS0xOTAwLHZbdCsyND4+Ml09ZS5nZXREYXkoKTt2YXIgcj1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwxKTt2W3QrMjg+PjJdPShlLmdldFRpbWUoKS1yLmdldFRpbWUoKSkvODY0ZTV8MCx2W3QrMzY+PjJdPS0oNjAqZS5nZXRUaW1lem9uZU9mZnNldCgpKTt2YXIgaT1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3I9ci5nZXRUaW1lem9uZU9mZnNldCgpLHZbdCszMj4+Ml09KGkhPXImJmUuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4ocixpKSl8MH0sdzpmdW5jdGlvbihlLHQscixpLG8sbCxkKXt0cnl7aWYoZSE9PTApcmV0dXJuLTI4O3ZhciBtPW4uVGEobyk7aWYoIW0pcmV0dXJuLTg7dmFyIGc9bi5tbWFwKG0sdCxsLHIsaSksdz1nLlVjO3JldHVybiB2W2Q+PjJdPWcubGMsd31jYXRjaChfKXtpZih0eXBlb2Ygbj09InVuZGVmaW5lZCJ8fCEoXyBpbnN0YW5jZW9mIG4uRXJybm9FcnJvcikpdGhyb3cgXztyZXR1cm4tXy5KYX19LHg6ZnVuY3Rpb24oZSx0LHIsaSxvLGwpe3RyeXt2YXIgZD1uLlRhKG8pO2lmKGQmJnImMil7dmFyIG09Sy5zbGljZShlLGUrdCk7bi5tc3luYyhkLG0sbCx0LGkpfX1jYXRjaChnKXtpZih0eXBlb2Ygbj09InVuZGVmaW5lZCJ8fCEoZyBpbnN0YW5jZW9mIG4uRXJybm9FcnJvcikpdGhyb3cgZztyZXR1cm4tZy5KYX19LGo6b3QscTpmdW5jdGlvbigpe3JldHVybiAyMTQ3NDgzNjQ4fSxkOk50LG86ZnVuY3Rpb24oZSx0LHIpe0suY29weVdpdGhpbihlLHQsdCtyKX0sYzpmdW5jdGlvbihlKXt2YXIgdD1LLmxlbmd0aDtpZihlPj4+PTAsMjE0NzQ4MzY0ODxlKXJldHVybiExO2Zvcih2YXIgcj0xOzQ+PXI7cio9Mil7dmFyIGk9dCooMSsuMi9yKTtpPU1hdGgubWluKGksZSsxMDA2NjMyOTYpO3ZhciBvPU1hdGg7aT1NYXRoLm1heChlLGkpLG89by5taW4uY2FsbChvLDIxNDc0ODM2NDgsaSsoNjU1MzYtaSU2NTUzNiklNjU1MzYpO2U6e3RyeXtZZS5ncm93KG8tR2UuYnl0ZUxlbmd0aCs2NTUzNT4+PjE2KSxrdCgpO3ZhciBsPTE7YnJlYWsgZX1jYXRjaHt9bD12b2lkIDB9aWYobClyZXR1cm4hMH1yZXR1cm4hMX0sejpmdW5jdGlvbihlLHQpe3ZhciByPTA7cmV0dXJuIFB0KCkuZm9yRWFjaChmdW5jdGlvbihpLG8pe3ZhciBsPXQrcjtmb3Iobz1DW2UrNCpvPj4yXT1sLGw9MDtsPGkubGVuZ3RoOysrbClCW28rKz4+MF09aS5jaGFyQ29kZUF0KGwpO0Jbbz4+MF09MCxyKz1pLmxlbmd0aCsxfSksMH0sQTpmdW5jdGlvbihlLHQpe3ZhciByPVB0KCk7Q1tlPj4yXT1yLmxlbmd0aDt2YXIgaT0wO3JldHVybiByLmZvckVhY2goZnVuY3Rpb24obyl7aSs9by5sZW5ndGgrMX0pLENbdD4+Ml09aSwwfSxmOmZ1bmN0aW9uKGUpe3RyeXt2YXIgdD1pZShlKTtyZXR1cm4gbi5jbG9zZSh0KSwwfWNhdGNoKHIpe2lmKHR5cGVvZiBuPT0idW5kZWZpbmVkInx8IShyIGluc3RhbmNlb2Ygbi5FcnJub0Vycm9yKSl0aHJvdyByO3JldHVybiByLkphfX0sbTpmdW5jdGlvbihlLHQpe3RyeXt2YXIgcj1pZShlKSxpPXIudHR5PzI6bi5pc0RpcihyLm1vZGUpPzM6bi5aYShyLm1vZGUpPzc6NDtyZXR1cm4gQlt0Pj4wXT1pLDB9Y2F0Y2gobyl7aWYodHlwZW9mIG49PSJ1bmRlZmluZWQifHwhKG8gaW5zdGFuY2VvZiBuLkVycm5vRXJyb3IpKXRocm93IG87cmV0dXJuIG8uSmF9fSx1OmZ1bmN0aW9uKGUsdCxyLGkpe3RyeXtlOnt2YXIgbz1pZShlKTtlPXQ7Zm9yKHZhciBsPXQ9MDtsPHI7bCsrKXt2YXIgZD1DW2U+PjJdLG09Q1tlKzQ+PjJdO2UrPTg7dmFyIGc9bi5yZWFkKG8sQixkLG0sdm9pZCAwKTtpZigwPmcpe3ZhciB3PS0xO2JyZWFrIGV9aWYodCs9ZyxnPG0pYnJlYWt9dz10fXJldHVybiB2W2k+PjJdPXcsMH1jYXRjaChfKXtpZih0eXBlb2Ygbj09InVuZGVmaW5lZCJ8fCEoXyBpbnN0YW5jZW9mIG4uRXJybm9FcnJvcikpdGhyb3cgXztyZXR1cm4gXy5KYX19LGs6ZnVuY3Rpb24oZSx0LHIsaSxvKXt0cnl7aWYodD1yKzIwOTcxNTI+Pj4wPDQxOTQzMDUtISF0Pyh0Pj4+MCkrNDI5NDk2NzI5NipyOk5hTixpc05hTih0KSlyZXR1cm4gNjE7dmFyIGw9aWUoZSk7cmV0dXJuIG4ubGxzZWVrKGwsdCxpKSwkPVtsLnBvc2l0aW9uPj4+MCwoRj1sLnBvc2l0aW9uLDE8PStNYXRoLmFicyhGKT8wPEY/KE1hdGgubWluKCtNYXRoLmZsb29yKEYvNDI5NDk2NzI5NiksNDI5NDk2NzI5NSl8MCk+Pj4wOn5+K01hdGguY2VpbCgoRi0rKH5+Rj4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCldLHZbbz4+Ml09JFswXSx2W28rND4+Ml09JFsxXSxsLnpiJiZ0PT09MCYmaT09PTAmJihsLnpiPW51bGwpLDB9Y2F0Y2goZCl7aWYodHlwZW9mIG49PSJ1bmRlZmluZWQifHwhKGQgaW5zdGFuY2VvZiBuLkVycm5vRXJyb3IpKXRocm93IGQ7cmV0dXJuIGQuSmF9fSxDOmZ1bmN0aW9uKGUpe3RyeXt2YXIgdD1pZShlKTtyZXR1cm4gdC5zdHJlYW1fb3BzJiZ0LnN0cmVhbV9vcHMuZnN5bmM/LXQuc3RyZWFtX29wcy5mc3luYyh0KTowfWNhdGNoKHIpe2lmKHR5cGVvZiBuPT0idW5kZWZpbmVkInx8IShyIGluc3RhbmNlb2Ygbi5FcnJub0Vycm9yKSl0aHJvdyByO3JldHVybiByLkphfX0scjpmdW5jdGlvbihlLHQscixpKXt0cnl7ZTp7dmFyIG89aWUoZSk7ZT10O2Zvcih2YXIgbD10PTA7bDxyO2wrKyl7dmFyIGQ9Q1tlPj4yXSxtPUNbZSs0Pj4yXTtlKz04O3ZhciBnPW4ud3JpdGUobyxCLGQsbSx2b2lkIDApO2lmKDA+Zyl7dmFyIHc9LTE7YnJlYWsgZX10Kz1nfXc9dH1yZXR1cm4gQ1tpPj4yXT13LDB9Y2F0Y2goXyl7aWYodHlwZW9mIG49PSJ1bmRlZmluZWQifHwhKF8gaW5zdGFuY2VvZiBuLkVycm5vRXJyb3IpKXRocm93IF87cmV0dXJuIF8uSmF9fX07KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShvKXtzLmFzbT1vLmV4cG9ydHMsWWU9cy5hc20uSixrdCgpLFk9cy5hc20uQmEscXQudW5zaGlmdChzLmFzbS5LKSxMZSgpfWZ1bmN0aW9uIHQobyl7ZShvLmluc3RhbmNlKX1mdW5jdGlvbiByKG8pe3JldHVybiBscigpLnRoZW4oZnVuY3Rpb24obCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGwsaSl9KS50aGVuKGZ1bmN0aW9uKGwpe3JldHVybiBsfSkudGhlbihvLGZ1bmN0aW9uKGwpe3RlKCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAiK2wpLFoobCl9KX12YXIgaT17YTp5cn07aWYocnQoKSxzLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIHMuaW5zdGFudGlhdGVXYXNtKGksZSl9Y2F0Y2gobyl7cmV0dXJuIHRlKCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAiK28pLCExfXJldHVybiBmdW5jdGlvbigpe3JldHVybiBrZXx8dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nIT0iZnVuY3Rpb24ifHxEdCgpfHxILnN0YXJ0c1dpdGgoImZpbGU6Ly8iKXx8dHlwZW9mIGZldGNoIT0iZnVuY3Rpb24iP3IodCk6ZmV0Y2goSCx7Y3JlZGVudGlhbHM6InNhbWUtb3JpZ2luIn0pLnRoZW4oZnVuY3Rpb24obyl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKG8saSkudGhlbih0LGZ1bmN0aW9uKGwpe3JldHVybiB0ZSgid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICIrbCksdGUoImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uIikscih0KX0pfSl9KCkse319KSgpLHMuX19fd2FzbV9jYWxsX2N0b3JzPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19fd2FzbV9jYWxsX2N0b3JzPXMuYXNtLkspLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fc3FsaXRlM192ZnNfZmluZD1mdW5jdGlvbigpe3JldHVybihzLl9zcWxpdGUzX3Zmc19maW5kPXMuYXNtLkwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fc3FsaXRlM19mcmVlPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX3NxbGl0ZTNfZnJlZT1zLmFzbS5NKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBCdD1zLl9fX2Vycm5vX2xvY2F0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuKEJ0PXMuX19fZXJybm9fbG9jYXRpb249cy5hc20uTikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtzLl9zcWxpdGUzX2ZpbmFsaXplPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX3NxbGl0ZTNfZmluYWxpemU9cy5hc20uTykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9zcWxpdGUzX3Jlc2V0PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX3NxbGl0ZTNfcmVzZXQ9cy5hc20uUCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9zcWxpdGUzX2NsZWFyX2JpbmRpbmdzPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX3NxbGl0ZTNfY2xlYXJfYmluZGluZ3M9cy5hc20uUSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9zcWxpdGUzX3ZhbHVlX2Jsb2I9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fc3FsaXRlM192YWx1ZV9ibG9iPXMuYXNtLlIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fc3FsaXRlM192YWx1ZV90ZXh0PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX3NxbGl0ZTNfdmFsdWVfdGV4dD1zLmFzbS5TKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX3NxbGl0ZTNfdmFsdWVfYnl0ZXM9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fc3FsaXRlM192YWx1ZV9ieXRlcz1zLmFzbS5UKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX3NxbGl0ZTNfdmFsdWVfZG91YmxlPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX3NxbGl0ZTNfdmFsdWVfZG91YmxlPXMuYXNtLlUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fc3FsaXRlM192YWx1ZV9pbnQ9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fc3FsaXRlM192YWx1ZV9pbnQ9cy5hc20uVikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9zcWxpdGUzX3ZhbHVlX3R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fc3FsaXRlM192YWx1ZV90eXBlPXMuYXNtLlcpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fc3FsaXRlM19yZXN1bHRfYmxvYj1mdW5jdGlvbigpe3JldHVybihzLl9zcWxpdGUzX3Jlc3VsdF9ibG9iPXMuYXNtLlgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fc3FsaXRlM19yZXN1bHRfZG91YmxlPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX3NxbGl0ZTNfcmVzdWx0X2RvdWJsZT1zLmFzbS5ZKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX3NxbGl0ZTNfcmVzdWx0X2Vycm9yPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX3NxbGl0ZTNfcmVzdWx0X2Vycm9yPXMuYXNtLlopLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fc3FsaXRlM19yZXN1bHRfaW50PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX3NxbGl0ZTNfcmVzdWx0X2ludD1zLmFzbS5fKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX3NxbGl0ZTNfcmVzdWx0X2ludDY0PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX3NxbGl0ZTNfcmVzdWx0X2ludDY0PXMuYXNtLiQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fc3FsaXRlM19yZXN1bHRfbnVsbD1mdW5jdGlvbigpe3JldHVybihzLl9zcWxpdGUzX3Jlc3VsdF9udWxsPXMuYXNtLmFhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX3NxbGl0ZTNfcmVzdWx0X3RleHQ9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fc3FsaXRlM19yZXN1bHRfdGV4dD1zLmFzbS5iYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9zcWxpdGUzX3N0ZXA9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fc3FsaXRlM19zdGVwPXMuYXNtLmNhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX3NxbGl0ZTNfY29sdW1uX2NvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX3NxbGl0ZTNfY29sdW1uX2NvdW50PXMuYXNtLmRhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX3NxbGl0ZTNfZGF0YV9jb3VudD1mdW5jdGlvbigpe3JldHVybihzLl9zcWxpdGUzX2RhdGFfY291bnQ9cy5hc20uZWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fc3FsaXRlM19jb2x1bW5fYmxvYj1mdW5jdGlvbigpe3JldHVybihzLl9zcWxpdGUzX2NvbHVtbl9ibG9iPXMuYXNtLmZhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX3NxbGl0ZTNfY29sdW1uX2J5dGVzPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX3NxbGl0ZTNfY29sdW1uX2J5dGVzPXMuYXNtLmdhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX3NxbGl0ZTNfY29sdW1uX2RvdWJsZT1mdW5jdGlvbigpe3JldHVybihzLl9zcWxpdGUzX2NvbHVtbl9kb3VibGU9cy5hc20uaGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fc3FsaXRlM19jb2x1bW5fdGV4dD1mdW5jdGlvbigpe3JldHVybihzLl9zcWxpdGUzX2NvbHVtbl90ZXh0PXMuYXNtLmlhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX3NxbGl0ZTNfY29sdW1uX3R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fc3FsaXRlM19jb2x1bW5fdHlwZT1zLmFzbS5qYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9zcWxpdGUzX2NvbHVtbl9uYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX3NxbGl0ZTNfY29sdW1uX25hbWU9cy5hc20ua2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fc3FsaXRlM19iaW5kX2Jsb2I9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fc3FsaXRlM19iaW5kX2Jsb2I9cy5hc20ubGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fc3FsaXRlM19iaW5kX2RvdWJsZT1mdW5jdGlvbigpe3JldHVybihzLl9zcWxpdGUzX2JpbmRfZG91YmxlPXMuYXNtLm1hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX3NxbGl0ZTNfYmluZF9pbnQ9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fc3FsaXRlM19iaW5kX2ludD1zLmFzbS5uYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9zcWxpdGUzX2JpbmRfdGV4dD1mdW5jdGlvbigpe3JldHVybihzLl9zcWxpdGUzX2JpbmRfdGV4dD1zLmFzbS5vYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXg9cy5hc20ucGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fc3FsaXRlM19zcWw9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fc3FsaXRlM19zcWw9cy5hc20ucWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fc3FsaXRlM19ub3JtYWxpemVkX3NxbD1mdW5jdGlvbigpe3JldHVybihzLl9zcWxpdGUzX25vcm1hbGl6ZWRfc3FsPXMuYXNtLnJhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX3NxbGl0ZTNfZXJybXNnPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX3NxbGl0ZTNfZXJybXNnPXMuYXNtLnNhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX3NxbGl0ZTNfZXhlYz1mdW5jdGlvbigpe3JldHVybihzLl9zcWxpdGUzX2V4ZWM9cy5hc20udGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fc3FsaXRlM19wcmVwYXJlX3YyPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX3NxbGl0ZTNfcHJlcGFyZV92Mj1zLmFzbS51YSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9zcWxpdGUzX2NoYW5nZXM9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fc3FsaXRlM19jaGFuZ2VzPXMuYXNtLnZhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX3NxbGl0ZTNfY2xvc2VfdjI9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fc3FsaXRlM19jbG9zZV92Mj1zLmFzbS53YSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92Mj1mdW5jdGlvbigpe3JldHVybihzLl9zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92Mj1zLmFzbS54YSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9zcWxpdGUzX29wZW49ZnVuY3Rpb24oKXtyZXR1cm4ocy5fc3FsaXRlM19vcGVuPXMuYXNtLnlhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBqZT1zLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oamU9cy5fbWFsbG9jPXMuYXNtLnphKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFZlPXMuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4oVmU9cy5fZnJlZT1zLmFzbS5BYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtzLl9SZWdpc3RlckV4dGVuc2lvbkZ1bmN0aW9ucz1mdW5jdGlvbigpe3JldHVybihzLl9SZWdpc3RlckV4dGVuc2lvbkZ1bmN0aW9ucz1zLmFzbS5DYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9yZWdpc3Rlcl9mb3JfaWRiPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX3JlZ2lzdGVyX2Zvcl9pZGI9cy5hc20uRGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIFR0PXMuX2Vtc2NyaXB0ZW5fYnVpbHRpbl9tZW1hbGlnbj1mdW5jdGlvbigpe3JldHVybihUdD1zLl9lbXNjcmlwdGVuX2J1aWx0aW5fbWVtYWxpZ249cy5hc20uRWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU2U9cy5zdGFja1NhdmU9ZnVuY3Rpb24oKXtyZXR1cm4oU2U9cy5zdGFja1NhdmU9cy5hc20uRmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRGU9cy5zdGFja1Jlc3RvcmU9ZnVuY3Rpb24oKXtyZXR1cm4oRGU9cy5zdGFja1Jlc3RvcmU9cy5hc20uR2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sb2U9cy5zdGFja0FsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKG9lPXMuc3RhY2tBbGxvYz1zLmFzbS5IYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtzLmN3cmFwPWZ1bmN0aW9uKGUsdCxyLGkpe3I9cnx8W107dmFyIG89ci5ldmVyeShmdW5jdGlvbihsKXtyZXR1cm4gbD09PSJudW1iZXIifSk7cmV0dXJuIHQhPT0ic3RyaW5nIiYmbyYmIWk/c1siXyIrZV06ZnVuY3Rpb24oKXtyZXR1cm4gYXIoZSx0LHIsYXJndW1lbnRzKX19LHMuVVRGOFRvU3RyaW5nPUwscy5zdGFja1NhdmU9U2Uscy5zdGFja1Jlc3RvcmU9RGUscy5zdGFja0FsbG9jPW9lLHMuRlM9bjt2YXIgQ2U7QWU9ZnVuY3Rpb24gZSgpe0NlfHx1dCgpLENlfHwoQWU9ZSl9O2Z1bmN0aW9uIHV0KCl7ZnVuY3Rpb24gZSgpe2lmKCFDZSYmKENlPSEwLHMuY2FsbGVkUnVuPSEwLCFndCkpe2lmKHMubm9GU0luaXR8fG4uaWIuQmJ8fG4uaWIoKSxuLmJjPSExLG50KHF0KSxzLm9uUnVudGltZUluaXRpYWxpemVkJiZzLm9uUnVudGltZUluaXRpYWxpemVkKCkscy5wb3N0UnVuKWZvcih0eXBlb2Ygcy5wb3N0UnVuPT0iZnVuY3Rpb24iJiYocy5wb3N0UnVuPVtzLnBvc3RSdW5dKTtzLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIHQ9cy5wb3N0UnVuLnNoaWZ0KCk7U3QudW5zaGlmdCh0KX1udChTdCl9fWlmKCEoMDxjZSkpe2lmKHMucHJlUnVuKWZvcih0eXBlb2Ygcy5wcmVSdW49PSJmdW5jdGlvbiImJihzLnByZVJ1bj1bcy5wcmVSdW5dKTtzLnByZVJ1bi5sZW5ndGg7KXVyKCk7bnQoQXQpLDA8Y2V8fChzLnNldFN0YXR1cz8ocy5zZXRTdGF0dXMoIlJ1bm5pbmcuLi4iKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe3Muc2V0U3RhdHVzKCIiKX0sMSksZSgpfSwxKSk6ZSgpKX19aWYocy5ydW49dXQscy5wcmVJbml0KWZvcih0eXBlb2Ygcy5wcmVJbml0PT0iZnVuY3Rpb24iJiYocy5wcmVJbml0PVtzLnByZUluaXRdKTswPHMucHJlSW5pdC5sZW5ndGg7KXMucHJlSW5pdC5wb3AoKSgpO3JldHVybiB1dCgpLHN9KSxmKX07RS5leHBvcnRzPXUsRS5leHBvcnRzLmRlZmF1bHQ9dX0pKHd0KTt2YXIgb3I9d3QuZXhwb3J0cztjb25zdCBidD1bInllbGxvdyIsImN5YW4iLCJtYWdlbnRhIl07Y2xhc3Mgc3J7Y29uc3RydWN0b3IoYSxmLHUsYyl7dGhpcy5kYk5hbWU9YSx0aGlzLndhc21Vcmw9Zix0aGlzLnBhZ2VTaXplPXUsdGhpcy5jYWNoZVNpemU9Yyx0aGlzLmN1cnJlbnRUcmFuc2FjdGlvbkk9MH1hc3luYyBpbml0KCl7Y29uc3QgYT1hd2FpdCBvcih7bG9jYXRlRmlsZTooKT0+dGhpcy53YXNtVXJsfSksZj1uZXcganQoYS5GUyxuZXcgdHIpO2EucmVnaXN0ZXJfZm9yX2lkYihmKSxhLkZTLm1rZGlyKCIvYmxvY2tlZCIpLGEuRlMubW91bnQoZix7fSwiL2Jsb2NrZWQiKTtjb25zdCB1PWAvYmxvY2tlZC8ke3RoaXMuZGJOYW1lfS5zcWxpdGVgO2lmKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj09InVuZGVmaW5lZCIpe2NvbnNvbGUubG9nKCJObyBTaGFyZWRBcnJheUJ1ZmZlciIpO2NvbnN0IGM9YS5GUy5vcGVuKHUsImErIik7YXdhaXQgYy5ub2RlLmNvbnRlbnRzLnJlYWRJZkZhbGxiYWNrKCksYS5GUy5jbG9zZShjKX10aGlzLnNxbERiPW5ldyBhLkRhdGFiYXNlKGAvYmxvY2tlZC8ke3RoaXMuZGJOYW1lfS5zcWxpdGVgLHtmaWxlbmFtZTohMH0pLGNvbnNvbGUubG9nKCJTZXR0aW5nIHByYWdtYSIpLHRoaXMuc3FsRGIuZXhlYyhgCiAgICAgIFBSQUdNQSBjYWNoZV9zaXplPSR7dGhpcy5jYWNoZVNpemV9OwogICAgICBQUkFHTUEgam91cm5hbF9tb2RlPU1FTU9SWTsKICAgICAgUFJBR01BIHBhZ2Vfc2l6ZT0ke3RoaXMucGFnZVNpemV9OwogICAgYCl9c3FsRXhlYyhhLGYsdSl7dHJ5e2NvbnN0IGM9W10scD1wZXJmb3JtYW5jZS5ub3coKSx5PXRoaXMuc3FsRGIucHJlcGFyZShhLGYpO2Zvcig7eS5zdGVwKCk7KWMucHVzaCh5LmdldEFzT2JqZWN0KCkpO3kuZnJlZSgpO2NvbnN0IGs9cGVyZm9ybWFuY2Uubm93KCk7cmV0dXJuKHU9PW51bGw/dm9pZCAwOnUudHJhbnNhY3Rpb25JZCkmJnUudHJhbnNhY3Rpb25JZCE9PXRoaXMuY3VycmVudFRyYW5zYWN0aW9uSWQmJiF1LnN1cHByZXNzJiYodGhpcy5jdXJyZW50VHJhbnNhY3Rpb25JZD11LnRyYW5zYWN0aW9uSWQsdGhpcy5jdXJyZW50VHJhbnNhY3Rpb25JKyspLHUhPW51bGwmJnUudHJhbnNhY3Rpb25JZHx8KHRoaXMuY3VycmVudFRyYW5zYWN0aW9uSWQ9dm9pZCAwKSx1IT1udWxsJiZ1LnN1cHByZXNzfHxjb25zb2xlLmxvZyhgJWNbJHt0aGlzLmRiTmFtZX1dJHt1IT1udWxsJiZ1LnRyYW5zYWN0aW9uSWQ/YFt0cl9pZD0ke3UudHJhbnNhY3Rpb25JZC5zdWJzdHJpbmcoMCw2KX1dYDoiIn0gJHthfSAke0pTT04uc3RyaW5naWZ5KGYpfSBUaW1lOiAkeygoay1wKS8xZTMpLnRvRml4ZWQoNCl9YCxgY29sb3I6ICR7dGhpcy5jdXJyZW50VHJhbnNhY3Rpb25JZD9idFt0aGlzLmN1cnJlbnRUcmFuc2FjdGlvbkklYnQubGVuZ3RoXToid2hpdGUifWApLGN9Y2F0Y2goYyl7dGhyb3cgY29uc29sZS5lcnJvcihgWyR7dGhpcy5kYk5hbWV9XSBGYWlsZWQgZXhlY3V0ZWAsYyxhLGYsdSx0aGlzLmN1cnJlbnRUcmFuc2FjdGlvbklkKSxjfX19Y29uc3QgeXQ9c2VsZjtsZXQgZ2U7eXQuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsYXN5bmMgRT0+e2NvbnN0IGE9dT0+eXQucG9zdE1lc3NhZ2UodSksZj1FLmRhdGE7aWYoZi50eXBlPT09ImluaXRpYWxpemUiKXtpZihnZSl0aHJvdyBuZXcgRXJyb3IoIkRCIGFscmVhZHkgaW5pdGlhbGl6ZWQhIik7Z2U9bmV3IHNyKGYuZGJOYW1lLGYud2FzbVVybCxmLnBhZ2VTaXplLGYuY2FjaGVTaXplKSxhd2FpdCBnZS5pbml0KCksYSh7dHlwZToiaW5pdGlhbGl6ZWQifSl9ZWxzZXtpZighZ2Upe2Eoe3R5cGU6InJlc3BvbnNlIixkYXRhOntjb21tYW5kSWQ6Zi5kYXRhLmNvbW1hbmRJZCxzdGF0dXM6ImVycm9yIixtZXNzYWdlOiJEQiBub3QgaW5pdGlhbGl6ZWQhIn19KSxjb25zb2xlLmVycm9yKCJEQiBpcyBub3QgaW5pdGlhbGl6ZWQiKTtyZXR1cm59Y29uc3QgdT1nZTt0cnl7Y29uc3QgYz1mLmRhdGEucXVlcmllcy5tYXAocD0+dS5zcWxFeGVjKHAudGV4dCxwLnZhbHVlcyxmLmRhdGEubG9nT3B0cykpO2Eoe3R5cGU6InJlc3BvbnNlIixkYXRhOntjb21tYW5kSWQ6Zi5kYXRhLmNvbW1hbmRJZCxzdGF0dXM6InN1Y2Nlc3MiLHJlc3VsdDpjfX0pfWNhdGNoKGMpe2Eoe3R5cGU6InJlc3BvbnNlIixkYXRhOntjb21tYW5kSWQ6Zi5kYXRhLmNvbW1hbmRJZCxzdGF0dXM6ImVycm9yIixtZXNzYWdlOmMgaW5zdGFuY2VvZiBFcnJvcj9jLm1lc3NhZ2U6SlNPTi5zdHJpbmdpZnkoYyl9fSl9fX0pfSkoKTsKLy8jIHNvdXJjZU1hcHBpbmdVUkw9L2Fzc2V0cy9EQi53b3JrZXIuNTgxZTkxZDkuanMubWFw";
const blob = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs)], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper() {
  const objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);
  try {
    return objURL ? new Worker(objURL, {}) : new Worker("data:application/javascript;base64," + encodedJs, { type: "module" });
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
const absurdWebBackend = ({
  wasmUrl,
  queryTimeout,
  pageSize,
  cacheSize
}) => ({
  dbName,
  stopped$
}) => {
  const initializedWorker = new WorkerWrapper();
  const messagesToWorker$ = new Subject();
  messagesToWorker$.pipe(takeUntil(stopped$)).subscribe((mes) => {
    initializedWorker.postMessage(mes);
  });
  const messagesFromWorker$ = new Observable((obs) => {
    const sub = (ev) => {
      obs.next(ev.data);
    };
    initializedWorker.addEventListener("message", sub);
    return () => {
      initializedWorker.removeEventListener("message", sub);
    };
  }).pipe(share({
    connector: () => new ReplaySubject(20),
    resetOnRefCountZero: false
  }), takeUntil(stopped$));
  stopped$.pipe(first()).subscribe(() => {
    initializedWorker.terminate();
  });
  const state = {
    messagesToWorker$,
    messagesFromWorker$,
    stop$: stopped$,
    queryTimeout: queryTimeout || 3e4
  };
  return {
    async initialize() {
      initBackend(initializedWorker);
      const initPromise = firstValueFrom(messagesFromWorker$.pipe(filter((ev) => ev.type === "initialized"), takeUntil(stopped$)));
      const url = typeof wasmUrl === "string" ? wasmUrl : await wasmUrl();
      messagesToWorker$.next({
        type: "initialize",
        dbName,
        wasmUrl: new URL(url, document.baseURI).toString(),
        pageSize: pageSize !== void 0 ? pageSize : 32 * 1024,
        cacheSize: cacheSize !== void 0 ? cacheSize : -5e3
      });
      await initPromise;
    },
    async execQueries(queries, opts) {
      return await runWorkerCommand(state, buildRunQueriesCommand(queries, opts));
    }
  };
};
function decodeBase64(base64, enableUnicode) {
  var binaryString = atob(base64);
  if (enableUnicode) {
    var binaryView = new Uint8Array(binaryString.length);
    for (var i = 0, n = binaryString.length; i < n; ++i) {
      binaryView[i] = binaryString.charCodeAt(i);
    }
    return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));
  }
  return binaryString;
}
function createURL(base64, sourcemapArg, enableUnicodeArg) {
  var sourcemap = sourcemapArg === void 0 ? null : sourcemapArg;
  var enableUnicode = enableUnicodeArg === void 0 ? false : enableUnicodeArg;
  var source = decodeBase64(base64, enableUnicode);
  var start = source.indexOf("\n", 10) + 1;
  var body = source.substring(start) + (sourcemap ? "//# sourceMappingURL=" + sourcemap : "");
  var blob2 = new Blob([body], { type: "application/javascript" });
  return URL.createObjectURL(blob2);
}
function createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {
  var url;
  return function WorkerFactory2(options) {
    url = url || createURL(base64, sourcemapArg, enableUnicodeArg);
    return new Worker(url, options);
  };
}
var WorkerFactory = createBase64WorkerFactory("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7bGV0IHQ9MzczNTkyODU1OTtjbGFzcyBle2NvbnN0cnVjdG9yKHQse2luaXRpYWxPZmZzZXQ6ZT00LHVzZUF0b21pY3M6aT0hMCxzdHJlYW06cz0hMCxkZWJ1ZzpyLG5hbWU6bn09e30pe3RoaXMuYnVmZmVyPXQsdGhpcy5hdG9taWNWaWV3PW5ldyBJbnQzMkFycmF5KHQpLHRoaXMub2Zmc2V0PWUsdGhpcy51c2VBdG9taWNzPWksdGhpcy5zdHJlYW09cyx0aGlzLmRlYnVnPXIsdGhpcy5uYW1lPW59bG9nKC4uLnQpe3RoaXMuZGVidWcmJmNvbnNvbGUubG9nKGBbcmVhZGVyOiAke3RoaXMubmFtZX1dYCwuLi50KX13YWl0V3JpdGUodCxlPW51bGwpe2lmKHRoaXMudXNlQXRvbWljcyl7Zm9yKHRoaXMubG9nKGB3YWl0aW5nIGZvciAke3R9YCk7MD09PUF0b21pY3MubG9hZCh0aGlzLmF0b21pY1ZpZXcsMCk7KXtpZihudWxsIT1lJiYidGltZWQtb3V0Ij09PUF0b21pY3Mud2FpdCh0aGlzLmF0b21pY1ZpZXcsMCwwLGUpKXRocm93IG5ldyBFcnJvcigidGltZW91dCIpO0F0b21pY3Mud2FpdCh0aGlzLmF0b21pY1ZpZXcsMCwwLDUwMCl9dGhpcy5sb2coYHJlc3VtZWQgZm9yICR7dH1gKX1lbHNlIGlmKDEhPT10aGlzLmF0b21pY1ZpZXdbMF0pdGhyb3cgbmV3IEVycm9yKCJgd2FpdFdyaXRlYCBleHBlY3RlZCBhcnJheSB0byBiZSByZWFkYWJsZSIpfWZsaXAoKXtpZih0aGlzLmxvZygiZmxpcCIpLHRoaXMudXNlQXRvbWljcyl7aWYoMSE9PUF0b21pY3MuY29tcGFyZUV4Y2hhbmdlKHRoaXMuYXRvbWljVmlldywwLDEsMCkpdGhyb3cgbmV3IEVycm9yKCJSZWFkIGRhdGEgb3V0IG9mIHN5bmMhIFRoaXMgaXMgZGlzYXN0cm91cyIpO0F0b21pY3Mubm90aWZ5KHRoaXMuYXRvbWljVmlldywwKX1lbHNlIHRoaXMuYXRvbWljVmlld1swXT0wO3RoaXMub2Zmc2V0PTR9ZG9uZSgpe3RoaXMud2FpdFdyaXRlKCJkb25lIik7bGV0IGU9bmV3IERhdGFWaWV3KHRoaXMuYnVmZmVyLHRoaXMub2Zmc2V0KS5nZXRVaW50MzIoMCk9PT10O3JldHVybiBlJiYodGhpcy5sb2coImRvbmUiKSx0aGlzLmZsaXAoKSksZX1wZWVrKHQpe3RoaXMucGVla09mZnNldD10aGlzLm9mZnNldDtsZXQgZT10KCk7cmV0dXJuIHRoaXMub2Zmc2V0PXRoaXMucGVla09mZnNldCx0aGlzLnBlZWtPZmZzZXQ9bnVsbCxlfXN0cmluZyh0KXt0aGlzLndhaXRXcml0ZSgic3RyaW5nIix0KTtsZXQgZT10aGlzLl9pbnQzMigpLGk9ZS8yLHM9bmV3IERhdGFWaWV3KHRoaXMuYnVmZmVyLHRoaXMub2Zmc2V0LGUpLHI9W107Zm9yKGxldCB0PTA7dDxpO3QrKylyLnB1c2gocy5nZXRVaW50MTYoMip0KSk7bGV0IG49U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLHIpO3JldHVybiB0aGlzLmxvZygic3RyaW5nIixuKSx0aGlzLm9mZnNldCs9ZSxudWxsPT10aGlzLnBlZWtPZmZzZXQmJnRoaXMuZmxpcCgpLG59X2ludDMyKCl7bGV0IHQ9bmV3IERhdGFWaWV3KHRoaXMuYnVmZmVyLHRoaXMub2Zmc2V0KS5nZXRJbnQzMigpO3JldHVybiB0aGlzLmxvZygiX2ludDMyIix0KSx0aGlzLm9mZnNldCs9NCx0fWludDMyKCl7dGhpcy53YWl0V3JpdGUoImludDMyIik7bGV0IHQ9dGhpcy5faW50MzIoKTtyZXR1cm4gdGhpcy5sb2coImludDMyIix0KSxudWxsPT10aGlzLnBlZWtPZmZzZXQmJnRoaXMuZmxpcCgpLHR9Ynl0ZXMoKXt0aGlzLndhaXRXcml0ZSgiYnl0ZXMiKTtsZXQgdD10aGlzLl9pbnQzMigpLGU9bmV3IEFycmF5QnVmZmVyKHQpO3JldHVybiBuZXcgVWludDhBcnJheShlKS5zZXQobmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIsdGhpcy5vZmZzZXQsdCkpLHRoaXMubG9nKCJieXRlcyIsZSksdGhpcy5vZmZzZXQrPXQsbnVsbD09dGhpcy5wZWVrT2Zmc2V0JiZ0aGlzLmZsaXAoKSxlfX1jbGFzcyBpe2NvbnN0cnVjdG9yKHQse2luaXRpYWxPZmZzZXQ6ZT00LHVzZUF0b21pY3M6aT0hMCxzdHJlYW06cz0hMCxkZWJ1ZzpyLG5hbWU6bn09e30pe3RoaXMuYnVmZmVyPXQsdGhpcy5hdG9taWNWaWV3PW5ldyBJbnQzMkFycmF5KHQpLHRoaXMub2Zmc2V0PWUsdGhpcy51c2VBdG9taWNzPWksdGhpcy5zdHJlYW09cyx0aGlzLmRlYnVnPXIsdGhpcy5uYW1lPW4sdGhpcy51c2VBdG9taWNzP0F0b21pY3Muc3RvcmUodGhpcy5hdG9taWNWaWV3LDAsMCk6dGhpcy5hdG9taWNWaWV3WzBdPTB9bG9nKC4uLnQpe3RoaXMuZGVidWcmJmNvbnNvbGUubG9nKGBbd3JpdGVyOiAke3RoaXMubmFtZX1dYCwuLi50KX13YWl0UmVhZCh0KXtpZih0aGlzLnVzZUF0b21pY3Mpe2lmKHRoaXMubG9nKGB3YWl0aW5nIGZvciAke3R9YCksMCE9PUF0b21pY3MuY29tcGFyZUV4Y2hhbmdlKHRoaXMuYXRvbWljVmlldywwLDAsMSkpdGhyb3cgbmV3IEVycm9yKCJXcm90ZSBzb21ldGhpbmcgaW50byB1bndyaXRhYmxlIGJ1ZmZlciEgVGhpcyBpcyBkaXNhc3Ryb3VzIik7Zm9yKEF0b21pY3Mubm90aWZ5KHRoaXMuYXRvbWljVmlldywwKTsxPT09QXRvbWljcy5sb2FkKHRoaXMuYXRvbWljVmlldywwKTspQXRvbWljcy53YWl0KHRoaXMuYXRvbWljVmlldywwLDEsNTAwKTt0aGlzLmxvZyhgcmVzdW1lZCBmb3IgJHt0fWApfWVsc2UgdGhpcy5hdG9taWNWaWV3WzBdPTE7dGhpcy5vZmZzZXQ9NH1maW5hbGl6ZSgpe3RoaXMubG9nKCJmaW5hbGl6aW5nIiksbmV3IERhdGFWaWV3KHRoaXMuYnVmZmVyLHRoaXMub2Zmc2V0KS5zZXRVaW50MzIoMCx0KSx0aGlzLndhaXRSZWFkKCJmaW5hbGl6ZSIpfXN0cmluZyh0KXt0aGlzLmxvZygic3RyaW5nIix0KTtsZXQgZT0yKnQubGVuZ3RoO3RoaXMuX2ludDMyKGUpO2xldCBpPW5ldyBEYXRhVmlldyh0aGlzLmJ1ZmZlcix0aGlzLm9mZnNldCxlKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylpLnNldFVpbnQxNigyKmUsdC5jaGFyQ29kZUF0KGUpKTt0aGlzLm9mZnNldCs9ZSx0aGlzLndhaXRSZWFkKCJzdHJpbmciKX1faW50MzIodCl7bmV3IERhdGFWaWV3KHRoaXMuYnVmZmVyLHRoaXMub2Zmc2V0KS5zZXRJbnQzMigwLHQpLHRoaXMub2Zmc2V0Kz00fWludDMyKHQpe3RoaXMubG9nKCJpbnQzMiIsdCksdGhpcy5faW50MzIodCksdGhpcy53YWl0UmVhZCgiaW50MzIiKX1ieXRlcyh0KXt0aGlzLmxvZygiYnl0ZXMiLHQpO2xldCBlPXQuYnl0ZUxlbmd0aDt0aGlzLl9pbnQzMihlKSxuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcix0aGlzLm9mZnNldCkuc2V0KG5ldyBVaW50OEFycmF5KHQpKSx0aGlzLm9mZnNldCs9ZSx0aGlzLndhaXRSZWFkKCJieXRlcyIpfX1sZXQgcz0wLHI9MSxuPTIsbz00O2xldCBhPS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksbD1uZXcgTWFwLGM9bmV3IE1hcDtmdW5jdGlvbiBoKHQsZSl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKGUpfWNsYXNzIGZ7Y29uc3RydWN0b3IodCxlPSJyZWFkb25seSIpe3RoaXMuZGI9dCx0aGlzLnRyYW5zPXRoaXMuZGIudHJhbnNhY3Rpb24oWyJkYXRhIl0sZSksdGhpcy5zdG9yZT10aGlzLnRyYW5zLm9iamVjdFN0b3JlKCJkYXRhIiksdGhpcy5sb2NrVHlwZT0icmVhZG9ubHkiPT09ZT9yOm8sdGhpcy5jYWNoZWRGaXJzdEJsb2NrPW51bGwsdGhpcy5jdXJzb3I9bnVsbCx0aGlzLnByZXZSZWFkcz1udWxsfWFzeW5jIHByZWZldGNoRmlyc3RCbG9jayh0KXtsZXQgZT1hd2FpdCB0aGlzLmdldCgwKTtyZXR1cm4gdGhpcy5jYWNoZWRGaXJzdEJsb2NrPWUsZX1hc3luYyB3YWl0Q29tcGxldGUoKXtyZXR1cm4gbmV3IFByb21pc2UoKCh0LGUpPT57dGhpcy5jb21taXQoKSx0aGlzLmxvY2tUeXBlPT09bz8odGhpcy50cmFucy5vbmNvbXBsZXRlPWU9PnQoKSx0aGlzLnRyYW5zLm9uZXJyb3I9dD0+ZSh0KSk6YT90aGlzLnRyYW5zLm9uY29tcGxldGU9ZT0+dCgpOnQoKX0pKX1jb21taXQoKXt0aGlzLnRyYW5zLmNvbW1pdCYmdGhpcy50cmFucy5jb21taXQoKX1hc3luYyB1cGdyYWRlRXhjbHVzaXZlKCl7dGhpcy5jb21taXQoKSx0aGlzLnRyYW5zPXRoaXMuZGIudHJhbnNhY3Rpb24oWyJkYXRhIl0sInJlYWR3cml0ZSIpLHRoaXMuc3RvcmU9dGhpcy50cmFucy5vYmplY3RTdG9yZSgiZGF0YSIpLHRoaXMubG9ja1R5cGU9bztsZXQgdD10aGlzLmNhY2hlZEZpcnN0QmxvY2s7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7aWYobnVsbCE9dCYmbnVsbCE9ZSl7bGV0IGk9bmV3IFVpbnQ4QXJyYXkodCkscz1uZXcgVWludDhBcnJheShlKTtmb3IobGV0IHQ9MjQ7dDw0MDt0KyspaWYoaVt0XSE9PXNbdF0pcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIG51bGw9PXQmJm51bGw9PWV9KGF3YWl0IHRoaXMucHJlZmV0Y2hGaXJzdEJsb2NrKDUwMCksdCl9ZG93bmdyYWRlU2hhcmVkKCl7dGhpcy5jb21taXQoKSx0aGlzLnRyYW5zPXRoaXMuZGIudHJhbnNhY3Rpb24oWyJkYXRhIl0sInJlYWRvbmx5IiksdGhpcy5zdG9yZT10aGlzLnRyYW5zLm9iamVjdFN0b3JlKCJkYXRhIiksdGhpcy5sb2NrVHlwZT1yfWFzeW5jIGdldCh0KXtyZXR1cm4gbmV3IFByb21pc2UoKChlLGkpPT57bGV0IHM9dGhpcy5zdG9yZS5nZXQodCk7cy5vbnN1Y2Nlc3M9dD0+e2Uocy5yZXN1bHQpfSxzLm9uZXJyb3I9dD0+aSh0KX0pKX1nZXRSZWFkRGlyZWN0aW9uKCl7bGV0IHQ9dGhpcy5wcmV2UmVhZHM7aWYodCl7aWYodFswXTx0WzFdJiZ0WzFdPHRbMl0mJnRbMl0tdFswXTwxMClyZXR1cm4ibmV4dCI7aWYodFswXT50WzFdJiZ0WzFdPnRbMl0mJnRbMF0tdFsyXTwxMClyZXR1cm4icHJldiJ9cmV0dXJuIG51bGx9cmVhZCh0KXtsZXQgZT0oKT0+bmV3IFByb21pc2UoKCh0LGUpPT57aWYobnVsbCE9dGhpcy5jdXJzb3JQcm9taXNlKXRocm93IG5ldyBFcnJvcigid2FpdEN1cnNvcigpIGNhbGxlZCBidXQgc29tZXRoaW5nIGVsc2UgaXMgYWxyZWFkeSB3YWl0aW5nIik7dGhpcy5jdXJzb3JQcm9taXNlPXtyZXNvbHZlOnQscmVqZWN0OmV9fSkpO2lmKHRoaXMuY3Vyc29yKXtsZXQgaT10aGlzLmN1cnNvcjtyZXR1cm4ibmV4dCI9PT1pLmRpcmVjdGlvbiYmdD5pLmtleSYmdDxpLmtleSsxMDA/KGkuYWR2YW5jZSh0LWkua2V5KSxlKCkpOiJwcmV2Ij09PWkuZGlyZWN0aW9uJiZ0PGkua2V5JiZ0Pmkua2V5LTEwMD8oaS5hZHZhbmNlKGkua2V5LXQpLGUoKSk6KHRoaXMuY3Vyc29yPW51bGwsdGhpcy5yZWFkKHQpKX17bGV0IGk9dGhpcy5nZXRSZWFkRGlyZWN0aW9uKCk7aWYoaSl7bGV0IHM7dGhpcy5wcmV2UmVhZHM9bnVsbCxzPSJwcmV2Ij09PWk/SURCS2V5UmFuZ2UudXBwZXJCb3VuZCh0KTpJREJLZXlSYW5nZS5sb3dlckJvdW5kKHQpO2xldCByPXRoaXMuc3RvcmUub3BlbkN1cnNvcihzLGkpO3JldHVybiByLm9uc3VjY2Vzcz10PT57bGV0IGU9dC50YXJnZXQucmVzdWx0O2lmKHRoaXMuY3Vyc29yPWUsbnVsbD09dGhpcy5jdXJzb3JQcm9taXNlKXRocm93IG5ldyBFcnJvcigiR290IGRhdGEgZnJvbSBjdXJzb3IgYnV0IG5vdGhpbmcgaXMgd2FpdGluZyBpdCIpO3RoaXMuY3Vyc29yUHJvbWlzZS5yZXNvbHZlKGU/ZS52YWx1ZTpudWxsKSx0aGlzLmN1cnNvclByb21pc2U9bnVsbH0sci5vbmVycm9yPXQ9PntpZihjb25zb2xlLmxvZygiQ3Vyc29yIGZhaWx1cmU6Iix0KSxudWxsPT10aGlzLmN1cnNvclByb21pc2UpdGhyb3cgbmV3IEVycm9yKCJHb3QgZGF0YSBmcm9tIGN1cnNvciBidXQgbm90aGluZyBpcyB3YWl0aW5nIGl0Iik7dGhpcy5jdXJzb3JQcm9taXNlLnJlamVjdCh0KSx0aGlzLmN1cnNvclByb21pc2U9bnVsbH0sZSgpfXJldHVybiBudWxsPT10aGlzLnByZXZSZWFkcyYmKHRoaXMucHJldlJlYWRzPVswLDAsMF0pLHRoaXMucHJldlJlYWRzLnB1c2godCksdGhpcy5wcmV2UmVhZHMuc2hpZnQoKSx0aGlzLmdldCh0KX19YXN5bmMgc2V0KHQpe3JldHVybiB0aGlzLnByZXZSZWFkcz1udWxsLG5ldyBQcm9taXNlKCgoZSxpKT0+e2xldCBzPXRoaXMuc3RvcmUucHV0KHQudmFsdWUsdC5rZXkpO3Mub25zdWNjZXNzPXQ9PmUocy5yZXN1bHQpLHMub25lcnJvcj10PT5pKHQpfSkpfWFzeW5jIGJ1bGtTZXQodCl7dGhpcy5wcmV2UmVhZHM9bnVsbCxhd2FpdCBQcm9taXNlLmFsbCh0Lm1hcCgodD0+dGhpcy5zZXQodCkpKSl9fWFzeW5jIGZ1bmN0aW9uIHUodCl7cmV0dXJuIG5ldyBQcm9taXNlKCgoZSxpKT0+e2lmKGwuZ2V0KHQpKXJldHVybiB2b2lkIGUobC5nZXQodCkpO2xldCBzPWdsb2JhbFRoaXMuaW5kZXhlZERCLm9wZW4odCwyKTtzLm9uc3VjY2Vzcz1pPT57bGV0IHM9aS50YXJnZXQucmVzdWx0O3Mub252ZXJzaW9uY2hhbmdlPSgpPT57Y29uc29sZS5sb2coImNsb3NpbmcgYmVjYXVzZSB2ZXJzaW9uIGNoYW5nZWQiKSxzLmNsb3NlKCksbC5kZWxldGUodCl9LHMub25jbG9zZT0oKT0+e2wuZGVsZXRlKHQpfSxsLnNldCh0LHMpLGUocyl9LHMub251cGdyYWRlbmVlZGVkPXQ9PntsZXQgZT10LnRhcmdldC5yZXN1bHQ7ZS5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCJkYXRhIil8fGUuY3JlYXRlT2JqZWN0U3RvcmUoImRhdGEiKX0scy5vbmJsb2NrZWQ9dD0+Y29uc29sZS5sb2coImJsb2NrZWQiLHQpLHMub25lcnJvcj1zLm9uYWJvcnQ9dD0+aSh0LnRhcmdldC5lcnJvcil9KSl9YXN5bmMgZnVuY3Rpb24gdyh0LGUsaSl7bGV0IHM9Yy5nZXQodCk7aWYocyl7aWYoInJlYWR3cml0ZSI9PT1lJiZzLmxvY2tUeXBlPT09cil0aHJvdyBuZXcgRXJyb3IoIkF0dGVtcHRlZCB3cml0ZSBidXQgb25seSBoYXMgU0hBUkVEIGxvY2siKTtyZXR1cm4gaShzKX1zPW5ldyBmKGF3YWl0IHUodCksZSksYXdhaXQgaShzKSxhd2FpdCBzLndhaXRDb21wbGV0ZSgpfWFzeW5jIGZ1bmN0aW9uIGQodCxlLGkpe2xldCBuPWZ1bmN0aW9uKHQpe3JldHVybiBjLmdldCh0KX0oZSk7aWYoaT09PXIpe2lmKG51bGw9PW4pdGhyb3cgbmV3IEVycm9yKCJVbmxvY2sgZXJyb3IgKFNIQVJFRCk6IG5vIHRyYW5zYWN0aW9uIHJ1bm5pbmciKTtuLmxvY2tUeXBlPT09byYmbi5kb3duZ3JhZGVTaGFyZWQoKX1lbHNlIGk9PT1zJiZuJiYoYXdhaXQgbi53YWl0Q29tcGxldGUoKSxjLmRlbGV0ZShlKSk7dC5pbnQzMigwKSx0LmZpbmFsaXplKCl9YXN5bmMgZnVuY3Rpb24gZyh0LGUpe2xldCBpPXQuc3RyaW5nKCk7c3dpdGNoKGkpe2Nhc2UicHJvZmlsZS1zdGFydCI6dC5kb25lKCksZS5pbnQzMigwKSxlLmZpbmFsaXplKCksZyh0LGUpO2JyZWFrO2Nhc2UicHJvZmlsZS1zdG9wIjp0LmRvbmUoKSxhd2FpdCBuZXcgUHJvbWlzZSgodD0+c2V0VGltZW91dCh0LDFlMykpKSxlLmludDMyKDApLGUuZmluYWxpemUoKSxnKHQsZSk7YnJlYWs7Y2FzZSJ3cml0ZUJsb2NrcyI6e2xldCBpPXQuc3RyaW5nKCkscz1bXTtmb3IoOyF0LmRvbmUoKTspe2xldCBlPXQuaW50MzIoKSxpPXQuYnl0ZXMoKTtzLnB1c2goe3BvczplLGRhdGE6aX0pfWF3YWl0IGFzeW5jIGZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gdyhlLCJyZWFkd3JpdGUiLChhc3luYyBlPT57YXdhaXQgZS5idWxrU2V0KGkubWFwKCh0PT4oe2tleTp0LnBvcyx2YWx1ZTp0LmRhdGF9KSkpKSx0LmludDMyKDApLHQuZmluYWxpemUoKX0pKX0oZSxpLHMpLGcodCxlKTticmVha31jYXNlInJlYWRCbG9jayI6e2xldCBpPXQuc3RyaW5nKCkscz10LmludDMyKCk7dC5kb25lKCksYXdhaXQgYXN5bmMgZnVuY3Rpb24odCxlLGkpe3JldHVybiB3KGUsInJlYWRvbmx5IiwoYXN5bmMgZT0+e2xldCBzPWF3YWl0IGUucmVhZChpKTtudWxsPT1zP3QuYnl0ZXMobmV3IEFycmF5QnVmZmVyKDApKTp0LmJ5dGVzKHMpLHQuZmluYWxpemUoKX0pKX0oZSxpLHMpLGcodCxlKTticmVha31jYXNlInJlYWRNZXRhIjp7bGV0IGk9dC5zdHJpbmcoKTt0LmRvbmUoKSxhd2FpdCBhc3luYyBmdW5jdGlvbih0LGUpe3JldHVybiB3KGUsInJlYWRvbmx5IiwoYXN5bmMgaT0+e3RyeXtjb25zb2xlLmxvZygiUmVhZGluZyBtZXRhLi4uIik7bGV0IHM9YXdhaXQgaS5nZXQoLTEpO2lmKGNvbnNvbGUubG9nKGBHb3QgbWV0YSBmb3IgJHtlfTpgLHMpLG51bGw9PXMpdC5pbnQzMigtMSksdC5pbnQzMig0MDk2KSx0LmZpbmFsaXplKCk7ZWxzZXtsZXQgZT1hd2FpdCBpLmdldCgwKSxyPTQwOTY7ZSYmKHI9MjU2Km5ldyBVaW50MTZBcnJheShlKVs4XSksdC5pbnQzMihzLnNpemUpLHQuaW50MzIociksdC5maW5hbGl6ZSgpfX1jYXRjaChlKXtjb25zb2xlLmxvZyhlKSx0LmludDMyKC0xKSx0LmludDMyKC0xKSx0LmZpbmFsaXplKCl9fSkpfShlLGkpLGcodCxlKTticmVha31jYXNlIndyaXRlTWV0YSI6e2xldCBpPXQuc3RyaW5nKCkscz10LmludDMyKCk7dC5kb25lKCksYXdhaXQgYXN5bmMgZnVuY3Rpb24odCxlLGkpe3JldHVybiB3KGUsInJlYWR3cml0ZSIsKGFzeW5jIGU9Pnt0cnl7YXdhaXQgZS5zZXQoe2tleTotMSx2YWx1ZTppfSksdC5pbnQzMigwKSx0LmZpbmFsaXplKCl9Y2F0Y2goZSl7Y29uc29sZS5sb2coZSksdC5pbnQzMigtMSksdC5maW5hbGl6ZSgpfX0pKX0oZSxpLHtzaXplOnN9KSxnKHQsZSk7YnJlYWt9Y2FzZSJjbG9zZUZpbGUiOntsZXQgaT10LnN0cmluZygpO3QuZG9uZSgpLGUuaW50MzIoMCksZS5maW5hbGl6ZSgpLGZ1bmN0aW9uKHQpe2xldCBlPWwuZ2V0KHQpO2UmJihlLmNsb3NlKCksbC5kZWxldGUodCkpfShpKSxzZWxmLmNsb3NlKCk7YnJlYWt9Y2FzZSJsb2NrRmlsZSI6e2xldCBpPXQuc3RyaW5nKCkscz10LmludDMyKCk7dC5kb25lKCksYXdhaXQgYXN5bmMgZnVuY3Rpb24odCxlLGkpe2xldCBzPWMuZ2V0KGUpO2lmKHMpaWYoaT5zLmxvY2tUeXBlKXtoKHMubG9ja1R5cGU9PT1yLGBVcHJhZGluZyBsb2NrIHR5cGUgZnJvbSAke3MubG9ja1R5cGV9IGlzIGludmFsaWRgKSxoKGk9PT1ufHxpPT09byxgVXBncmFkaW5nIGxvY2sgdHlwZSB0byAke2l9IGlzIGludmFsaWRgKTtsZXQgZT1hd2FpdCBzLnVwZ3JhZGVFeGNsdXNpdmUoKTt0LmludDMyKGU/MDotMSksdC5maW5hbGl6ZSgpfWVsc2UgaChzLmxvY2tUeXBlPT09aSxgRG93bmdyYWRpbmcgbG9jayB0byAke2l9IGlzIGludmFsaWRgKSx0LmludDMyKDApLHQuZmluYWxpemUoKTtlbHNle2goaT09PXIsYE5ldyBsb2NrcyBtdXN0IHN0YXJ0IGFzIFNIQVJFRCBpbnN0ZWFkIG9mICR7aX1gKTtsZXQgcz1uZXcgZihhd2FpdCB1KGUpKTthd2FpdCBzLnByZWZldGNoRmlyc3RCbG9jayg1MDApLGMuc2V0KGUscyksdC5pbnQzMigwKSx0LmZpbmFsaXplKCl9fShlLGkscyksZyh0LGUpO2JyZWFrfWNhc2UidW5sb2NrRmlsZSI6e2xldCBpPXQuc3RyaW5nKCkscz10LmludDMyKCk7dC5kb25lKCksYXdhaXQgZChlLGkscyksZyh0LGUpO2JyZWFrfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJVbmtub3duIG1ldGhvZDogIitpKX19c2VsZi5vbm1lc3NhZ2U9dD0+e3N3aXRjaCh0LmRhdGEudHlwZSl7Y2FzZSJpbml0Ijp7bGV0W3Mscl09dC5kYXRhLmJ1ZmZlcnM7ZyhuZXcgZShzLHtuYW1lOiJhcmdzIixkZWJ1ZzohMX0pLG5ldyBpKHIse25hbWU6InJlc3VsdHMiLGRlYnVnOiExfSkpO2JyZWFrfX19fSgpOwoK", null, false);
var indexeddbMainThreadWorkerD62f296a = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": WorkerFactory
}, Symbol.toStringTag, { value: "Module" }));
export { absurdWebBackend, buildRunQueriesCommand, runWorkerCommand };
//# sourceMappingURL=index.es.js.map
