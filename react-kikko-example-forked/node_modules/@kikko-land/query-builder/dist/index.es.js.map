{"version":3,"file":"index.es.js","sources":["../src/types.ts","../src/tokens/rawSql.ts","../src/tokens/binary.ts","../src/tokens/utils.ts","../src/tokens/alias.ts","../src/tokens/join.ts","../src/tokens/order.ts","../src/tokens/cte.ts","../src/tokens/returning.ts","../src/tokens/where.ts","../src/tokens/statements/delete.ts","../src/tokens/orReplace.ts","../src/tokens/limitOffset.ts","../src/tokens/statements/values.ts","../src/tokens/compounds.ts","../src/tokens/from.ts","../src/tokens/statements/select.ts","../src/tokens/statements/insert.ts","../src/tokens/statements/update.ts","../src/tokens/unary.ts"],"sourcesContent":["import { ISql } from \"@kikko-land/sql\";\n\nexport enum TokenType {\n  Binary = \"Binary\",\n  Unary = \"Unary\",\n  Alias = \"Alias\",\n  Compound = \"Compound\",\n  Select = \"Select\",\n  Update = \"Update\",\n  Delete = \"Delete\",\n  Insert = \"Insert\",\n  Values = \"Values\",\n  OrderTerm = \"OrderTerm\",\n  LimitOffsetTerm = \"LimitOffsetTerm\",\n  RawSql = \"RawSql\",\n  CompoundOperator = \"CompoundOperator\",\n  CTE = \"CTE\",\n  Join = \"Join\",\n  Returning = \"Returning\",\n}\n\nexport interface IBaseToken<T extends TokenType = TokenType> {\n  type: T;\n  toSql(): ISql;\n}\n\nexport const isToken = (t: unknown): t is IBaseToken => {\n  return (\n    t !== null &&\n    typeof t === \"object\" &&\n    \"type\" in t &&\n    \"toSql\" in t &&\n    Object.values(TokenType).includes((t as IBaseToken).type)\n  );\n};\n\nexport function assertUnreachable(x: never): never {\n  throw new Error(`Didn't expect to get here: ${JSON.stringify(x)}`);\n}\n","import {\n  IContainsTable,\n  IPrimitiveValue,\n  ISqlAdapter,\n  sql,\n} from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../types\";\n\nexport const buildRawSql = (\n  t: ISqlAdapter | IContainsTable | IPrimitiveValue\n): IBaseToken<TokenType.RawSql> => {\n  return {\n    type: TokenType.RawSql,\n    toSql() {\n      return sql`${t}`;\n    },\n  };\n};\n\nexport const toToken = (\n  t: IBaseToken | ISqlAdapter | IPrimitiveValue | IContainsTable\n): IBaseToken => {\n  if (isToken(t)) return t;\n\n  if (sql.isSql(t)) {\n    return buildRawSql(t);\n  }\n\n  return buildRawSql(t);\n};\n","import { IPrimitiveValue, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../types\";\nimport { toToken } from \"./rawSql\";\nimport { wrapParentheses } from \"./utils\";\n\n// TODO: in null support\n// TODO: add ESCAPE for LIKE/NOT LIKE\nexport interface IBinaryOperator extends IBaseToken<TokenType.Binary> {\n  _operator:\n    | \"<\"\n    | \"<=\"\n    | \">\"\n    | \">=\"\n    | \"=\"\n    | \"<>\"\n    | \"AND\"\n    | \"OR\"\n    | \"IN\"\n    | \"NOT IN\"\n    | \"LIKE\"\n    | \"NOT LIKE\"\n    // TODO: add all\n    | \"BETWEEN\"\n    | \"NOT BETWEEN\"\n    | \"GLOB\"\n    | \"NOT GLOB\"\n    | \"MATCH\"\n    | \"NOT MATCH\"\n    | \"REGEXP\"\n    | \"NOT REGEXP\";\n  _left: IBaseToken;\n  _right: IBaseToken | IBaseToken[];\n}\n\nexport const isBinaryOperator = (t: unknown): t is IBinaryOperator => {\n  return (\n    t !== null &&\n    typeof t === \"object\" &&\n    \"type\" in t &&\n    (t as IBinaryOperator).type === TokenType.Binary\n  );\n};\n\nconst binaryOperator = (\n  operator: IBinaryOperator[\"_operator\"],\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right:\n    | IBaseToken\n    | ISqlAdapter\n    | IPrimitiveValue\n    | (IBaseToken | ISqlAdapter | IPrimitiveValue)[]\n): IBinaryOperator => {\n  return {\n    type: TokenType.Binary,\n    _left: toToken(left),\n    _right: Array.isArray(right) ? right.map(toToken) : toToken(right),\n    _operator: operator,\n    toSql() {\n      return sql`${wrapParentheses(this._left)} ${sql.raw(this._operator)} ${\n        Array.isArray(this._right)\n          ? sql`(${sql.join(this._right)})`\n          : wrapParentheses(this._right)\n      }`;\n    },\n  };\n};\n\nexport const notEq$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) =>\n    notEq(left, right);\n};\nexport const notEq = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"<>\", left, right);\n};\n\nexport const eq$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => eq(left, right);\n};\nexport const eq = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"=\", left, right);\n};\n\nexport const gt$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => gt(left, right);\n};\nexport const gt = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\">\", left, right);\n};\n\nexport const gtEq$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) =>\n    gtEq(left, right);\n};\nexport const gtEq = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\">=\", left, right);\n};\n\nexport const lt$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => lt(left, right);\n};\nexport const lt = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"<\", left, right);\n};\n\nexport const ltEq$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) =>\n    ltEq(left, right);\n};\nexport const ltEq = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"<=\", left, right);\n};\n\nexport const like = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"LIKE\", left, right);\n};\nexport const like$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) =>\n    like(left, right);\n};\n\nexport const notLike = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"NOT LIKE\", left, right);\n};\nexport const notLike$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) =>\n    notLike(left, right);\n};\n\nexport const In = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  ...right: (IBaseToken | ISqlAdapter | IPrimitiveValue)[]\n) => {\n  return binaryOperator(\"IN\", left, right);\n};\nexport const notIn = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  ...right: (IBaseToken | ISqlAdapter | IPrimitiveValue)[]\n) => {\n  return binaryOperator(\"NOT IN\", left, right);\n};\n\nexport const in$ =\n  (...values: (IBaseToken | ISqlAdapter | IPrimitiveValue)[]) =>\n  (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n    return In(left, ...values);\n  };\nexport const notIn$ =\n  (...values: (IBaseToken | ISqlAdapter | IPrimitiveValue)[]) =>\n  (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n    return notIn(left, ...values);\n  };\n\nexport type IConditionValue =\n  | IBaseToken\n  | ISqlAdapter\n  | Record<\n      string,\n      | ((left: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator)\n      | IBaseToken\n      | ISqlAdapter\n      | IPrimitiveValue\n    >;\n\nexport const conditionValuesToToken = (values: IConditionValue[]) => {\n  return values\n    .flatMap((v) =>\n      isToken(v) || sql.isSql(v)\n        ? toToken(v)\n        : Object.entries(v).map(([k, expr]) =>\n            toToken(\n              typeof expr === \"function\"\n                ? expr(sql.liter(k))\n                : eq(sql.liter(k), expr)\n            )\n          )\n    )\n    .filter((v) => !v.toSql().isEmpty);\n};\n\nconst conditionOperator = (\n  type: \"AND\" | \"OR\",\n  ...values: IConditionValue[]\n): IBinaryOperator => {\n  const exprs = conditionValuesToToken(values);\n\n  if (exprs.length <= 1) {\n    throw new Error(\"Must at least two arguments present\");\n  }\n\n  let current = binaryOperator(type, exprs[0], exprs[1]);\n\n  for (const next of exprs.slice(2)) {\n    current = binaryOperator(type, current, next);\n  }\n\n  return current;\n};\n\nexport const and = (...values: IConditionValue[]): IBinaryOperator => {\n  return conditionOperator(\"AND\", ...values);\n};\n\nexport const or = (...values: IConditionValue[]): IBinaryOperator => {\n  return conditionOperator(\"OR\", ...values);\n};\n","import {\n  IContainsTable,\n  IPrimitiveValue,\n  ISql,\n  ISqlAdapter,\n  sql,\n} from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../types\";\nimport { isBinaryOperator } from \"./binary\";\n\nexport const wrapParentheses = <\n  T extends IBaseToken | ISqlAdapter | IPrimitiveValue | IContainsTable\n>(\n  val: T\n): T | ISql =>\n  (isBinaryOperator(val) && val._operator === \"OR\") ||\n  (isToken(val) &&\n    (val.type === TokenType.Select || val.type === TokenType.Values))\n    ? sql`(${val})`\n    : val;\n","import {\n  IContainsTable,\n  IPrimitiveValue,\n  ISqlAdapter,\n  sql,\n} from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\nimport { toToken } from \"./rawSql\";\nimport { wrapParentheses } from \"./utils\";\n\nexport type IAlias = IBaseToken<TokenType.Alias> & {\n  _left: IBaseToken;\n  _right: string;\n};\n\nexport const alias = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue | IContainsTable,\n  right: string\n): IAlias => {\n  return {\n    type: TokenType.Alias,\n    _left: toToken(left),\n    _right: right,\n    toSql() {\n      return sql`${wrapParentheses(this._left)} AS ${sql.liter(this._right)}`;\n    },\n  };\n};\n","import { IContainsTable, ISqlAdapter, sql } from \"@kikko-land/sql\";\nimport { isTable } from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../types\";\nimport { alias } from \"./alias\";\nimport { conditionValuesToToken, IConditionValue } from \"./binary\";\nimport { toToken } from \"./rawSql\";\nimport { ISelectStatement } from \"./statements/select\";\nimport { wrapParentheses } from \"./utils\";\n\ntype IJoinOperator =\n  | {\n      joinType: \"CROSS\";\n    }\n  | ({\n      isNatural: boolean;\n    } & (\n      | {\n          joinType: \"LEFT\" | \"RIGHT\" | \"FULL\";\n          isOuter: boolean;\n        }\n      | {\n          joinType: \"INNER\";\n        }\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | {}\n    ));\n\nexport interface IJoinExpr extends IBaseToken<TokenType.Join> {\n  _operator?: IJoinOperator;\n  _toJoin:\n    | IContainsTable\n    | IBaseToken\n    | { toSelect: IBaseToken; alias: string };\n  _on?: IConditionValue;\n}\n\nconst baseJoin = (\n  operator: IJoinOperator | undefined,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): IJoinExpr => {\n  return {\n    type: TokenType.Join,\n    _operator: operator,\n    _toJoin: (() => {\n      if (typeof toJoin === \"string\") {\n        return sql.table(toJoin);\n      } else if (isTable(toJoin)) {\n        return toJoin;\n      } else if (isToken(toJoin) || sql.isSql(toJoin)) {\n        return toToken(toJoin);\n      } else {\n        const entries = Object.entries(toJoin);\n        if (entries.length === 0) {\n          throw new Error(\"No alias select present for join\");\n        }\n        if (entries.length > 1) {\n          throw new Error(\"Only one select could be specified at join\");\n        }\n        return { toSelect: toToken(entries[0][1]), alias: entries[0][0] };\n      }\n    })(),\n    _on: on,\n\n    toSql() {\n      const operatorSql = (() => {\n        if (!this._operator) return [sql`JOIN`];\n\n        if (\"joinType\" in this._operator) {\n          if (this._operator.joinType === \"CROSS\") {\n            return [sql`CROSS JOIN`] as const;\n          } else {\n            return [\n              this._operator.isNatural ? sql`NATURAL` : undefined,\n              sql.raw(this._operator.joinType),\n              \"isOuter\" in this._operator && this._operator.isOuter\n                ? sql`OUTER`\n                : undefined,\n              sql`JOIN`,\n            ] as const;\n          }\n        } else {\n          return [\n            this._operator.isNatural ? sql`NATURAL` : undefined,\n            sql`JOIN`,\n          ] as const;\n        }\n      })().flatMap((v) => (v === undefined ? [] : v));\n\n      return sql.join(\n        [\n          ...operatorSql,\n          \"toSelect\" in this._toJoin\n            ? alias(this._toJoin.toSelect, this._toJoin.alias)\n            : wrapParentheses(this._toJoin),\n          ...(this._on ? [sql`ON`, ...conditionValuesToToken([this._on])] : []),\n        ],\n        \" \"\n      );\n    },\n  };\n};\n\ntype IToJoinArg =\n  | IBaseToken\n  | ISqlAdapter\n  | IContainsTable\n  | string\n  | { [key: string]: ISqlAdapter | ISelectStatement | string };\n\nexport interface IJoinState {\n  _joinValues: IJoinExpr[];\n\n  withoutJoin: typeof withoutJoin;\n\n  join: typeof join;\n  joinCross: typeof joinCross;\n\n  joinNatural: typeof joinNatural;\n\n  joinLeft: typeof joinLeft;\n  joinLeftOuter: typeof joinLeftOuter;\n  joinLeftNatural: typeof joinLeftNatural;\n  joinLeftNaturalOuter: typeof joinLeftNaturalOuter;\n\n  joinRight: typeof joinRight;\n  joinRightOuter: typeof joinRightOuter;\n  joinRightNatural: typeof joinRightNatural;\n  joinRightNaturalOuter: typeof joinRightNaturalOuter;\n\n  joinFull: typeof joinFull;\n  joinFullOuter: typeof joinFullOuter;\n  joinFullNatural: typeof joinFullNatural;\n  joinFullNaturalOuter: typeof joinFullNaturalOuter;\n\n  joinInner: typeof joinInner;\n  joinInnerNatural: typeof joinInnerNatural;\n}\n\nexport function join<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [...this._joinValues, baseJoin(undefined, toJoin, on)],\n  };\n}\n\nexport function joinCross<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ joinType: \"CROSS\" }, toJoin, on),\n    ],\n  };\n}\n\nexport function joinNatural<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: true }, toJoin, on),\n    ],\n  };\n}\n\nexport function joinLeftNatural<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: false, joinType: \"LEFT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\n\nexport function joinRightNatural<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: false, joinType: \"RIGHT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\n\nexport function joinFullNatural<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: false, joinType: \"FULL\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\n\nexport function joinLeftNaturalOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: true, joinType: \"LEFT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\nexport function joinRightNaturalOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: true, joinType: \"RIGHT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\nexport function joinFullNaturalOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: true, joinType: \"FULL\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\n\nexport function joinInnerNatural<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: true, joinType: \"INNER\" as const }, toJoin, on),\n    ],\n  };\n}\n\nexport function joinLeft<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: false, joinType: \"LEFT\" as const }, toJoin, on),\n    ],\n  };\n}\nexport function joinRight<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: false, joinType: \"RIGHT\" as const }, toJoin, on),\n    ],\n  };\n}\nexport function joinFull<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: false, joinType: \"FULL\" as const }, toJoin, on),\n    ],\n  };\n}\n\nexport function joinLeftOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: false, isOuter: true, joinType: \"LEFT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\nexport function joinRightOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: false, isOuter: true, joinType: \"RIGHT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\nexport function joinFullOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: false, isOuter: true, joinType: \"FULL\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\n\nexport function joinInner<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: false, joinType: \"INNER\" as const }, toJoin),\n      on,\n    ],\n  };\n}\n\nexport function withoutJoin<T extends IJoinState>(this: T): T {\n  return {\n    ...this,\n    _joinValues: [],\n  };\n}\n","import { ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\nimport { toToken } from \"./rawSql\";\n\nexport interface IOrderTerm extends IBaseToken<TokenType.OrderTerm> {\n  _orderType: \"DESC\" | \"ASC\";\n  _val: IBaseToken | string;\n  _nullOrder?: \"NULLS FIRST\" | \"NULLS LAST\";\n}\n\nconst orderTerm = (\n  type: IOrderTerm[\"_orderType\"],\n  val: IBaseToken | ISqlAdapter | string,\n  nullOrder: IOrderTerm[\"_nullOrder\"]\n): IOrderTerm => {\n  return {\n    type: TokenType.OrderTerm,\n    _orderType: type,\n    _val: typeof val === \"string\" ? val : toToken(val),\n    _nullOrder: nullOrder,\n    toSql() {\n      return sql.join(\n        [\n          typeof this._val === \"string\" ? sql.liter(this._val) : this._val,\n          sql.raw(this._orderType),\n          nullOrder ? sql.raw(nullOrder) : sql.empty,\n        ],\n        \" \"\n      );\n    },\n  };\n};\n\nexport const desc = (\n  val: IBaseToken | ISqlAdapter | string,\n  nullOrder?: \"NULLS FIRST\" | \"NULLS LAST\"\n) => {\n  return orderTerm(\"DESC\", val, nullOrder);\n};\n\nexport const asc = (\n  val: IBaseToken | ISqlAdapter | string,\n  nullOrder?: \"NULLS FIRST\" | \"NULLS LAST\"\n) => {\n  return orderTerm(\"ASC\", val, nullOrder);\n};\n\nexport interface IOrderState {\n  _orderByValues: IOrderTerm[];\n\n  orderBy: typeof orderBy;\n  withoutOrder: typeof withoutOrder;\n}\n\nexport function orderBy<T extends IOrderState>(\n  this: T,\n  ...orderTerm: IOrderTerm[]\n): T {\n  return {\n    ...this,\n    _orderByValues: [...this._orderByValues, ...orderTerm],\n  };\n}\n\nexport function withoutOrder<T extends IOrderState>(this: T): T {\n  return {\n    ...this,\n    _orderByValue: undefined,\n  };\n}\n","import { ISql, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\nimport { buildRawSql } from \"./rawSql\";\nimport { ISelectStatement } from \"./statements/select\";\nimport { IValuesStatement } from \"./statements/values\";\n\nexport interface ICTETerm extends IBaseToken<TokenType.CTE> {\n  _recursive: boolean;\n  _values: {\n    table: string;\n    columns: string[];\n    select: ISelectStatement | IValuesStatement | IBaseToken<TokenType.RawSql>;\n  }[];\n}\n\nexport interface ICTEState {\n  _cteValue?: ICTETerm;\n\n  with: typeof With;\n  withRecursive: typeof withRecursive;\n  withoutWith: typeof withoutWith;\n}\n\nconst cteTerm = (args: {\n  table: string;\n  columns: string[];\n  recursive: boolean;\n  select: ISelectStatement | IValuesStatement | IBaseToken<TokenType.RawSql>;\n}): ICTETerm => {\n  return {\n    type: TokenType.CTE,\n    _recursive: args.recursive,\n    _values: [\n      {\n        table: args.table,\n        columns: args.columns,\n        select: args.select,\n      },\n    ],\n    toSql() {\n      return sql.join(\n        [\n          sql`WITH`,\n          this._recursive ? sql`RECURSIVE` : null,\n          sql.join(\n            this._values.map(\n              (v) =>\n                sql`${sql.liter(v.table)}(${sql.join(\n                  v.columns.map(sql.liter)\n                )}) AS (${v.select})`\n            )\n          ),\n        ].filter((b) => b),\n        \" \"\n      );\n    },\n  };\n};\n\nconst cteTermState = <T extends ICTEState>(\n  state: T,\n  args: {\n    table: string;\n    columns: string[];\n    recursive: boolean;\n    select: ISelectStatement | IValuesStatement | ISql;\n  }\n): T => {\n  if (state._cteValue?._recursive === true && args.recursive === false) {\n    throw new Error(\"WITH is already recursive\");\n  }\n\n  if (state._cteValue?._recursive === false && args.recursive === true) {\n    throw new Error(\"WITH is not recursive\");\n  }\n\n  return {\n    ...state,\n    _cteValue: state._cteValue\n      ? {\n          ...state._cteValue,\n          values: [...state._cteValue._values, {}],\n        }\n      : cteTerm({\n          table: args.table,\n          columns: args.columns,\n          recursive: args.recursive,\n          select: sql.isSql(args.select)\n            ? buildRawSql(args.select)\n            : args.select,\n        }),\n  };\n};\n\nexport function With<T extends ICTEState>(\n  this: T,\n  args: {\n    table: string;\n    columns: string[];\n    select: ISelectStatement | IValuesStatement | ISql;\n  }\n): T {\n  return cteTermState(this, { ...args, recursive: false });\n}\n\nexport function withRecursive<T extends ICTEState>(\n  this: T,\n  args: {\n    table: string;\n    columns: string[];\n    select: ISelectStatement | IValuesStatement | ISql;\n  }\n): T {\n  return cteTermState(this, { ...args, recursive: true });\n}\n\nexport function withoutWith<T extends ICTEState>(this: T): T {\n  return { ...this, cteValue: undefined };\n}\n","import { ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../types\";\nimport { alias } from \"./alias\";\nimport { toToken } from \"./rawSql\";\nimport { ISelectStatement } from \"./statements/select\";\n\ntype IReturnValue = {\n  _toSelect: \"*\" | string | ISelectStatement | IBaseToken;\n  _alias?: string;\n};\nexport interface IReturningClause extends IBaseToken<TokenType.Returning> {\n  _values: IReturnValue[];\n}\n\ntype IReturningArg =\n  | \"*\"\n  | string\n  | ISqlAdapter\n  | IBaseToken\n  | { [key: string]: ISqlAdapter | string | ISelectStatement };\n\nexport interface IReturningState {\n  _returningValue: IReturningClause;\n\n  returning: typeof returningForState;\n  withoutReturning: typeof withoutReturningForState;\n}\n\nexport const returning = (...args: IReturningArg[]): IReturningClause => {\n  return {\n    type: TokenType.Returning,\n    _values: args.flatMap((arg): IReturnValue | IReturnValue[] => {\n      if (sql.isSql(arg) || isToken(arg)) {\n        return { _toSelect: toToken(arg) };\n      } else if (typeof arg === \"string\") {\n        return { _toSelect: arg };\n      } else {\n        return Object.entries(arg).map(([columnOrAs, aliasOrQuery]) => {\n          return typeof aliasOrQuery === \"string\"\n            ? { _toSelect: columnOrAs, _alias: aliasOrQuery }\n            : { _toSelect: toToken(aliasOrQuery), _alias: columnOrAs };\n        });\n      }\n    }),\n    toSql() {\n      return this._values.length > 0\n        ? sql`RETURNING ${sql.join(\n            this._values.map((val) => {\n              if (val._toSelect === \"*\") {\n                return sql`*`;\n              } else {\n                return val._alias\n                  ? alias(val._toSelect, val._alias)\n                  : val._toSelect;\n              }\n            })\n          )}`\n        : sql.empty;\n    },\n  };\n};\n\nexport function returningForState<T extends IReturningState>(\n  this: T,\n  ...args: IReturningArg[]\n): T {\n  return {\n    ...this,\n    _returningValue: {\n      ...this._returningValue,\n      _values: [...this._returningValue._values, ...returning(...args)._values],\n    },\n  };\n}\n\nexport function withoutReturningForState<T extends IReturningState>(\n  this: T\n): T {\n  return {\n    ...this,\n    _returningValue: returning(),\n  };\n}\n","import { IBaseToken, TokenType } from \"../types\";\nimport {\n  and,\n  conditionValuesToToken,\n  IBinaryOperator,\n  IConditionValue,\n  or,\n} from \"./binary\";\nimport { IUnaryOperator } from \"./unary\";\n\nexport interface IWhereState {\n  _whereValue?: IBaseToken<TokenType.RawSql> | IBinaryOperator | IUnaryOperator;\n\n  where: typeof where;\n  orWhere: typeof orWhere;\n}\n\nconst constructWhere = function <T extends IWhereState>(\n  state: T,\n  andOrOr: \"and\" | \"or\",\n  values: IConditionValue[]\n): T {\n  const finalValues = state._whereValue\n    ? [state._whereValue, ...conditionValuesToToken(values)]\n    : conditionValuesToToken(values);\n\n  if (finalValues.length > 1) {\n    return {\n      ...state,\n      _whereValue: andOrOr === \"and\" ? and(...finalValues) : or(...finalValues),\n    };\n  } else {\n    return { ...state, _whereValue: finalValues[0] };\n  }\n};\n\nexport function where<T extends IWhereState>(\n  this: T,\n  ...values: IConditionValue[]\n): T {\n  return constructWhere(this, \"and\", values);\n}\n\nexport function orWhere<T extends IWhereState>(\n  this: T,\n  ...values: IConditionValue[]\n): T {\n  return constructWhere(this, \"or\", values);\n}\n","import { IContainsTable, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../../types\";\nimport { ICTEState, With, withoutWith, withRecursive } from \"../cte\";\nimport {\n  IReturningState,\n  returning,\n  returningForState,\n  withoutReturningForState,\n} from \"../returning\";\nimport { IWhereState, orWhere, where } from \"../where\";\n\nexport interface IDeleteStatement\n  extends IBaseToken<TokenType.Delete>,\n    ICTEState,\n    IWhereState,\n    IReturningState {\n  _deleteTable: IContainsTable;\n}\n\nexport const deleteFrom = (tbl: string | IContainsTable): IDeleteStatement => {\n  return {\n    type: TokenType.Delete,\n    _deleteTable: typeof tbl === \"string\" ? sql.table(tbl) : tbl,\n    _returningValue: returning(),\n\n    with: With,\n    withoutWith,\n    withRecursive,\n\n    where,\n    orWhere,\n\n    returning: returningForState,\n    withoutReturning: withoutReturningForState,\n\n    toSql() {\n      return sql.join(\n        [\n          this._cteValue ? this._cteValue : null,\n          sql`DELETE FROM ${this._deleteTable}`,\n          this._whereValue ? sql`WHERE ${this._whereValue}` : null,\n          this._returningValue,\n        ].filter((v) => v),\n        \" \"\n      );\n    },\n  };\n};\n","export interface IOrReplaceState {\n  _orReplaceValue?: \"ABORT\" | \"FAIL\" | \"IGNORE\" | \"REPLACE\" | \"ROLLBACK\";\n\n  orAbort: typeof orAbort;\n  orFail: typeof orFail;\n  orIgnore: typeof orIgnore;\n  orReplace: typeof orReplace;\n  orRollback: typeof orRollback;\n}\n\nexport function orAbort<T extends IOrReplaceState>(this: T): T {\n  return { ...this, _orReplaceValue: \"ABORT\" };\n}\n\nexport function orFail<T extends IOrReplaceState>(this: T): T {\n  return { ...this, _orReplaceValue: \"FAIL\" };\n}\n\nexport function orIgnore<T extends IOrReplaceState>(this: T): T {\n  return { ...this, _orReplaceValue: \"IGNORE\" };\n}\n\nexport function orReplace<T extends IOrReplaceState>(this: T): T {\n  return { ...this, _orReplaceValue: \"REPLACE\" };\n}\n\nexport function orRollback<T extends IOrReplaceState>(this: T): T {\n  return { ...this, _orReplaceValue: \"ROLLBACK\" };\n}\n","import { IPrimitiveValue, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\nimport { toToken } from \"./rawSql\";\nimport { wrapParentheses } from \"./utils\";\n\nexport interface ILimitOffsetTerm\n  extends IBaseToken<TokenType.LimitOffsetTerm> {\n  _limitValue?: IBaseToken;\n  _offsetValue?: IBaseToken;\n}\n\nexport interface ILimitOffsetState {\n  _limitOffsetValue: ILimitOffsetTerm;\n\n  limit: typeof limit;\n  offset: typeof offset;\n  withoutLimit: typeof withoutLimit;\n  withoutOffset: typeof withoutOffset;\n}\n\nexport const buildInitialLimitOffsetState = (): ILimitOffsetTerm => {\n  return {\n    type: TokenType.LimitOffsetTerm,\n    toSql() {\n      return this._limitValue\n        ? sql.join(\n            [\n              this._limitValue\n                ? sql`LIMIT ${wrapParentheses(this._limitValue)}`\n                : null,\n              this._offsetValue && this._limitValue\n                ? sql`OFFSET ${wrapParentheses(this._offsetValue)}`\n                : null,\n            ].filter((v) => v),\n            \" \"\n          )\n        : sql.empty;\n    },\n  };\n};\n\nexport function limit<T extends ILimitOffsetState>(\n  this: T,\n  val: IBaseToken | ISqlAdapter | IPrimitiveValue\n): T {\n  return {\n    ...this,\n    _limitOffsetValue: { ...this._limitOffsetValue, _limitValue: toToken(val) },\n  };\n}\n\nexport function withoutLimit<T extends ILimitOffsetState>(this: T): T {\n  return {\n    ...this,\n    _limitOffsetValue: { ...this._limitOffsetValue, _limitValue: undefined },\n  };\n}\n\nexport function offset<T extends ILimitOffsetState>(\n  this: T,\n  val: IBaseToken | ISqlAdapter | IPrimitiveValue\n): T {\n  return {\n    ...this,\n    _limitOffsetValue: {\n      ...this._limitOffsetValue,\n      _offsetValue: toToken(val),\n    },\n  };\n}\n\nexport function withoutOffset<T extends ILimitOffsetState>(this: T): T {\n  return {\n    ...this,\n    _limitOffsetValue: { ...this._limitOffsetValue, _offsetValue: undefined },\n  };\n}\n","import { IPrimitiveValue, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../../types\";\nimport {\n  except,\n  ICompoundState,\n  intersect,\n  union,\n  unionAll,\n  withoutCompound,\n} from \"../compounds\";\nimport { ICTEState, With, withoutWith, withRecursive } from \"../cte\";\nimport {\n  buildInitialLimitOffsetState,\n  ILimitOffsetState,\n  limit,\n  offset,\n  withoutLimit,\n  withoutOffset,\n} from \"../limitOffset\";\nimport { IOrderState, orderBy, withoutOrder } from \"../order\";\n\nexport interface IValuesStatement\n  extends IBaseToken<TokenType.Values>,\n    IOrderState,\n    ICompoundState,\n    ILimitOffsetState,\n    ICTEState {\n  _values: (IBaseToken | ISqlAdapter | IPrimitiveValue)[][];\n}\n\nexport const values = (\n  ...vals: (IBaseToken | ISqlAdapter | IPrimitiveValue)[][]\n): IValuesStatement => {\n  return {\n    type: TokenType.Values,\n    _values: vals,\n    _compoundValues: [],\n    _orderByValues: [],\n    _limitOffsetValue: buildInitialLimitOffsetState(),\n\n    orderBy,\n    withoutOrder,\n\n    union,\n    unionAll,\n    intersect,\n    except,\n    withoutCompound,\n\n    limit,\n    withoutLimit,\n    offset,\n    withoutOffset,\n\n    withoutWith,\n    withRecursive,\n    with: With,\n    toSql() {\n      return sql.join(\n        [\n          this._cteValue ? this._cteValue : null,\n          sql`VALUES ${sql.join(\n            this._values.map((val) => sql`(${sql.join(val)})`)\n          )}`,\n          this._compoundValues.length > 0\n            ? sql.join(this._compoundValues, \" \")\n            : null,\n          this._orderByValues.length > 0\n            ? sql.join([sql`ORDER BY`, sql.join(this._orderByValues)], \" \")\n            : null,\n          this._limitOffsetValue.toSql().isEmpty\n            ? null\n            : this._limitOffsetValue,\n        ].filter((v) => v),\n        \" \"\n      );\n    },\n  };\n};\n\nexport const isValues = (val: unknown): val is IValuesStatement => {\n  return (\n    val !== null &&\n    typeof val === \"object\" &&\n    (val as IValuesStatement).type === TokenType.Values\n  );\n};\n","import { ISql, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\nimport { toToken } from \"./rawSql\";\nimport { ISelectStatement, isSelect } from \"./statements/select\";\nimport { isValues, IValuesStatement } from \"./statements/values\";\n\ntype IUnionArg = ISelectStatement | IValuesStatement | ISql;\n\nexport interface ICompoundOperator extends IBaseToken<TokenType.OrderTerm> {\n  _compoundType: \"UNION\" | \"UNION ALL\" | \"INTERSECT\" | \"EXCEPT\";\n  _value: ISelectStatement | IValuesStatement | IBaseToken<TokenType.RawSql>;\n}\n\nexport interface ICompoundState {\n  _compoundValues: ICompoundOperator[];\n\n  union: typeof union;\n  unionAll: typeof unionAll;\n  intersect: typeof intersect;\n  except: typeof except;\n  withoutCompound: typeof withoutCompound;\n}\n\nconst makeCompounds = <T extends ICompoundState>(\n  state: T,\n  type: \"UNION\" | \"UNION ALL\" | \"INTERSECT\" | \"EXCEPT\",\n  values: IUnionArg[]\n): T => {\n  return {\n    ...state,\n    _compoundValues: [\n      ...state._compoundValues,\n      ...values.map((val): ICompoundOperator => {\n        const token = toToken(val);\n\n        return {\n          type: TokenType.OrderTerm,\n          _compoundType: type,\n          _value: isSelect(token)\n            ? token.withoutWith().withoutLimit().withoutOrder().withoutOffset()\n            : isValues(token)\n            ? token.withoutWith().withoutLimit().withoutOrder().withoutOffset()\n            : (token as IValuesStatement | IBaseToken<TokenType.RawSql>),\n          toSql() {\n            return sql`${sql.raw(this._compoundType)} ${this._value}`;\n          },\n        };\n      }),\n    ],\n  };\n};\n\nexport function union<T extends ICompoundState>(\n  this: T,\n  ...values: IUnionArg[]\n) {\n  return makeCompounds(this, \"UNION\", values);\n}\nexport function unionAll<T extends ICompoundState>(\n  this: T,\n  ...values: IUnionArg[]\n) {\n  return makeCompounds(this, \"UNION ALL\", values);\n}\nexport function intersect<T extends ICompoundState>(\n  this: T,\n  ...values: IUnionArg[]\n) {\n  return makeCompounds(this, \"INTERSECT\", values);\n}\nexport function except<T extends ICompoundState>(\n  this: T,\n  ...values: IUnionArg[]\n) {\n  return makeCompounds(this, \"EXCEPT\", values);\n}\n\nexport function withoutCompound<T extends ICompoundState>(this: T) {\n  return { ...this, _compoundValues: [] };\n}\n","import { IContainsTable, ISql, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken } from \"../types\";\nimport { alias } from \"./alias\";\nimport { toToken } from \"./rawSql\";\nimport { wrapParentheses } from \"./utils\";\n\nexport interface IFromState {\n  _fromValues: (\n    | IContainsTable\n    | IBaseToken\n    | { select: IContainsTable | IBaseToken; alias: string }\n  )[];\n\n  from: typeof from;\n}\n\nexport function from<T extends IFromState>(\n  this: T,\n  ...values: (\n    | IBaseToken\n    | ISqlAdapter\n    | IContainsTable\n    | string\n    | Record<string, IBaseToken | ISqlAdapter | IContainsTable | string>\n  )[]\n): T {\n  return {\n    ...this,\n    _fromValues: [\n      ...this._fromValues,\n      ...values\n        .map((v) => {\n          if (typeof v === \"string\") {\n            return sql.table(v);\n          } else if (isToken(v) || sql.isSql(v) || sql.isTable(v)) {\n            return toToken(wrapParentheses(v));\n          } else {\n            return Object.entries(v).map(([k, v]) => ({\n              select:\n                typeof v === \"string\"\n                  ? sql.table(v)\n                  : toToken(wrapParentheses(v)),\n              alias: k,\n            }));\n          }\n        })\n        .flat(),\n    ],\n  };\n}\n\nexport const fromToSql = (state: IFromState): ISql | null => {\n  return state._fromValues.length > 0\n    ? sql.join(\n        state._fromValues.map((v) =>\n          isToken(v) || sql.isTable(v) ? v : alias(v.select, v.alias)\n        )\n      )\n    : null;\n};\n","import { ISql, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../../types\";\nimport { alias } from \"../alias\";\nimport {\n  except,\n  ICompoundState,\n  intersect,\n  union,\n  unionAll,\n  withoutCompound,\n} from \"../compounds\";\nimport { ICTEState, With, withoutWith, withRecursive } from \"../cte\";\nimport { from, fromToSql, IFromState } from \"../from\";\nimport {\n  IJoinState,\n  join,\n  joinCross,\n  joinFull,\n  joinFullNatural,\n  joinFullNaturalOuter,\n  joinFullOuter,\n  joinInner,\n  joinInnerNatural,\n  joinLeft,\n  joinLeftNatural,\n  joinLeftNaturalOuter,\n  joinLeftOuter,\n  joinNatural,\n  joinRight,\n  joinRightNatural,\n  joinRightNaturalOuter,\n  joinRightOuter,\n  withoutJoin,\n} from \"../join\";\nimport {\n  buildInitialLimitOffsetState,\n  ILimitOffsetState,\n  limit,\n  offset,\n  withoutLimit,\n  withoutOffset,\n} from \"../limitOffset\";\nimport { IOrderState, orderBy, withoutOrder } from \"../order\";\nimport { toToken } from \"../rawSql\";\nimport { IWhereState, orWhere, where } from \"../where\";\nimport { IValuesStatement } from \"./values\";\n\nexport const isSelect = (val: unknown): val is ISelectStatement => {\n  return (\n    val !== null &&\n    typeof val === \"object\" &&\n    (val as ISelectStatement).type === TokenType.Select\n  );\n};\n\n// TODO: add filter, window support\nexport interface ISelectStatement\n  extends IBaseToken<TokenType.Select>,\n    IOrderState,\n    ICompoundState,\n    ILimitOffsetState,\n    ICTEState,\n    IWhereState,\n    IFromState,\n    IJoinState {\n  _distinctValue: boolean;\n\n  _selectValues: {\n    toSelect: \"*\" | string | ISelectStatement | IBaseToken;\n    alias?: string;\n  }[];\n\n  _groupByValues: (IBaseToken | string)[];\n  _havingValue?: IBaseToken;\n\n  distinct(val: boolean): ISelectStatement;\n  select(...args: ISelectArgType[]): ISelectStatement;\n\n  groupBy(...values: (IBaseToken | ISqlAdapter | string)[]): ISelectStatement;\n  having(val: IBaseToken | ISqlAdapter): ISelectStatement;\n}\n\ntype ISelectArgType =\n  | \"*\"\n  | string\n  | ISqlAdapter\n  | ISelectStatement\n  | IValuesStatement\n  | { [key: string]: ISqlAdapter | string | ISelectStatement }\n  | IBaseToken;\n\nconst selectArgsToValues = (\n  args: ISelectArgType[]\n): ISelectStatement[\"_selectValues\"] => {\n  if (args === null || args === undefined || args.length === 0)\n    return [{ toSelect: \"*\" }];\n\n  return args.flatMap((arg, i) => {\n    if (arg === \"*\" && i === 0) return { toSelect: \"*\" };\n    if (typeof arg === \"string\") return { toSelect: arg };\n    if (isToken(arg) || sql.isSql(arg)) return { toSelect: toToken(arg) };\n\n    return Object.entries(arg).map(([columnOrAs, aliasOrQuery]) =>\n      typeof aliasOrQuery === \"string\"\n        ? { toSelect: columnOrAs, alias: aliasOrQuery }\n        : { toSelect: toToken(aliasOrQuery), alias: columnOrAs }\n    );\n  });\n};\n\nexport const select = (...selectArgs: ISelectArgType[]): ISelectStatement => {\n  return {\n    type: TokenType.Select,\n    _fromValues: [],\n    _selectValues: selectArgsToValues(selectArgs),\n    _distinctValue: false,\n    _groupByValues: [],\n    _compoundValues: [],\n    _orderByValues: [],\n    _joinValues: [],\n    _limitOffsetValue: buildInitialLimitOffsetState(),\n    select(...selectArgs: ISelectArgType[]): ISelectStatement {\n      return {\n        ...this,\n        _selectValues: [\n          ...this._selectValues,\n          ...selectArgsToValues(selectArgs),\n        ],\n      };\n    },\n    distinct(val: boolean): ISelectStatement {\n      return {\n        ...this,\n        _distinctValue: val,\n      };\n    },\n    from,\n    where,\n    orWhere,\n    limit,\n    offset,\n    withoutLimit,\n    withoutOffset,\n    groupBy(...values: (IBaseToken | ISql | string)[]): ISelectStatement {\n      return {\n        ...this,\n        _groupByValues: values.map((val) =>\n          typeof val === \"string\" ? val : toToken(val)\n        ),\n      };\n    },\n    having(val: IBaseToken | ISql): ISelectStatement {\n      return { ...this, _havingValue: toToken(val) };\n    },\n    orderBy,\n    withoutOrder,\n\n    with: With,\n    withoutWith,\n    withRecursive,\n\n    union,\n    unionAll,\n    intersect,\n    except,\n    withoutCompound,\n\n    withoutJoin,\n\n    join,\n    joinCross,\n\n    joinNatural,\n\n    joinLeft,\n    joinLeftOuter,\n    joinLeftNatural: joinLeftNatural,\n    joinLeftNaturalOuter: joinLeftNaturalOuter,\n\n    joinRight,\n    joinRightOuter,\n    joinRightNatural: joinRightNatural,\n    joinRightNaturalOuter: joinRightNaturalOuter,\n\n    joinFull,\n    joinFullOuter,\n    joinFullNatural: joinFullNatural,\n    joinFullNaturalOuter: joinFullNaturalOuter,\n\n    joinInner,\n    joinInnerNatural: joinInnerNatural,\n\n    toSql() {\n      return sql.join(\n        [\n          this._cteValue ? this._cteValue : null,\n          sql`SELECT`,\n          this._distinctValue ? sql`DISTINCT` : null,\n          sql.join(\n            this._selectValues.map((val) => {\n              if (val.toSelect === \"*\") {\n                return sql`*`;\n              } else if (typeof val.toSelect === \"string\") {\n                return sql.liter(val.toSelect);\n              } else {\n                return val.alias\n                  ? alias(val.toSelect, val.alias)\n                  : val.toSelect;\n              }\n            })\n          ),\n          this._fromValues.length > 0 || this._joinValues.length > 0\n            ? sql`FROM`\n            : null,\n          fromToSql(this),\n          this._joinValues.length > 0\n            ? sql.join(\n                this._joinValues.map((expr) => expr.toSql()),\n                \" \"\n              )\n            : null,\n          this._whereValue ? sql`WHERE ${this._whereValue}` : null,\n          this._groupByValues.length > 0\n            ? sql`GROUP BY ${sql.join(\n                this._groupByValues.map((val) =>\n                  typeof val === \"string\" ? sql.liter(val) : val\n                )\n              )}`\n            : null,\n          this._groupByValues.length > 0 && this._havingValue\n            ? sql`HAVING ${this._havingValue}`\n            : null,\n          this._compoundValues.length > 0\n            ? sql.join(this._compoundValues, \" \")\n            : null,\n          this._orderByValues.length > 0\n            ? sql.join([sql`ORDER BY`, sql.join(this._orderByValues)], \" \")\n            : null,\n          this._limitOffsetValue.toSql().isEmpty\n            ? null\n            : this._limitOffsetValue,\n        ].filter((v) => v),\n        \" \"\n      );\n    },\n  };\n};\n","import {\n  IContainsTable,\n  IPrimitiveValue,\n  ISqlAdapter,\n  sql,\n} from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../../types\";\nimport { ICTEState, With, withoutWith, withRecursive } from \"../cte\";\nimport {\n  IOrReplaceState,\n  orAbort,\n  orFail,\n  orIgnore,\n  orReplace,\n  orRollback,\n} from \"../orReplace\";\nimport { buildRawSql } from \"../rawSql\";\nimport {\n  IReturningState,\n  returning,\n  returningForState,\n  withoutReturningForState,\n} from \"../returning\";\nimport { ISelectStatement, isSelect } from \"./select\";\nimport { isValues, IValuesStatement } from \"./values\";\n\n// TODO: on conflict support\nexport interface IInsertStatement\n  extends IBaseToken<TokenType.Insert>,\n    ICTEState,\n    IReturningState,\n    IOrReplaceState {\n  _intoTable?: IContainsTable;\n  _columnNames: string[];\n\n  _toInsertValue?:\n    | IValuesStatement\n    | ISelectStatement\n    | { columnName: string; value: IPrimitiveValue | IBaseToken }[][];\n\n  setColumnNames(columnNames: string[]): IInsertStatement;\n  withoutColumnNames(): IInsertStatement;\n\n  insert(arg: IInsertArg): IInsertStatement;\n  withoutInsert(): IInsertStatement;\n\n  withoutInto(): IInsertStatement;\n  into(val: string | IContainsTable): IInsertStatement;\n}\n\ntype IRecArg =\n  | Record<string, IPrimitiveValue | IBaseToken | ISqlAdapter>\n  | Record<string, IPrimitiveValue | IBaseToken | ISqlAdapter>[];\ntype IInsertArg = IValuesStatement | ISelectStatement | IRecArg;\n\nconst mapRecordArg = (arg: IRecArg) => {\n  return (Array.isArray(arg) ? arg : [arg]).map((it) =>\n    Object.entries(it).map(([columnName, value]) => {\n      return {\n        columnName,\n        value: sql.isSql(value) && !isToken(value) ? buildRawSql(value) : value,\n      };\n    })\n  );\n};\n\nconst applyInsertArg = (\n  state: IInsertStatement,\n  arg: IInsertArg\n): IInsertStatement => {\n  if (\n    state._toInsertValue &&\n    (isSelect(state._toInsertValue) || isValues(state._toInsertValue))\n  ) {\n    throw new Error(\n      \"Insert value is already state. If you want to change insert values user resetInsert() before.\"\n    );\n  }\n\n  if (isSelect(arg) || isValues(arg)) {\n    return { ...state, _toInsertValue: arg };\n  }\n\n  return {\n    ...state,\n    _toInsertValue: Array.isArray(state._toInsertValue)\n      ? [...state._toInsertValue, ...mapRecordArg(arg)]\n      : mapRecordArg(arg),\n  };\n};\n\nexport const insert = (insertArg: IInsertArg): IInsertStatement => {\n  return {\n    type: TokenType.Insert,\n    _returningValue: returning(),\n    _columnNames: [],\n    _toInsertValue:\n      isSelect(insertArg) || isValues(insertArg)\n        ? insertArg\n        : mapRecordArg(insertArg),\n\n    with: With,\n    withRecursive,\n    withoutWith,\n\n    orAbort,\n    orFail,\n    orIgnore,\n    orReplace,\n    orRollback,\n\n    returning: returningForState,\n    withoutReturning: withoutReturningForState,\n\n    setColumnNames(names: string[]): IInsertStatement {\n      return { ...this, _columnNames: names };\n    },\n    withoutColumnNames(): IInsertStatement {\n      return { ...this, _columnNames: [] };\n    },\n\n    insert(arg: IInsertArg): IInsertStatement {\n      return applyInsertArg(this, arg);\n    },\n    withoutInsert(): IInsertStatement {\n      return { ...this, _toInsertValue: undefined };\n    },\n\n    into(val: string | IContainsTable): IInsertStatement {\n      return {\n        ...this,\n        _intoTable: typeof val === \"string\" ? sql.table(val) : val,\n      };\n    },\n    withoutInto(): IInsertStatement {\n      return { ...this, _intoTable: undefined };\n    },\n\n    toSql() {\n      if (!this._toInsertValue) {\n        throw new Error(\"Insert values are not set\");\n      }\n\n      if (!this._intoTable) {\n        throw new Error(\"Into table is not set\");\n      }\n\n      const columns =\n        this._columnNames.length > 0\n          ? this._columnNames\n          : Array.isArray(this._toInsertValue)\n          ? this._toInsertValue[0].map(({ columnName }) => columnName)\n          : [];\n\n      return sql.join(\n        [\n          this._cteValue ? this._cteValue : null,\n          sql`INSERT`,\n          this._orReplaceValue\n            ? sql`OR ${sql.raw(this._orReplaceValue)}`\n            : null,\n          sql`INTO`,\n          this._intoTable,\n          columns.length > 0\n            ? sql`(${sql.join(columns.map((c) => sql.liter(c)))})`\n            : null,\n          isValues(this._toInsertValue) || isSelect(this._toInsertValue)\n            ? this._toInsertValue\n            : sql`VALUES ${sql.join(\n                this._toInsertValue.map((toInsertColumns) => {\n                  const toInsert: (IPrimitiveValue | IBaseToken)[] = Array(\n                    toInsertColumns.length\n                  );\n\n                  for (const { columnName, value } of toInsertColumns) {\n                    const index = columns.indexOf(columnName);\n\n                    if (index === -1) {\n                      throw new Error(\n                        `Column ${columnName} is not present at columns set: ${columns}. Make sure that you set all columns with setColumnNames() or each insert objects have the same keys present. Tried to insert: ${JSON.stringify(\n                          toInsertColumns\n                        )}`\n                      );\n                    }\n\n                    toInsert[index] = value;\n                  }\n\n                  return sql`(${sql.join(toInsert)})`;\n                })\n              )}`,\n          this._returningValue,\n        ].filter((v) => v),\n        \" \"\n      );\n    },\n  };\n};\n","import {\n  IContainsTable,\n  IPrimitiveValue,\n  ISqlAdapter,\n  sql,\n} from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../../types\";\nimport { ICTEState, With, withoutWith, withRecursive } from \"../cte\";\nimport { from, fromToSql, IFromState } from \"../from\";\nimport {\n  IJoinState,\n  join,\n  joinCross,\n  joinFull,\n  joinFullNatural,\n  joinFullNaturalOuter,\n  joinFullOuter,\n  joinInner,\n  joinInnerNatural,\n  joinLeft,\n  joinLeftNatural,\n  joinLeftNaturalOuter,\n  joinLeftOuter,\n  joinNatural,\n  joinRight,\n  joinRightNatural,\n  joinRightNaturalOuter,\n  joinRightOuter,\n  withoutJoin,\n} from \"../join\";\nimport {\n  IOrReplaceState,\n  orAbort,\n  orFail,\n  orIgnore,\n  orReplace,\n  orRollback,\n} from \"../orReplace\";\nimport { buildRawSql } from \"../rawSql\";\nimport {\n  IReturningState,\n  returning,\n  returningForState,\n  withoutReturningForState,\n} from \"../returning\";\nimport { wrapParentheses } from \"../utils\";\nimport { IWhereState, orWhere, where } from \"../where\";\nimport { ISelectStatement } from \"./select\";\nimport { IValuesStatement } from \"./values\";\n\ntype ISetValue =\n  | {\n      columnName: string;\n      toSet:\n        | IBaseToken<TokenType.RawSql>\n        | IPrimitiveValue\n        | ISelectStatement\n        | IValuesStatement;\n    }\n  | IBaseToken<TokenType.RawSql>;\n\nexport interface IUpdateStatement\n  extends IBaseToken<TokenType.Update>,\n    ICTEState,\n    IWhereState,\n    IFromState,\n    IReturningState,\n    IOrReplaceState,\n    IJoinState {\n  _updateTable: IContainsTable;\n  _setValues: ISetValue[];\n\n  set(...args: ISetArgType[]): IUpdateStatement;\n}\n\ntype ISetArgType =\n  | ISqlAdapter\n  | {\n      [key: string]:\n        | ISqlAdapter\n        | IBaseToken<TokenType.RawSql>\n        | IPrimitiveValue\n        | ISelectStatement\n        | IValuesStatement;\n    }\n  | IBaseToken<TokenType.RawSql>;\n\nexport const update = (tbl: string | IContainsTable): IUpdateStatement => {\n  return {\n    type: TokenType.Update,\n    _updateTable: typeof tbl === \"string\" ? sql.table(tbl) : tbl,\n    _setValues: [],\n    _fromValues: [],\n    _joinValues: [],\n    _returningValue: returning(),\n\n    with: With,\n    withoutWith,\n    withRecursive,\n\n    from,\n\n    where,\n    orWhere,\n\n    returning: returningForState,\n    withoutReturning: withoutReturningForState,\n\n    orAbort,\n    orFail,\n    orIgnore,\n    orReplace,\n    orRollback,\n\n    withoutJoin,\n\n    join,\n    joinCross,\n\n    joinNatural,\n\n    joinLeft,\n    joinLeftOuter,\n    joinLeftNatural: joinLeftNatural,\n    joinLeftNaturalOuter: joinLeftNaturalOuter,\n\n    joinRight,\n    joinRightOuter,\n    joinRightNatural: joinRightNatural,\n    joinRightNaturalOuter: joinRightNaturalOuter,\n\n    joinFull,\n    joinFullOuter,\n    joinFullNatural: joinFullNatural,\n    joinFullNaturalOuter: joinFullNaturalOuter,\n\n    joinInner,\n    joinInnerNatural: joinInnerNatural,\n\n    set(...args: ISetArgType[]): IUpdateStatement {\n      const vals = args.flatMap((m): ISetValue | ISetValue[] => {\n        if (isToken(m)) {\n          return m;\n        } else if (sql.isSql(m)) {\n          return buildRawSql(m);\n        } else {\n          return Object.entries(m).map(([key, val]) => {\n            return {\n              columnName: key,\n              toSet: !isToken(val) && sql.isSql(val) ? buildRawSql(val) : val,\n            };\n          });\n        }\n      });\n\n      return { ...this, _setValues: [...this._setValues, ...vals] };\n    },\n\n    toSql() {\n      return sql.join(\n        [\n          this._cteValue ? this._cteValue : null,\n          sql`UPDATE`,\n          this._orReplaceValue\n            ? sql`OR ${sql.raw(this._orReplaceValue)}`\n            : null,\n          this._updateTable,\n          sql`SET`,\n          sql.join(\n            this._setValues.map((val) =>\n              isToken(val)\n                ? val\n                : sql`${sql.liter(val.columnName)} = ${wrapParentheses(\n                    val.toSet\n                  )}`\n            )\n          ),\n          this._fromValues.length > 0 || this._joinValues.length > 0\n            ? sql`FROM`\n            : null,\n          fromToSql(this),\n          this._joinValues.length > 0\n            ? sql.join(\n                this._joinValues.map((expr) => expr.toSql()),\n                \" \"\n              )\n            : null,\n          this._whereValue ? sql`WHERE ${this._whereValue}` : null,\n          this._returningValue,\n        ].filter((v) => v),\n        \" \"\n      );\n    },\n  };\n};\n","import { IPrimitiveValue, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\n\nexport interface IUnaryOperator extends IBaseToken<TokenType.Unary> {\n  _operator: \"NOT\";\n  _expr: IBaseToken | ISqlAdapter | IPrimitiveValue;\n}\n\nexport const not = (\n  expr: IBaseToken | ISqlAdapter | IPrimitiveValue\n): IUnaryOperator => {\n  return {\n    _operator: \"NOT\",\n    type: TokenType.Unary,\n    _expr: expr,\n    toSql() {\n      return sql`NOT (${this._expr})`;\n    },\n  };\n};\n"],"names":["sql"],"mappings":"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"}