{"version":3,"file":"index.umd.js","sources":["../src/types.ts","../src/tokens/rawSql.ts","../src/tokens/binary.ts","../src/tokens/utils.ts","../src/tokens/alias.ts","../src/tokens/join.ts","../src/tokens/order.ts","../src/tokens/cte.ts","../src/tokens/returning.ts","../src/tokens/where.ts","../src/tokens/statements/delete.ts","../src/tokens/orReplace.ts","../src/tokens/limitOffset.ts","../src/tokens/statements/values.ts","../src/tokens/compounds.ts","../src/tokens/from.ts","../src/tokens/statements/select.ts","../src/tokens/statements/insert.ts","../src/tokens/statements/update.ts","../src/tokens/unary.ts"],"sourcesContent":["import { ISql } from \"@kikko-land/sql\";\n\nexport enum TokenType {\n  Binary = \"Binary\",\n  Unary = \"Unary\",\n  Alias = \"Alias\",\n  Compound = \"Compound\",\n  Select = \"Select\",\n  Update = \"Update\",\n  Delete = \"Delete\",\n  Insert = \"Insert\",\n  Values = \"Values\",\n  OrderTerm = \"OrderTerm\",\n  LimitOffsetTerm = \"LimitOffsetTerm\",\n  RawSql = \"RawSql\",\n  CompoundOperator = \"CompoundOperator\",\n  CTE = \"CTE\",\n  Join = \"Join\",\n  Returning = \"Returning\",\n}\n\nexport interface IBaseToken<T extends TokenType = TokenType> {\n  type: T;\n  toSql(): ISql;\n}\n\nexport const isToken = (t: unknown): t is IBaseToken => {\n  return (\n    t !== null &&\n    typeof t === \"object\" &&\n    \"type\" in t &&\n    \"toSql\" in t &&\n    Object.values(TokenType).includes((t as IBaseToken).type)\n  );\n};\n\nexport function assertUnreachable(x: never): never {\n  throw new Error(`Didn't expect to get here: ${JSON.stringify(x)}`);\n}\n","import {\n  IContainsTable,\n  IPrimitiveValue,\n  ISqlAdapter,\n  sql,\n} from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../types\";\n\nexport const buildRawSql = (\n  t: ISqlAdapter | IContainsTable | IPrimitiveValue\n): IBaseToken<TokenType.RawSql> => {\n  return {\n    type: TokenType.RawSql,\n    toSql() {\n      return sql`${t}`;\n    },\n  };\n};\n\nexport const toToken = (\n  t: IBaseToken | ISqlAdapter | IPrimitiveValue | IContainsTable\n): IBaseToken => {\n  if (isToken(t)) return t;\n\n  if (sql.isSql(t)) {\n    return buildRawSql(t);\n  }\n\n  return buildRawSql(t);\n};\n","import { IPrimitiveValue, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../types\";\nimport { toToken } from \"./rawSql\";\nimport { wrapParentheses } from \"./utils\";\n\n// TODO: in null support\n// TODO: add ESCAPE for LIKE/NOT LIKE\nexport interface IBinaryOperator extends IBaseToken<TokenType.Binary> {\n  _operator:\n    | \"<\"\n    | \"<=\"\n    | \">\"\n    | \">=\"\n    | \"=\"\n    | \"<>\"\n    | \"AND\"\n    | \"OR\"\n    | \"IN\"\n    | \"NOT IN\"\n    | \"LIKE\"\n    | \"NOT LIKE\"\n    // TODO: add all\n    | \"BETWEEN\"\n    | \"NOT BETWEEN\"\n    | \"GLOB\"\n    | \"NOT GLOB\"\n    | \"MATCH\"\n    | \"NOT MATCH\"\n    | \"REGEXP\"\n    | \"NOT REGEXP\";\n  _left: IBaseToken;\n  _right: IBaseToken | IBaseToken[];\n}\n\nexport const isBinaryOperator = (t: unknown): t is IBinaryOperator => {\n  return (\n    t !== null &&\n    typeof t === \"object\" &&\n    \"type\" in t &&\n    (t as IBinaryOperator).type === TokenType.Binary\n  );\n};\n\nconst binaryOperator = (\n  operator: IBinaryOperator[\"_operator\"],\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right:\n    | IBaseToken\n    | ISqlAdapter\n    | IPrimitiveValue\n    | (IBaseToken | ISqlAdapter | IPrimitiveValue)[]\n): IBinaryOperator => {\n  return {\n    type: TokenType.Binary,\n    _left: toToken(left),\n    _right: Array.isArray(right) ? right.map(toToken) : toToken(right),\n    _operator: operator,\n    toSql() {\n      return sql`${wrapParentheses(this._left)} ${sql.raw(this._operator)} ${\n        Array.isArray(this._right)\n          ? sql`(${sql.join(this._right)})`\n          : wrapParentheses(this._right)\n      }`;\n    },\n  };\n};\n\nexport const notEq$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) =>\n    notEq(left, right);\n};\nexport const notEq = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"<>\", left, right);\n};\n\nexport const eq$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => eq(left, right);\n};\nexport const eq = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"=\", left, right);\n};\n\nexport const gt$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => gt(left, right);\n};\nexport const gt = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\">\", left, right);\n};\n\nexport const gtEq$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) =>\n    gtEq(left, right);\n};\nexport const gtEq = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\">=\", left, right);\n};\n\nexport const lt$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => lt(left, right);\n};\nexport const lt = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"<\", left, right);\n};\n\nexport const ltEq$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) =>\n    ltEq(left, right);\n};\nexport const ltEq = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"<=\", left, right);\n};\n\nexport const like = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"LIKE\", left, right);\n};\nexport const like$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) =>\n    like(left, right);\n};\n\nexport const notLike = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  right: IBaseToken | ISqlAdapter | IPrimitiveValue\n) => {\n  return binaryOperator(\"NOT LIKE\", left, right);\n};\nexport const notLike$ = (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n  return (left: IBaseToken | ISqlAdapter | IPrimitiveValue) =>\n    notLike(left, right);\n};\n\nexport const In = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  ...right: (IBaseToken | ISqlAdapter | IPrimitiveValue)[]\n) => {\n  return binaryOperator(\"IN\", left, right);\n};\nexport const notIn = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue,\n  ...right: (IBaseToken | ISqlAdapter | IPrimitiveValue)[]\n) => {\n  return binaryOperator(\"NOT IN\", left, right);\n};\n\nexport const in$ =\n  (...values: (IBaseToken | ISqlAdapter | IPrimitiveValue)[]) =>\n  (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n    return In(left, ...values);\n  };\nexport const notIn$ =\n  (...values: (IBaseToken | ISqlAdapter | IPrimitiveValue)[]) =>\n  (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => {\n    return notIn(left, ...values);\n  };\n\nexport type IConditionValue =\n  | IBaseToken\n  | ISqlAdapter\n  | Record<\n      string,\n      | ((left: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator)\n      | IBaseToken\n      | ISqlAdapter\n      | IPrimitiveValue\n    >;\n\nexport const conditionValuesToToken = (values: IConditionValue[]) => {\n  return values\n    .flatMap((v) =>\n      isToken(v) || sql.isSql(v)\n        ? toToken(v)\n        : Object.entries(v).map(([k, expr]) =>\n            toToken(\n              typeof expr === \"function\"\n                ? expr(sql.liter(k))\n                : eq(sql.liter(k), expr)\n            )\n          )\n    )\n    .filter((v) => !v.toSql().isEmpty);\n};\n\nconst conditionOperator = (\n  type: \"AND\" | \"OR\",\n  ...values: IConditionValue[]\n): IBinaryOperator => {\n  const exprs = conditionValuesToToken(values);\n\n  if (exprs.length <= 1) {\n    throw new Error(\"Must at least two arguments present\");\n  }\n\n  let current = binaryOperator(type, exprs[0], exprs[1]);\n\n  for (const next of exprs.slice(2)) {\n    current = binaryOperator(type, current, next);\n  }\n\n  return current;\n};\n\nexport const and = (...values: IConditionValue[]): IBinaryOperator => {\n  return conditionOperator(\"AND\", ...values);\n};\n\nexport const or = (...values: IConditionValue[]): IBinaryOperator => {\n  return conditionOperator(\"OR\", ...values);\n};\n","import {\n  IContainsTable,\n  IPrimitiveValue,\n  ISql,\n  ISqlAdapter,\n  sql,\n} from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../types\";\nimport { isBinaryOperator } from \"./binary\";\n\nexport const wrapParentheses = <\n  T extends IBaseToken | ISqlAdapter | IPrimitiveValue | IContainsTable\n>(\n  val: T\n): T | ISql =>\n  (isBinaryOperator(val) && val._operator === \"OR\") ||\n  (isToken(val) &&\n    (val.type === TokenType.Select || val.type === TokenType.Values))\n    ? sql`(${val})`\n    : val;\n","import {\n  IContainsTable,\n  IPrimitiveValue,\n  ISqlAdapter,\n  sql,\n} from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\nimport { toToken } from \"./rawSql\";\nimport { wrapParentheses } from \"./utils\";\n\nexport type IAlias = IBaseToken<TokenType.Alias> & {\n  _left: IBaseToken;\n  _right: string;\n};\n\nexport const alias = (\n  left: IBaseToken | ISqlAdapter | IPrimitiveValue | IContainsTable,\n  right: string\n): IAlias => {\n  return {\n    type: TokenType.Alias,\n    _left: toToken(left),\n    _right: right,\n    toSql() {\n      return sql`${wrapParentheses(this._left)} AS ${sql.liter(this._right)}`;\n    },\n  };\n};\n","import { IContainsTable, ISqlAdapter, sql } from \"@kikko-land/sql\";\nimport { isTable } from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../types\";\nimport { alias } from \"./alias\";\nimport { conditionValuesToToken, IConditionValue } from \"./binary\";\nimport { toToken } from \"./rawSql\";\nimport { ISelectStatement } from \"./statements/select\";\nimport { wrapParentheses } from \"./utils\";\n\ntype IJoinOperator =\n  | {\n      joinType: \"CROSS\";\n    }\n  | ({\n      isNatural: boolean;\n    } & (\n      | {\n          joinType: \"LEFT\" | \"RIGHT\" | \"FULL\";\n          isOuter: boolean;\n        }\n      | {\n          joinType: \"INNER\";\n        }\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | {}\n    ));\n\nexport interface IJoinExpr extends IBaseToken<TokenType.Join> {\n  _operator?: IJoinOperator;\n  _toJoin:\n    | IContainsTable\n    | IBaseToken\n    | { toSelect: IBaseToken; alias: string };\n  _on?: IConditionValue;\n}\n\nconst baseJoin = (\n  operator: IJoinOperator | undefined,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): IJoinExpr => {\n  return {\n    type: TokenType.Join,\n    _operator: operator,\n    _toJoin: (() => {\n      if (typeof toJoin === \"string\") {\n        return sql.table(toJoin);\n      } else if (isTable(toJoin)) {\n        return toJoin;\n      } else if (isToken(toJoin) || sql.isSql(toJoin)) {\n        return toToken(toJoin);\n      } else {\n        const entries = Object.entries(toJoin);\n        if (entries.length === 0) {\n          throw new Error(\"No alias select present for join\");\n        }\n        if (entries.length > 1) {\n          throw new Error(\"Only one select could be specified at join\");\n        }\n        return { toSelect: toToken(entries[0][1]), alias: entries[0][0] };\n      }\n    })(),\n    _on: on,\n\n    toSql() {\n      const operatorSql = (() => {\n        if (!this._operator) return [sql`JOIN`];\n\n        if (\"joinType\" in this._operator) {\n          if (this._operator.joinType === \"CROSS\") {\n            return [sql`CROSS JOIN`] as const;\n          } else {\n            return [\n              this._operator.isNatural ? sql`NATURAL` : undefined,\n              sql.raw(this._operator.joinType),\n              \"isOuter\" in this._operator && this._operator.isOuter\n                ? sql`OUTER`\n                : undefined,\n              sql`JOIN`,\n            ] as const;\n          }\n        } else {\n          return [\n            this._operator.isNatural ? sql`NATURAL` : undefined,\n            sql`JOIN`,\n          ] as const;\n        }\n      })().flatMap((v) => (v === undefined ? [] : v));\n\n      return sql.join(\n        [\n          ...operatorSql,\n          \"toSelect\" in this._toJoin\n            ? alias(this._toJoin.toSelect, this._toJoin.alias)\n            : wrapParentheses(this._toJoin),\n          ...(this._on ? [sql`ON`, ...conditionValuesToToken([this._on])] : []),\n        ],\n        \" \"\n      );\n    },\n  };\n};\n\ntype IToJoinArg =\n  | IBaseToken\n  | ISqlAdapter\n  | IContainsTable\n  | string\n  | { [key: string]: ISqlAdapter | ISelectStatement | string };\n\nexport interface IJoinState {\n  _joinValues: IJoinExpr[];\n\n  withoutJoin: typeof withoutJoin;\n\n  join: typeof join;\n  joinCross: typeof joinCross;\n\n  joinNatural: typeof joinNatural;\n\n  joinLeft: typeof joinLeft;\n  joinLeftOuter: typeof joinLeftOuter;\n  joinLeftNatural: typeof joinLeftNatural;\n  joinLeftNaturalOuter: typeof joinLeftNaturalOuter;\n\n  joinRight: typeof joinRight;\n  joinRightOuter: typeof joinRightOuter;\n  joinRightNatural: typeof joinRightNatural;\n  joinRightNaturalOuter: typeof joinRightNaturalOuter;\n\n  joinFull: typeof joinFull;\n  joinFullOuter: typeof joinFullOuter;\n  joinFullNatural: typeof joinFullNatural;\n  joinFullNaturalOuter: typeof joinFullNaturalOuter;\n\n  joinInner: typeof joinInner;\n  joinInnerNatural: typeof joinInnerNatural;\n}\n\nexport function join<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [...this._joinValues, baseJoin(undefined, toJoin, on)],\n  };\n}\n\nexport function joinCross<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ joinType: \"CROSS\" }, toJoin, on),\n    ],\n  };\n}\n\nexport function joinNatural<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: true }, toJoin, on),\n    ],\n  };\n}\n\nexport function joinLeftNatural<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: false, joinType: \"LEFT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\n\nexport function joinRightNatural<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: false, joinType: \"RIGHT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\n\nexport function joinFullNatural<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: false, joinType: \"FULL\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\n\nexport function joinLeftNaturalOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: true, joinType: \"LEFT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\nexport function joinRightNaturalOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: true, joinType: \"RIGHT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\nexport function joinFullNaturalOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: true, isOuter: true, joinType: \"FULL\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\n\nexport function joinInnerNatural<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: true, joinType: \"INNER\" as const }, toJoin, on),\n    ],\n  };\n}\n\nexport function joinLeft<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: false, joinType: \"LEFT\" as const }, toJoin, on),\n    ],\n  };\n}\nexport function joinRight<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: false, joinType: \"RIGHT\" as const }, toJoin, on),\n    ],\n  };\n}\nexport function joinFull<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: false, joinType: \"FULL\" as const }, toJoin, on),\n    ],\n  };\n}\n\nexport function joinLeftOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: false, isOuter: true, joinType: \"LEFT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\nexport function joinRightOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: false, isOuter: true, joinType: \"RIGHT\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\nexport function joinFullOuter<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin(\n        { isNatural: false, isOuter: true, joinType: \"FULL\" as const },\n        toJoin,\n        on\n      ),\n    ],\n  };\n}\n\nexport function joinInner<T extends IJoinState>(\n  this: T,\n  toJoin: IToJoinArg,\n  on?: IConditionValue\n): T {\n  return {\n    ...this,\n    _joinValues: [\n      ...this._joinValues,\n      baseJoin({ isNatural: false, joinType: \"INNER\" as const }, toJoin),\n      on,\n    ],\n  };\n}\n\nexport function withoutJoin<T extends IJoinState>(this: T): T {\n  return {\n    ...this,\n    _joinValues: [],\n  };\n}\n","import { ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\nimport { toToken } from \"./rawSql\";\n\nexport interface IOrderTerm extends IBaseToken<TokenType.OrderTerm> {\n  _orderType: \"DESC\" | \"ASC\";\n  _val: IBaseToken | string;\n  _nullOrder?: \"NULLS FIRST\" | \"NULLS LAST\";\n}\n\nconst orderTerm = (\n  type: IOrderTerm[\"_orderType\"],\n  val: IBaseToken | ISqlAdapter | string,\n  nullOrder: IOrderTerm[\"_nullOrder\"]\n): IOrderTerm => {\n  return {\n    type: TokenType.OrderTerm,\n    _orderType: type,\n    _val: typeof val === \"string\" ? val : toToken(val),\n    _nullOrder: nullOrder,\n    toSql() {\n      return sql.join(\n        [\n          typeof this._val === \"string\" ? sql.liter(this._val) : this._val,\n          sql.raw(this._orderType),\n          nullOrder ? sql.raw(nullOrder) : sql.empty,\n        ],\n        \" \"\n      );\n    },\n  };\n};\n\nexport const desc = (\n  val: IBaseToken | ISqlAdapter | string,\n  nullOrder?: \"NULLS FIRST\" | \"NULLS LAST\"\n) => {\n  return orderTerm(\"DESC\", val, nullOrder);\n};\n\nexport const asc = (\n  val: IBaseToken | ISqlAdapter | string,\n  nullOrder?: \"NULLS FIRST\" | \"NULLS LAST\"\n) => {\n  return orderTerm(\"ASC\", val, nullOrder);\n};\n\nexport interface IOrderState {\n  _orderByValues: IOrderTerm[];\n\n  orderBy: typeof orderBy;\n  withoutOrder: typeof withoutOrder;\n}\n\nexport function orderBy<T extends IOrderState>(\n  this: T,\n  ...orderTerm: IOrderTerm[]\n): T {\n  return {\n    ...this,\n    _orderByValues: [...this._orderByValues, ...orderTerm],\n  };\n}\n\nexport function withoutOrder<T extends IOrderState>(this: T): T {\n  return {\n    ...this,\n    _orderByValue: undefined,\n  };\n}\n","import { ISql, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\nimport { buildRawSql } from \"./rawSql\";\nimport { ISelectStatement } from \"./statements/select\";\nimport { IValuesStatement } from \"./statements/values\";\n\nexport interface ICTETerm extends IBaseToken<TokenType.CTE> {\n  _recursive: boolean;\n  _values: {\n    table: string;\n    columns: string[];\n    select: ISelectStatement | IValuesStatement | IBaseToken<TokenType.RawSql>;\n  }[];\n}\n\nexport interface ICTEState {\n  _cteValue?: ICTETerm;\n\n  with: typeof With;\n  withRecursive: typeof withRecursive;\n  withoutWith: typeof withoutWith;\n}\n\nconst cteTerm = (args: {\n  table: string;\n  columns: string[];\n  recursive: boolean;\n  select: ISelectStatement | IValuesStatement | IBaseToken<TokenType.RawSql>;\n}): ICTETerm => {\n  return {\n    type: TokenType.CTE,\n    _recursive: args.recursive,\n    _values: [\n      {\n        table: args.table,\n        columns: args.columns,\n        select: args.select,\n      },\n    ],\n    toSql() {\n      return sql.join(\n        [\n          sql`WITH`,\n          this._recursive ? sql`RECURSIVE` : null,\n          sql.join(\n            this._values.map(\n              (v) =>\n                sql`${sql.liter(v.table)}(${sql.join(\n                  v.columns.map(sql.liter)\n                )}) AS (${v.select})`\n            )\n          ),\n        ].filter((b) => b),\n        \" \"\n      );\n    },\n  };\n};\n\nconst cteTermState = <T extends ICTEState>(\n  state: T,\n  args: {\n    table: string;\n    columns: string[];\n    recursive: boolean;\n    select: ISelectStatement | IValuesStatement | ISql;\n  }\n): T => {\n  if (state._cteValue?._recursive === true && args.recursive === false) {\n    throw new Error(\"WITH is already recursive\");\n  }\n\n  if (state._cteValue?._recursive === false && args.recursive === true) {\n    throw new Error(\"WITH is not recursive\");\n  }\n\n  return {\n    ...state,\n    _cteValue: state._cteValue\n      ? {\n          ...state._cteValue,\n          values: [...state._cteValue._values, {}],\n        }\n      : cteTerm({\n          table: args.table,\n          columns: args.columns,\n          recursive: args.recursive,\n          select: sql.isSql(args.select)\n            ? buildRawSql(args.select)\n            : args.select,\n        }),\n  };\n};\n\nexport function With<T extends ICTEState>(\n  this: T,\n  args: {\n    table: string;\n    columns: string[];\n    select: ISelectStatement | IValuesStatement | ISql;\n  }\n): T {\n  return cteTermState(this, { ...args, recursive: false });\n}\n\nexport function withRecursive<T extends ICTEState>(\n  this: T,\n  args: {\n    table: string;\n    columns: string[];\n    select: ISelectStatement | IValuesStatement | ISql;\n  }\n): T {\n  return cteTermState(this, { ...args, recursive: true });\n}\n\nexport function withoutWith<T extends ICTEState>(this: T): T {\n  return { ...this, cteValue: undefined };\n}\n","import { ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../types\";\nimport { alias } from \"./alias\";\nimport { toToken } from \"./rawSql\";\nimport { ISelectStatement } from \"./statements/select\";\n\ntype IReturnValue = {\n  _toSelect: \"*\" | string | ISelectStatement | IBaseToken;\n  _alias?: string;\n};\nexport interface IReturningClause extends IBaseToken<TokenType.Returning> {\n  _values: IReturnValue[];\n}\n\ntype IReturningArg =\n  | \"*\"\n  | string\n  | ISqlAdapter\n  | IBaseToken\n  | { [key: string]: ISqlAdapter | string | ISelectStatement };\n\nexport interface IReturningState {\n  _returningValue: IReturningClause;\n\n  returning: typeof returningForState;\n  withoutReturning: typeof withoutReturningForState;\n}\n\nexport const returning = (...args: IReturningArg[]): IReturningClause => {\n  return {\n    type: TokenType.Returning,\n    _values: args.flatMap((arg): IReturnValue | IReturnValue[] => {\n      if (sql.isSql(arg) || isToken(arg)) {\n        return { _toSelect: toToken(arg) };\n      } else if (typeof arg === \"string\") {\n        return { _toSelect: arg };\n      } else {\n        return Object.entries(arg).map(([columnOrAs, aliasOrQuery]) => {\n          return typeof aliasOrQuery === \"string\"\n            ? { _toSelect: columnOrAs, _alias: aliasOrQuery }\n            : { _toSelect: toToken(aliasOrQuery), _alias: columnOrAs };\n        });\n      }\n    }),\n    toSql() {\n      return this._values.length > 0\n        ? sql`RETURNING ${sql.join(\n            this._values.map((val) => {\n              if (val._toSelect === \"*\") {\n                return sql`*`;\n              } else {\n                return val._alias\n                  ? alias(val._toSelect, val._alias)\n                  : val._toSelect;\n              }\n            })\n          )}`\n        : sql.empty;\n    },\n  };\n};\n\nexport function returningForState<T extends IReturningState>(\n  this: T,\n  ...args: IReturningArg[]\n): T {\n  return {\n    ...this,\n    _returningValue: {\n      ...this._returningValue,\n      _values: [...this._returningValue._values, ...returning(...args)._values],\n    },\n  };\n}\n\nexport function withoutReturningForState<T extends IReturningState>(\n  this: T\n): T {\n  return {\n    ...this,\n    _returningValue: returning(),\n  };\n}\n","import { IBaseToken, TokenType } from \"../types\";\nimport {\n  and,\n  conditionValuesToToken,\n  IBinaryOperator,\n  IConditionValue,\n  or,\n} from \"./binary\";\nimport { IUnaryOperator } from \"./unary\";\n\nexport interface IWhereState {\n  _whereValue?: IBaseToken<TokenType.RawSql> | IBinaryOperator | IUnaryOperator;\n\n  where: typeof where;\n  orWhere: typeof orWhere;\n}\n\nconst constructWhere = function <T extends IWhereState>(\n  state: T,\n  andOrOr: \"and\" | \"or\",\n  values: IConditionValue[]\n): T {\n  const finalValues = state._whereValue\n    ? [state._whereValue, ...conditionValuesToToken(values)]\n    : conditionValuesToToken(values);\n\n  if (finalValues.length > 1) {\n    return {\n      ...state,\n      _whereValue: andOrOr === \"and\" ? and(...finalValues) : or(...finalValues),\n    };\n  } else {\n    return { ...state, _whereValue: finalValues[0] };\n  }\n};\n\nexport function where<T extends IWhereState>(\n  this: T,\n  ...values: IConditionValue[]\n): T {\n  return constructWhere(this, \"and\", values);\n}\n\nexport function orWhere<T extends IWhereState>(\n  this: T,\n  ...values: IConditionValue[]\n): T {\n  return constructWhere(this, \"or\", values);\n}\n","import { IContainsTable, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../../types\";\nimport { ICTEState, With, withoutWith, withRecursive } from \"../cte\";\nimport {\n  IReturningState,\n  returning,\n  returningForState,\n  withoutReturningForState,\n} from \"../returning\";\nimport { IWhereState, orWhere, where } from \"../where\";\n\nexport interface IDeleteStatement\n  extends IBaseToken<TokenType.Delete>,\n    ICTEState,\n    IWhereState,\n    IReturningState {\n  _deleteTable: IContainsTable;\n}\n\nexport const deleteFrom = (tbl: string | IContainsTable): IDeleteStatement => {\n  return {\n    type: TokenType.Delete,\n    _deleteTable: typeof tbl === \"string\" ? sql.table(tbl) : tbl,\n    _returningValue: returning(),\n\n    with: With,\n    withoutWith,\n    withRecursive,\n\n    where,\n    orWhere,\n\n    returning: returningForState,\n    withoutReturning: withoutReturningForState,\n\n    toSql() {\n      return sql.join(\n        [\n          this._cteValue ? this._cteValue : null,\n          sql`DELETE FROM ${this._deleteTable}`,\n          this._whereValue ? sql`WHERE ${this._whereValue}` : null,\n          this._returningValue,\n        ].filter((v) => v),\n        \" \"\n      );\n    },\n  };\n};\n","export interface IOrReplaceState {\n  _orReplaceValue?: \"ABORT\" | \"FAIL\" | \"IGNORE\" | \"REPLACE\" | \"ROLLBACK\";\n\n  orAbort: typeof orAbort;\n  orFail: typeof orFail;\n  orIgnore: typeof orIgnore;\n  orReplace: typeof orReplace;\n  orRollback: typeof orRollback;\n}\n\nexport function orAbort<T extends IOrReplaceState>(this: T): T {\n  return { ...this, _orReplaceValue: \"ABORT\" };\n}\n\nexport function orFail<T extends IOrReplaceState>(this: T): T {\n  return { ...this, _orReplaceValue: \"FAIL\" };\n}\n\nexport function orIgnore<T extends IOrReplaceState>(this: T): T {\n  return { ...this, _orReplaceValue: \"IGNORE\" };\n}\n\nexport function orReplace<T extends IOrReplaceState>(this: T): T {\n  return { ...this, _orReplaceValue: \"REPLACE\" };\n}\n\nexport function orRollback<T extends IOrReplaceState>(this: T): T {\n  return { ...this, _orReplaceValue: \"ROLLBACK\" };\n}\n","import { IPrimitiveValue, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\nimport { toToken } from \"./rawSql\";\nimport { wrapParentheses } from \"./utils\";\n\nexport interface ILimitOffsetTerm\n  extends IBaseToken<TokenType.LimitOffsetTerm> {\n  _limitValue?: IBaseToken;\n  _offsetValue?: IBaseToken;\n}\n\nexport interface ILimitOffsetState {\n  _limitOffsetValue: ILimitOffsetTerm;\n\n  limit: typeof limit;\n  offset: typeof offset;\n  withoutLimit: typeof withoutLimit;\n  withoutOffset: typeof withoutOffset;\n}\n\nexport const buildInitialLimitOffsetState = (): ILimitOffsetTerm => {\n  return {\n    type: TokenType.LimitOffsetTerm,\n    toSql() {\n      return this._limitValue\n        ? sql.join(\n            [\n              this._limitValue\n                ? sql`LIMIT ${wrapParentheses(this._limitValue)}`\n                : null,\n              this._offsetValue && this._limitValue\n                ? sql`OFFSET ${wrapParentheses(this._offsetValue)}`\n                : null,\n            ].filter((v) => v),\n            \" \"\n          )\n        : sql.empty;\n    },\n  };\n};\n\nexport function limit<T extends ILimitOffsetState>(\n  this: T,\n  val: IBaseToken | ISqlAdapter | IPrimitiveValue\n): T {\n  return {\n    ...this,\n    _limitOffsetValue: { ...this._limitOffsetValue, _limitValue: toToken(val) },\n  };\n}\n\nexport function withoutLimit<T extends ILimitOffsetState>(this: T): T {\n  return {\n    ...this,\n    _limitOffsetValue: { ...this._limitOffsetValue, _limitValue: undefined },\n  };\n}\n\nexport function offset<T extends ILimitOffsetState>(\n  this: T,\n  val: IBaseToken | ISqlAdapter | IPrimitiveValue\n): T {\n  return {\n    ...this,\n    _limitOffsetValue: {\n      ...this._limitOffsetValue,\n      _offsetValue: toToken(val),\n    },\n  };\n}\n\nexport function withoutOffset<T extends ILimitOffsetState>(this: T): T {\n  return {\n    ...this,\n    _limitOffsetValue: { ...this._limitOffsetValue, _offsetValue: undefined },\n  };\n}\n","import { IPrimitiveValue, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../../types\";\nimport {\n  except,\n  ICompoundState,\n  intersect,\n  union,\n  unionAll,\n  withoutCompound,\n} from \"../compounds\";\nimport { ICTEState, With, withoutWith, withRecursive } from \"../cte\";\nimport {\n  buildInitialLimitOffsetState,\n  ILimitOffsetState,\n  limit,\n  offset,\n  withoutLimit,\n  withoutOffset,\n} from \"../limitOffset\";\nimport { IOrderState, orderBy, withoutOrder } from \"../order\";\n\nexport interface IValuesStatement\n  extends IBaseToken<TokenType.Values>,\n    IOrderState,\n    ICompoundState,\n    ILimitOffsetState,\n    ICTEState {\n  _values: (IBaseToken | ISqlAdapter | IPrimitiveValue)[][];\n}\n\nexport const values = (\n  ...vals: (IBaseToken | ISqlAdapter | IPrimitiveValue)[][]\n): IValuesStatement => {\n  return {\n    type: TokenType.Values,\n    _values: vals,\n    _compoundValues: [],\n    _orderByValues: [],\n    _limitOffsetValue: buildInitialLimitOffsetState(),\n\n    orderBy,\n    withoutOrder,\n\n    union,\n    unionAll,\n    intersect,\n    except,\n    withoutCompound,\n\n    limit,\n    withoutLimit,\n    offset,\n    withoutOffset,\n\n    withoutWith,\n    withRecursive,\n    with: With,\n    toSql() {\n      return sql.join(\n        [\n          this._cteValue ? this._cteValue : null,\n          sql`VALUES ${sql.join(\n            this._values.map((val) => sql`(${sql.join(val)})`)\n          )}`,\n          this._compoundValues.length > 0\n            ? sql.join(this._compoundValues, \" \")\n            : null,\n          this._orderByValues.length > 0\n            ? sql.join([sql`ORDER BY`, sql.join(this._orderByValues)], \" \")\n            : null,\n          this._limitOffsetValue.toSql().isEmpty\n            ? null\n            : this._limitOffsetValue,\n        ].filter((v) => v),\n        \" \"\n      );\n    },\n  };\n};\n\nexport const isValues = (val: unknown): val is IValuesStatement => {\n  return (\n    val !== null &&\n    typeof val === \"object\" &&\n    (val as IValuesStatement).type === TokenType.Values\n  );\n};\n","import { ISql, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\nimport { toToken } from \"./rawSql\";\nimport { ISelectStatement, isSelect } from \"./statements/select\";\nimport { isValues, IValuesStatement } from \"./statements/values\";\n\ntype IUnionArg = ISelectStatement | IValuesStatement | ISql;\n\nexport interface ICompoundOperator extends IBaseToken<TokenType.OrderTerm> {\n  _compoundType: \"UNION\" | \"UNION ALL\" | \"INTERSECT\" | \"EXCEPT\";\n  _value: ISelectStatement | IValuesStatement | IBaseToken<TokenType.RawSql>;\n}\n\nexport interface ICompoundState {\n  _compoundValues: ICompoundOperator[];\n\n  union: typeof union;\n  unionAll: typeof unionAll;\n  intersect: typeof intersect;\n  except: typeof except;\n  withoutCompound: typeof withoutCompound;\n}\n\nconst makeCompounds = <T extends ICompoundState>(\n  state: T,\n  type: \"UNION\" | \"UNION ALL\" | \"INTERSECT\" | \"EXCEPT\",\n  values: IUnionArg[]\n): T => {\n  return {\n    ...state,\n    _compoundValues: [\n      ...state._compoundValues,\n      ...values.map((val): ICompoundOperator => {\n        const token = toToken(val);\n\n        return {\n          type: TokenType.OrderTerm,\n          _compoundType: type,\n          _value: isSelect(token)\n            ? token.withoutWith().withoutLimit().withoutOrder().withoutOffset()\n            : isValues(token)\n            ? token.withoutWith().withoutLimit().withoutOrder().withoutOffset()\n            : (token as IValuesStatement | IBaseToken<TokenType.RawSql>),\n          toSql() {\n            return sql`${sql.raw(this._compoundType)} ${this._value}`;\n          },\n        };\n      }),\n    ],\n  };\n};\n\nexport function union<T extends ICompoundState>(\n  this: T,\n  ...values: IUnionArg[]\n) {\n  return makeCompounds(this, \"UNION\", values);\n}\nexport function unionAll<T extends ICompoundState>(\n  this: T,\n  ...values: IUnionArg[]\n) {\n  return makeCompounds(this, \"UNION ALL\", values);\n}\nexport function intersect<T extends ICompoundState>(\n  this: T,\n  ...values: IUnionArg[]\n) {\n  return makeCompounds(this, \"INTERSECT\", values);\n}\nexport function except<T extends ICompoundState>(\n  this: T,\n  ...values: IUnionArg[]\n) {\n  return makeCompounds(this, \"EXCEPT\", values);\n}\n\nexport function withoutCompound<T extends ICompoundState>(this: T) {\n  return { ...this, _compoundValues: [] };\n}\n","import { IContainsTable, ISql, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken } from \"../types\";\nimport { alias } from \"./alias\";\nimport { toToken } from \"./rawSql\";\nimport { wrapParentheses } from \"./utils\";\n\nexport interface IFromState {\n  _fromValues: (\n    | IContainsTable\n    | IBaseToken\n    | { select: IContainsTable | IBaseToken; alias: string }\n  )[];\n\n  from: typeof from;\n}\n\nexport function from<T extends IFromState>(\n  this: T,\n  ...values: (\n    | IBaseToken\n    | ISqlAdapter\n    | IContainsTable\n    | string\n    | Record<string, IBaseToken | ISqlAdapter | IContainsTable | string>\n  )[]\n): T {\n  return {\n    ...this,\n    _fromValues: [\n      ...this._fromValues,\n      ...values\n        .map((v) => {\n          if (typeof v === \"string\") {\n            return sql.table(v);\n          } else if (isToken(v) || sql.isSql(v) || sql.isTable(v)) {\n            return toToken(wrapParentheses(v));\n          } else {\n            return Object.entries(v).map(([k, v]) => ({\n              select:\n                typeof v === \"string\"\n                  ? sql.table(v)\n                  : toToken(wrapParentheses(v)),\n              alias: k,\n            }));\n          }\n        })\n        .flat(),\n    ],\n  };\n}\n\nexport const fromToSql = (state: IFromState): ISql | null => {\n  return state._fromValues.length > 0\n    ? sql.join(\n        state._fromValues.map((v) =>\n          isToken(v) || sql.isTable(v) ? v : alias(v.select, v.alias)\n        )\n      )\n    : null;\n};\n","import { ISql, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../../types\";\nimport { alias } from \"../alias\";\nimport {\n  except,\n  ICompoundState,\n  intersect,\n  union,\n  unionAll,\n  withoutCompound,\n} from \"../compounds\";\nimport { ICTEState, With, withoutWith, withRecursive } from \"../cte\";\nimport { from, fromToSql, IFromState } from \"../from\";\nimport {\n  IJoinState,\n  join,\n  joinCross,\n  joinFull,\n  joinFullNatural,\n  joinFullNaturalOuter,\n  joinFullOuter,\n  joinInner,\n  joinInnerNatural,\n  joinLeft,\n  joinLeftNatural,\n  joinLeftNaturalOuter,\n  joinLeftOuter,\n  joinNatural,\n  joinRight,\n  joinRightNatural,\n  joinRightNaturalOuter,\n  joinRightOuter,\n  withoutJoin,\n} from \"../join\";\nimport {\n  buildInitialLimitOffsetState,\n  ILimitOffsetState,\n  limit,\n  offset,\n  withoutLimit,\n  withoutOffset,\n} from \"../limitOffset\";\nimport { IOrderState, orderBy, withoutOrder } from \"../order\";\nimport { toToken } from \"../rawSql\";\nimport { IWhereState, orWhere, where } from \"../where\";\nimport { IValuesStatement } from \"./values\";\n\nexport const isSelect = (val: unknown): val is ISelectStatement => {\n  return (\n    val !== null &&\n    typeof val === \"object\" &&\n    (val as ISelectStatement).type === TokenType.Select\n  );\n};\n\n// TODO: add filter, window support\nexport interface ISelectStatement\n  extends IBaseToken<TokenType.Select>,\n    IOrderState,\n    ICompoundState,\n    ILimitOffsetState,\n    ICTEState,\n    IWhereState,\n    IFromState,\n    IJoinState {\n  _distinctValue: boolean;\n\n  _selectValues: {\n    toSelect: \"*\" | string | ISelectStatement | IBaseToken;\n    alias?: string;\n  }[];\n\n  _groupByValues: (IBaseToken | string)[];\n  _havingValue?: IBaseToken;\n\n  distinct(val: boolean): ISelectStatement;\n  select(...args: ISelectArgType[]): ISelectStatement;\n\n  groupBy(...values: (IBaseToken | ISqlAdapter | string)[]): ISelectStatement;\n  having(val: IBaseToken | ISqlAdapter): ISelectStatement;\n}\n\ntype ISelectArgType =\n  | \"*\"\n  | string\n  | ISqlAdapter\n  | ISelectStatement\n  | IValuesStatement\n  | { [key: string]: ISqlAdapter | string | ISelectStatement }\n  | IBaseToken;\n\nconst selectArgsToValues = (\n  args: ISelectArgType[]\n): ISelectStatement[\"_selectValues\"] => {\n  if (args === null || args === undefined || args.length === 0)\n    return [{ toSelect: \"*\" }];\n\n  return args.flatMap((arg, i) => {\n    if (arg === \"*\" && i === 0) return { toSelect: \"*\" };\n    if (typeof arg === \"string\") return { toSelect: arg };\n    if (isToken(arg) || sql.isSql(arg)) return { toSelect: toToken(arg) };\n\n    return Object.entries(arg).map(([columnOrAs, aliasOrQuery]) =>\n      typeof aliasOrQuery === \"string\"\n        ? { toSelect: columnOrAs, alias: aliasOrQuery }\n        : { toSelect: toToken(aliasOrQuery), alias: columnOrAs }\n    );\n  });\n};\n\nexport const select = (...selectArgs: ISelectArgType[]): ISelectStatement => {\n  return {\n    type: TokenType.Select,\n    _fromValues: [],\n    _selectValues: selectArgsToValues(selectArgs),\n    _distinctValue: false,\n    _groupByValues: [],\n    _compoundValues: [],\n    _orderByValues: [],\n    _joinValues: [],\n    _limitOffsetValue: buildInitialLimitOffsetState(),\n    select(...selectArgs: ISelectArgType[]): ISelectStatement {\n      return {\n        ...this,\n        _selectValues: [\n          ...this._selectValues,\n          ...selectArgsToValues(selectArgs),\n        ],\n      };\n    },\n    distinct(val: boolean): ISelectStatement {\n      return {\n        ...this,\n        _distinctValue: val,\n      };\n    },\n    from,\n    where,\n    orWhere,\n    limit,\n    offset,\n    withoutLimit,\n    withoutOffset,\n    groupBy(...values: (IBaseToken | ISql | string)[]): ISelectStatement {\n      return {\n        ...this,\n        _groupByValues: values.map((val) =>\n          typeof val === \"string\" ? val : toToken(val)\n        ),\n      };\n    },\n    having(val: IBaseToken | ISql): ISelectStatement {\n      return { ...this, _havingValue: toToken(val) };\n    },\n    orderBy,\n    withoutOrder,\n\n    with: With,\n    withoutWith,\n    withRecursive,\n\n    union,\n    unionAll,\n    intersect,\n    except,\n    withoutCompound,\n\n    withoutJoin,\n\n    join,\n    joinCross,\n\n    joinNatural,\n\n    joinLeft,\n    joinLeftOuter,\n    joinLeftNatural: joinLeftNatural,\n    joinLeftNaturalOuter: joinLeftNaturalOuter,\n\n    joinRight,\n    joinRightOuter,\n    joinRightNatural: joinRightNatural,\n    joinRightNaturalOuter: joinRightNaturalOuter,\n\n    joinFull,\n    joinFullOuter,\n    joinFullNatural: joinFullNatural,\n    joinFullNaturalOuter: joinFullNaturalOuter,\n\n    joinInner,\n    joinInnerNatural: joinInnerNatural,\n\n    toSql() {\n      return sql.join(\n        [\n          this._cteValue ? this._cteValue : null,\n          sql`SELECT`,\n          this._distinctValue ? sql`DISTINCT` : null,\n          sql.join(\n            this._selectValues.map((val) => {\n              if (val.toSelect === \"*\") {\n                return sql`*`;\n              } else if (typeof val.toSelect === \"string\") {\n                return sql.liter(val.toSelect);\n              } else {\n                return val.alias\n                  ? alias(val.toSelect, val.alias)\n                  : val.toSelect;\n              }\n            })\n          ),\n          this._fromValues.length > 0 || this._joinValues.length > 0\n            ? sql`FROM`\n            : null,\n          fromToSql(this),\n          this._joinValues.length > 0\n            ? sql.join(\n                this._joinValues.map((expr) => expr.toSql()),\n                \" \"\n              )\n            : null,\n          this._whereValue ? sql`WHERE ${this._whereValue}` : null,\n          this._groupByValues.length > 0\n            ? sql`GROUP BY ${sql.join(\n                this._groupByValues.map((val) =>\n                  typeof val === \"string\" ? sql.liter(val) : val\n                )\n              )}`\n            : null,\n          this._groupByValues.length > 0 && this._havingValue\n            ? sql`HAVING ${this._havingValue}`\n            : null,\n          this._compoundValues.length > 0\n            ? sql.join(this._compoundValues, \" \")\n            : null,\n          this._orderByValues.length > 0\n            ? sql.join([sql`ORDER BY`, sql.join(this._orderByValues)], \" \")\n            : null,\n          this._limitOffsetValue.toSql().isEmpty\n            ? null\n            : this._limitOffsetValue,\n        ].filter((v) => v),\n        \" \"\n      );\n    },\n  };\n};\n","import {\n  IContainsTable,\n  IPrimitiveValue,\n  ISqlAdapter,\n  sql,\n} from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../../types\";\nimport { ICTEState, With, withoutWith, withRecursive } from \"../cte\";\nimport {\n  IOrReplaceState,\n  orAbort,\n  orFail,\n  orIgnore,\n  orReplace,\n  orRollback,\n} from \"../orReplace\";\nimport { buildRawSql } from \"../rawSql\";\nimport {\n  IReturningState,\n  returning,\n  returningForState,\n  withoutReturningForState,\n} from \"../returning\";\nimport { ISelectStatement, isSelect } from \"./select\";\nimport { isValues, IValuesStatement } from \"./values\";\n\n// TODO: on conflict support\nexport interface IInsertStatement\n  extends IBaseToken<TokenType.Insert>,\n    ICTEState,\n    IReturningState,\n    IOrReplaceState {\n  _intoTable?: IContainsTable;\n  _columnNames: string[];\n\n  _toInsertValue?:\n    | IValuesStatement\n    | ISelectStatement\n    | { columnName: string; value: IPrimitiveValue | IBaseToken }[][];\n\n  setColumnNames(columnNames: string[]): IInsertStatement;\n  withoutColumnNames(): IInsertStatement;\n\n  insert(arg: IInsertArg): IInsertStatement;\n  withoutInsert(): IInsertStatement;\n\n  withoutInto(): IInsertStatement;\n  into(val: string | IContainsTable): IInsertStatement;\n}\n\ntype IRecArg =\n  | Record<string, IPrimitiveValue | IBaseToken | ISqlAdapter>\n  | Record<string, IPrimitiveValue | IBaseToken | ISqlAdapter>[];\ntype IInsertArg = IValuesStatement | ISelectStatement | IRecArg;\n\nconst mapRecordArg = (arg: IRecArg) => {\n  return (Array.isArray(arg) ? arg : [arg]).map((it) =>\n    Object.entries(it).map(([columnName, value]) => {\n      return {\n        columnName,\n        value: sql.isSql(value) && !isToken(value) ? buildRawSql(value) : value,\n      };\n    })\n  );\n};\n\nconst applyInsertArg = (\n  state: IInsertStatement,\n  arg: IInsertArg\n): IInsertStatement => {\n  if (\n    state._toInsertValue &&\n    (isSelect(state._toInsertValue) || isValues(state._toInsertValue))\n  ) {\n    throw new Error(\n      \"Insert value is already state. If you want to change insert values user resetInsert() before.\"\n    );\n  }\n\n  if (isSelect(arg) || isValues(arg)) {\n    return { ...state, _toInsertValue: arg };\n  }\n\n  return {\n    ...state,\n    _toInsertValue: Array.isArray(state._toInsertValue)\n      ? [...state._toInsertValue, ...mapRecordArg(arg)]\n      : mapRecordArg(arg),\n  };\n};\n\nexport const insert = (insertArg: IInsertArg): IInsertStatement => {\n  return {\n    type: TokenType.Insert,\n    _returningValue: returning(),\n    _columnNames: [],\n    _toInsertValue:\n      isSelect(insertArg) || isValues(insertArg)\n        ? insertArg\n        : mapRecordArg(insertArg),\n\n    with: With,\n    withRecursive,\n    withoutWith,\n\n    orAbort,\n    orFail,\n    orIgnore,\n    orReplace,\n    orRollback,\n\n    returning: returningForState,\n    withoutReturning: withoutReturningForState,\n\n    setColumnNames(names: string[]): IInsertStatement {\n      return { ...this, _columnNames: names };\n    },\n    withoutColumnNames(): IInsertStatement {\n      return { ...this, _columnNames: [] };\n    },\n\n    insert(arg: IInsertArg): IInsertStatement {\n      return applyInsertArg(this, arg);\n    },\n    withoutInsert(): IInsertStatement {\n      return { ...this, _toInsertValue: undefined };\n    },\n\n    into(val: string | IContainsTable): IInsertStatement {\n      return {\n        ...this,\n        _intoTable: typeof val === \"string\" ? sql.table(val) : val,\n      };\n    },\n    withoutInto(): IInsertStatement {\n      return { ...this, _intoTable: undefined };\n    },\n\n    toSql() {\n      if (!this._toInsertValue) {\n        throw new Error(\"Insert values are not set\");\n      }\n\n      if (!this._intoTable) {\n        throw new Error(\"Into table is not set\");\n      }\n\n      const columns =\n        this._columnNames.length > 0\n          ? this._columnNames\n          : Array.isArray(this._toInsertValue)\n          ? this._toInsertValue[0].map(({ columnName }) => columnName)\n          : [];\n\n      return sql.join(\n        [\n          this._cteValue ? this._cteValue : null,\n          sql`INSERT`,\n          this._orReplaceValue\n            ? sql`OR ${sql.raw(this._orReplaceValue)}`\n            : null,\n          sql`INTO`,\n          this._intoTable,\n          columns.length > 0\n            ? sql`(${sql.join(columns.map((c) => sql.liter(c)))})`\n            : null,\n          isValues(this._toInsertValue) || isSelect(this._toInsertValue)\n            ? this._toInsertValue\n            : sql`VALUES ${sql.join(\n                this._toInsertValue.map((toInsertColumns) => {\n                  const toInsert: (IPrimitiveValue | IBaseToken)[] = Array(\n                    toInsertColumns.length\n                  );\n\n                  for (const { columnName, value } of toInsertColumns) {\n                    const index = columns.indexOf(columnName);\n\n                    if (index === -1) {\n                      throw new Error(\n                        `Column ${columnName} is not present at columns set: ${columns}. Make sure that you set all columns with setColumnNames() or each insert objects have the same keys present. Tried to insert: ${JSON.stringify(\n                          toInsertColumns\n                        )}`\n                      );\n                    }\n\n                    toInsert[index] = value;\n                  }\n\n                  return sql`(${sql.join(toInsert)})`;\n                })\n              )}`,\n          this._returningValue,\n        ].filter((v) => v),\n        \" \"\n      );\n    },\n  };\n};\n","import {\n  IContainsTable,\n  IPrimitiveValue,\n  ISqlAdapter,\n  sql,\n} from \"@kikko-land/sql\";\n\nimport { IBaseToken, isToken, TokenType } from \"../../types\";\nimport { ICTEState, With, withoutWith, withRecursive } from \"../cte\";\nimport { from, fromToSql, IFromState } from \"../from\";\nimport {\n  IJoinState,\n  join,\n  joinCross,\n  joinFull,\n  joinFullNatural,\n  joinFullNaturalOuter,\n  joinFullOuter,\n  joinInner,\n  joinInnerNatural,\n  joinLeft,\n  joinLeftNatural,\n  joinLeftNaturalOuter,\n  joinLeftOuter,\n  joinNatural,\n  joinRight,\n  joinRightNatural,\n  joinRightNaturalOuter,\n  joinRightOuter,\n  withoutJoin,\n} from \"../join\";\nimport {\n  IOrReplaceState,\n  orAbort,\n  orFail,\n  orIgnore,\n  orReplace,\n  orRollback,\n} from \"../orReplace\";\nimport { buildRawSql } from \"../rawSql\";\nimport {\n  IReturningState,\n  returning,\n  returningForState,\n  withoutReturningForState,\n} from \"../returning\";\nimport { wrapParentheses } from \"../utils\";\nimport { IWhereState, orWhere, where } from \"../where\";\nimport { ISelectStatement } from \"./select\";\nimport { IValuesStatement } from \"./values\";\n\ntype ISetValue =\n  | {\n      columnName: string;\n      toSet:\n        | IBaseToken<TokenType.RawSql>\n        | IPrimitiveValue\n        | ISelectStatement\n        | IValuesStatement;\n    }\n  | IBaseToken<TokenType.RawSql>;\n\nexport interface IUpdateStatement\n  extends IBaseToken<TokenType.Update>,\n    ICTEState,\n    IWhereState,\n    IFromState,\n    IReturningState,\n    IOrReplaceState,\n    IJoinState {\n  _updateTable: IContainsTable;\n  _setValues: ISetValue[];\n\n  set(...args: ISetArgType[]): IUpdateStatement;\n}\n\ntype ISetArgType =\n  | ISqlAdapter\n  | {\n      [key: string]:\n        | ISqlAdapter\n        | IBaseToken<TokenType.RawSql>\n        | IPrimitiveValue\n        | ISelectStatement\n        | IValuesStatement;\n    }\n  | IBaseToken<TokenType.RawSql>;\n\nexport const update = (tbl: string | IContainsTable): IUpdateStatement => {\n  return {\n    type: TokenType.Update,\n    _updateTable: typeof tbl === \"string\" ? sql.table(tbl) : tbl,\n    _setValues: [],\n    _fromValues: [],\n    _joinValues: [],\n    _returningValue: returning(),\n\n    with: With,\n    withoutWith,\n    withRecursive,\n\n    from,\n\n    where,\n    orWhere,\n\n    returning: returningForState,\n    withoutReturning: withoutReturningForState,\n\n    orAbort,\n    orFail,\n    orIgnore,\n    orReplace,\n    orRollback,\n\n    withoutJoin,\n\n    join,\n    joinCross,\n\n    joinNatural,\n\n    joinLeft,\n    joinLeftOuter,\n    joinLeftNatural: joinLeftNatural,\n    joinLeftNaturalOuter: joinLeftNaturalOuter,\n\n    joinRight,\n    joinRightOuter,\n    joinRightNatural: joinRightNatural,\n    joinRightNaturalOuter: joinRightNaturalOuter,\n\n    joinFull,\n    joinFullOuter,\n    joinFullNatural: joinFullNatural,\n    joinFullNaturalOuter: joinFullNaturalOuter,\n\n    joinInner,\n    joinInnerNatural: joinInnerNatural,\n\n    set(...args: ISetArgType[]): IUpdateStatement {\n      const vals = args.flatMap((m): ISetValue | ISetValue[] => {\n        if (isToken(m)) {\n          return m;\n        } else if (sql.isSql(m)) {\n          return buildRawSql(m);\n        } else {\n          return Object.entries(m).map(([key, val]) => {\n            return {\n              columnName: key,\n              toSet: !isToken(val) && sql.isSql(val) ? buildRawSql(val) : val,\n            };\n          });\n        }\n      });\n\n      return { ...this, _setValues: [...this._setValues, ...vals] };\n    },\n\n    toSql() {\n      return sql.join(\n        [\n          this._cteValue ? this._cteValue : null,\n          sql`UPDATE`,\n          this._orReplaceValue\n            ? sql`OR ${sql.raw(this._orReplaceValue)}`\n            : null,\n          this._updateTable,\n          sql`SET`,\n          sql.join(\n            this._setValues.map((val) =>\n              isToken(val)\n                ? val\n                : sql`${sql.liter(val.columnName)} = ${wrapParentheses(\n                    val.toSet\n                  )}`\n            )\n          ),\n          this._fromValues.length > 0 || this._joinValues.length > 0\n            ? sql`FROM`\n            : null,\n          fromToSql(this),\n          this._joinValues.length > 0\n            ? sql.join(\n                this._joinValues.map((expr) => expr.toSql()),\n                \" \"\n              )\n            : null,\n          this._whereValue ? sql`WHERE ${this._whereValue}` : null,\n          this._returningValue,\n        ].filter((v) => v),\n        \" \"\n      );\n    },\n  };\n};\n","import { IPrimitiveValue, ISqlAdapter, sql } from \"@kikko-land/sql\";\n\nimport { IBaseToken, TokenType } from \"../types\";\n\nexport interface IUnaryOperator extends IBaseToken<TokenType.Unary> {\n  _operator: \"NOT\";\n  _expr: IBaseToken | ISqlAdapter | IPrimitiveValue;\n}\n\nexport const not = (\n  expr: IBaseToken | ISqlAdapter | IPrimitiveValue\n): IUnaryOperator => {\n  return {\n    _operator: \"NOT\",\n    type: TokenType.Unary,\n    _expr: expr,\n    toSql() {\n      return sql`NOT (${this._expr})`;\n    },\n  };\n};\n"],"names":["sql","isTable"],"mappings":"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"}