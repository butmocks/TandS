import { IPrimitiveValue, ISqlAdapter } from "@kikko-land/sql";
import { IBaseToken, TokenType } from "../types";
export interface IBinaryOperator extends IBaseToken<TokenType.Binary> {
    _operator: "<" | "<=" | ">" | ">=" | "=" | "<>" | "AND" | "OR" | "IN" | "NOT IN" | "LIKE" | "NOT LIKE" | "BETWEEN" | "NOT BETWEEN" | "GLOB" | "NOT GLOB" | "MATCH" | "NOT MATCH" | "REGEXP" | "NOT REGEXP";
    _left: IBaseToken;
    _right: IBaseToken | IBaseToken[];
}
export declare const isBinaryOperator: (t: unknown) => t is IBinaryOperator;
export declare const notEq$: (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare const notEq: (left: IBaseToken | ISqlAdapter | IPrimitiveValue, right: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare const eq$: (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare const eq: (left: IBaseToken | ISqlAdapter | IPrimitiveValue, right: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare const gt$: (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare const gt: (left: IBaseToken | ISqlAdapter | IPrimitiveValue, right: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare const gtEq$: (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare const gtEq: (left: IBaseToken | ISqlAdapter | IPrimitiveValue, right: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare const lt$: (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare const lt: (left: IBaseToken | ISqlAdapter | IPrimitiveValue, right: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare const ltEq$: (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare const ltEq: (left: IBaseToken | ISqlAdapter | IPrimitiveValue, right: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare const like: (left: IBaseToken | ISqlAdapter | IPrimitiveValue, right: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare const like$: (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare const notLike: (left: IBaseToken | ISqlAdapter | IPrimitiveValue, right: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare const notLike$: (right: IBaseToken | ISqlAdapter | IPrimitiveValue) => (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare const In: (left: IBaseToken | ISqlAdapter | IPrimitiveValue, ...right: (IBaseToken | ISqlAdapter | IPrimitiveValue)[]) => IBinaryOperator;
export declare const notIn: (left: IBaseToken | ISqlAdapter | IPrimitiveValue, ...right: (IBaseToken | ISqlAdapter | IPrimitiveValue)[]) => IBinaryOperator;
export declare const in$: (...values: (IBaseToken | ISqlAdapter | IPrimitiveValue)[]) => (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare const notIn$: (...values: (IBaseToken | ISqlAdapter | IPrimitiveValue)[]) => (left: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator;
export declare type IConditionValue = IBaseToken | ISqlAdapter | Record<string, ((left: IBaseToken | ISqlAdapter | IPrimitiveValue) => IBinaryOperator) | IBaseToken | ISqlAdapter | IPrimitiveValue>;
export declare const conditionValuesToToken: (values: IConditionValue[]) => IBaseToken<TokenType>[];
export declare const and: (...values: IConditionValue[]) => IBinaryOperator;
export declare const or: (...values: IConditionValue[]) => IBinaryOperator;
