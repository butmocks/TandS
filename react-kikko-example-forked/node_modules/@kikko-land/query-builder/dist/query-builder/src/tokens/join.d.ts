import { IContainsTable, ISqlAdapter } from "@kikko-land/sql";
import { IBaseToken, TokenType } from "../types";
import { IConditionValue } from "./binary";
import { ISelectStatement } from "./statements/select";
declare type IJoinOperator = {
    joinType: "CROSS";
} | ({
    isNatural: boolean;
} & ({
    joinType: "LEFT" | "RIGHT" | "FULL";
    isOuter: boolean;
} | {
    joinType: "INNER";
} | {}));
export interface IJoinExpr extends IBaseToken<TokenType.Join> {
    _operator?: IJoinOperator;
    _toJoin: IContainsTable | IBaseToken | {
        toSelect: IBaseToken;
        alias: string;
    };
    _on?: IConditionValue;
}
declare type IToJoinArg = IBaseToken | ISqlAdapter | IContainsTable | string | {
    [key: string]: ISqlAdapter | ISelectStatement | string;
};
export interface IJoinState {
    _joinValues: IJoinExpr[];
    withoutJoin: typeof withoutJoin;
    join: typeof join;
    joinCross: typeof joinCross;
    joinNatural: typeof joinNatural;
    joinLeft: typeof joinLeft;
    joinLeftOuter: typeof joinLeftOuter;
    joinLeftNatural: typeof joinLeftNatural;
    joinLeftNaturalOuter: typeof joinLeftNaturalOuter;
    joinRight: typeof joinRight;
    joinRightOuter: typeof joinRightOuter;
    joinRightNatural: typeof joinRightNatural;
    joinRightNaturalOuter: typeof joinRightNaturalOuter;
    joinFull: typeof joinFull;
    joinFullOuter: typeof joinFullOuter;
    joinFullNatural: typeof joinFullNatural;
    joinFullNaturalOuter: typeof joinFullNaturalOuter;
    joinInner: typeof joinInner;
    joinInnerNatural: typeof joinInnerNatural;
}
export declare function join<T extends IJoinState>(this: T, toJoin: IToJoinArg, on?: IConditionValue): T;
export declare function joinCross<T extends IJoinState>(this: T, toJoin: IToJoinArg, on?: IConditionValue): T;
export declare function joinNatural<T extends IJoinState>(this: T, toJoin: IToJoinArg, on?: IConditionValue): T;
export declare function joinLeftNatural<T extends IJoinState>(this: T, toJoin: IToJoinArg, on?: IConditionValue): T;
export declare function joinRightNatural<T extends IJoinState>(this: T, toJoin: IToJoinArg, on?: IConditionValue): T;
export declare function joinFullNatural<T extends IJoinState>(this: T, toJoin: IToJoinArg, on?: IConditionValue): T;
export declare function joinLeftNaturalOuter<T extends IJoinState>(this: T, toJoin: IToJoinArg, on?: IConditionValue): T;
export declare function joinRightNaturalOuter<T extends IJoinState>(this: T, toJoin: IToJoinArg, on?: IConditionValue): T;
export declare function joinFullNaturalOuter<T extends IJoinState>(this: T, toJoin: IToJoinArg, on?: IConditionValue): T;
export declare function joinInnerNatural<T extends IJoinState>(this: T, toJoin: IToJoinArg, on?: IConditionValue): T;
export declare function joinLeft<T extends IJoinState>(this: T, toJoin: IToJoinArg, on?: IConditionValue): T;
export declare function joinRight<T extends IJoinState>(this: T, toJoin: IToJoinArg, on?: IConditionValue): T;
export declare function joinFull<T extends IJoinState>(this: T, toJoin: IToJoinArg, on?: IConditionValue): T;
export declare function joinLeftOuter<T extends IJoinState>(this: T, toJoin: IToJoinArg, on?: IConditionValue): T;
export declare function joinRightOuter<T extends IJoinState>(this: T, toJoin: IToJoinArg, on?: IConditionValue): T;
export declare function joinFullOuter<T extends IJoinState>(this: T, toJoin: IToJoinArg, on?: IConditionValue): T;
export declare function joinInner<T extends IJoinState>(this: T, toJoin: IToJoinArg, on?: IConditionValue): T;
export declare function withoutJoin<T extends IJoinState>(this: T): T;
export {};
