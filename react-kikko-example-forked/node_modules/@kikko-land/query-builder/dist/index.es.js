import { sql as sql$1, isTable } from "@kikko-land/sql";
export * from "@kikko-land/sql";
var TokenType = /* @__PURE__ */ ((TokenType2) => {
  TokenType2["Binary"] = "Binary";
  TokenType2["Unary"] = "Unary";
  TokenType2["Alias"] = "Alias";
  TokenType2["Compound"] = "Compound";
  TokenType2["Select"] = "Select";
  TokenType2["Update"] = "Update";
  TokenType2["Delete"] = "Delete";
  TokenType2["Insert"] = "Insert";
  TokenType2["Values"] = "Values";
  TokenType2["OrderTerm"] = "OrderTerm";
  TokenType2["LimitOffsetTerm"] = "LimitOffsetTerm";
  TokenType2["RawSql"] = "RawSql";
  TokenType2["CompoundOperator"] = "CompoundOperator";
  TokenType2["CTE"] = "CTE";
  TokenType2["Join"] = "Join";
  TokenType2["Returning"] = "Returning";
  return TokenType2;
})(TokenType || {});
const isToken = (t) => {
  return t !== null && typeof t === "object" && "type" in t && "toSql" in t && Object.values(TokenType).includes(t.type);
};
const buildRawSql = (t) => {
  return {
    type: TokenType.RawSql,
    toSql() {
      return sql$1`${t}`;
    }
  };
};
const toToken = (t) => {
  if (isToken(t))
    return t;
  if (sql$1.isSql(t)) {
    return buildRawSql(t);
  }
  return buildRawSql(t);
};
const isBinaryOperator = (t) => {
  return t !== null && typeof t === "object" && "type" in t && t.type === TokenType.Binary;
};
const binaryOperator = (operator, left, right) => {
  return {
    type: TokenType.Binary,
    _left: toToken(left),
    _right: Array.isArray(right) ? right.map(toToken) : toToken(right),
    _operator: operator,
    toSql() {
      return sql$1`${wrapParentheses(this._left)} ${sql$1.raw(this._operator)} ${Array.isArray(this._right) ? sql$1`(${sql$1.join(this._right)})` : wrapParentheses(this._right)}`;
    }
  };
};
const notEq$ = (right) => {
  return (left) => notEq(left, right);
};
const notEq = (left, right) => {
  return binaryOperator("<>", left, right);
};
const eq$ = (right) => {
  return (left) => eq(left, right);
};
const eq = (left, right) => {
  return binaryOperator("=", left, right);
};
const gt$ = (right) => {
  return (left) => gt(left, right);
};
const gt = (left, right) => {
  return binaryOperator(">", left, right);
};
const gtEq$ = (right) => {
  return (left) => gtEq(left, right);
};
const gtEq = (left, right) => {
  return binaryOperator(">=", left, right);
};
const lt$ = (right) => {
  return (left) => lt(left, right);
};
const lt = (left, right) => {
  return binaryOperator("<", left, right);
};
const ltEq$ = (right) => {
  return (left) => ltEq(left, right);
};
const ltEq = (left, right) => {
  return binaryOperator("<=", left, right);
};
const like = (left, right) => {
  return binaryOperator("LIKE", left, right);
};
const like$ = (right) => {
  return (left) => like(left, right);
};
const notLike = (left, right) => {
  return binaryOperator("NOT LIKE", left, right);
};
const notLike$ = (right) => {
  return (left) => notLike(left, right);
};
const In = (left, ...right) => {
  return binaryOperator("IN", left, right);
};
const notIn = (left, ...right) => {
  return binaryOperator("NOT IN", left, right);
};
const in$ = (...values2) => (left) => {
  return In(left, ...values2);
};
const notIn$ = (...values2) => (left) => {
  return notIn(left, ...values2);
};
const conditionValuesToToken = (values2) => {
  return values2.flatMap((v) => isToken(v) || sql$1.isSql(v) ? toToken(v) : Object.entries(v).map(([k, expr]) => toToken(typeof expr === "function" ? expr(sql$1.liter(k)) : eq(sql$1.liter(k), expr)))).filter((v) => !v.toSql().isEmpty);
};
const conditionOperator = (type, ...values2) => {
  const exprs = conditionValuesToToken(values2);
  if (exprs.length <= 1) {
    throw new Error("Must at least two arguments present");
  }
  let current = binaryOperator(type, exprs[0], exprs[1]);
  for (const next of exprs.slice(2)) {
    current = binaryOperator(type, current, next);
  }
  return current;
};
const and = (...values2) => {
  return conditionOperator("AND", ...values2);
};
const or = (...values2) => {
  return conditionOperator("OR", ...values2);
};
const wrapParentheses = (val) => isBinaryOperator(val) && val._operator === "OR" || isToken(val) && (val.type === TokenType.Select || val.type === TokenType.Values) ? sql$1`(${val})` : val;
const alias = (left, right) => {
  return {
    type: TokenType.Alias,
    _left: toToken(left),
    _right: right,
    toSql() {
      return sql$1`${wrapParentheses(this._left)} AS ${sql$1.liter(this._right)}`;
    }
  };
};
const baseJoin = (operator, toJoin, on) => {
  return {
    type: TokenType.Join,
    _operator: operator,
    _toJoin: (() => {
      if (typeof toJoin === "string") {
        return sql$1.table(toJoin);
      } else if (isTable(toJoin)) {
        return toJoin;
      } else if (isToken(toJoin) || sql$1.isSql(toJoin)) {
        return toToken(toJoin);
      } else {
        const entries = Object.entries(toJoin);
        if (entries.length === 0) {
          throw new Error("No alias select present for join");
        }
        if (entries.length > 1) {
          throw new Error("Only one select could be specified at join");
        }
        return { toSelect: toToken(entries[0][1]), alias: entries[0][0] };
      }
    })(),
    _on: on,
    toSql() {
      const operatorSql = (() => {
        if (!this._operator)
          return [sql$1`JOIN`];
        if ("joinType" in this._operator) {
          if (this._operator.joinType === "CROSS") {
            return [sql$1`CROSS JOIN`];
          } else {
            return [
              this._operator.isNatural ? sql$1`NATURAL` : void 0,
              sql$1.raw(this._operator.joinType),
              "isOuter" in this._operator && this._operator.isOuter ? sql$1`OUTER` : void 0,
              sql$1`JOIN`
            ];
          }
        } else {
          return [
            this._operator.isNatural ? sql$1`NATURAL` : void 0,
            sql$1`JOIN`
          ];
        }
      })().flatMap((v) => v === void 0 ? [] : v);
      return sql$1.join([
        ...operatorSql,
        "toSelect" in this._toJoin ? alias(this._toJoin.toSelect, this._toJoin.alias) : wrapParentheses(this._toJoin),
        ...this._on ? [sql$1`ON`, ...conditionValuesToToken([this._on])] : []
      ], " ");
    }
  };
};
function join(toJoin, on) {
  return {
    ...this,
    _joinValues: [...this._joinValues, baseJoin(void 0, toJoin, on)]
  };
}
function joinCross(toJoin, on) {
  return {
    ...this,
    _joinValues: [
      ...this._joinValues,
      baseJoin({ joinType: "CROSS" }, toJoin, on)
    ]
  };
}
function joinNatural(toJoin, on) {
  return {
    ...this,
    _joinValues: [
      ...this._joinValues,
      baseJoin({ isNatural: true }, toJoin, on)
    ]
  };
}
function joinLeftNatural(toJoin, on) {
  return {
    ...this,
    _joinValues: [
      ...this._joinValues,
      baseJoin({ isNatural: true, isOuter: false, joinType: "LEFT" }, toJoin, on)
    ]
  };
}
function joinRightNatural(toJoin, on) {
  return {
    ...this,
    _joinValues: [
      ...this._joinValues,
      baseJoin({ isNatural: true, isOuter: false, joinType: "RIGHT" }, toJoin, on)
    ]
  };
}
function joinFullNatural(toJoin, on) {
  return {
    ...this,
    _joinValues: [
      ...this._joinValues,
      baseJoin({ isNatural: true, isOuter: false, joinType: "FULL" }, toJoin, on)
    ]
  };
}
function joinLeftNaturalOuter(toJoin, on) {
  return {
    ...this,
    _joinValues: [
      ...this._joinValues,
      baseJoin({ isNatural: true, isOuter: true, joinType: "LEFT" }, toJoin, on)
    ]
  };
}
function joinRightNaturalOuter(toJoin, on) {
  return {
    ...this,
    _joinValues: [
      ...this._joinValues,
      baseJoin({ isNatural: true, isOuter: true, joinType: "RIGHT" }, toJoin, on)
    ]
  };
}
function joinFullNaturalOuter(toJoin, on) {
  return {
    ...this,
    _joinValues: [
      ...this._joinValues,
      baseJoin({ isNatural: true, isOuter: true, joinType: "FULL" }, toJoin, on)
    ]
  };
}
function joinInnerNatural(toJoin, on) {
  return {
    ...this,
    _joinValues: [
      ...this._joinValues,
      baseJoin({ isNatural: true, joinType: "INNER" }, toJoin, on)
    ]
  };
}
function joinLeft(toJoin, on) {
  return {
    ...this,
    _joinValues: [
      ...this._joinValues,
      baseJoin({ isNatural: false, joinType: "LEFT" }, toJoin, on)
    ]
  };
}
function joinRight(toJoin, on) {
  return {
    ...this,
    _joinValues: [
      ...this._joinValues,
      baseJoin({ isNatural: false, joinType: "RIGHT" }, toJoin, on)
    ]
  };
}
function joinFull(toJoin, on) {
  return {
    ...this,
    _joinValues: [
      ...this._joinValues,
      baseJoin({ isNatural: false, joinType: "FULL" }, toJoin, on)
    ]
  };
}
function joinLeftOuter(toJoin, on) {
  return {
    ...this,
    _joinValues: [
      ...this._joinValues,
      baseJoin({ isNatural: false, isOuter: true, joinType: "LEFT" }, toJoin, on)
    ]
  };
}
function joinRightOuter(toJoin, on) {
  return {
    ...this,
    _joinValues: [
      ...this._joinValues,
      baseJoin({ isNatural: false, isOuter: true, joinType: "RIGHT" }, toJoin, on)
    ]
  };
}
function joinFullOuter(toJoin, on) {
  return {
    ...this,
    _joinValues: [
      ...this._joinValues,
      baseJoin({ isNatural: false, isOuter: true, joinType: "FULL" }, toJoin, on)
    ]
  };
}
function joinInner(toJoin, on) {
  return {
    ...this,
    _joinValues: [
      ...this._joinValues,
      baseJoin({ isNatural: false, joinType: "INNER" }, toJoin),
      on
    ]
  };
}
function withoutJoin() {
  return {
    ...this,
    _joinValues: []
  };
}
const orderTerm = (type, val, nullOrder) => {
  return {
    type: TokenType.OrderTerm,
    _orderType: type,
    _val: typeof val === "string" ? val : toToken(val),
    _nullOrder: nullOrder,
    toSql() {
      return sql$1.join([
        typeof this._val === "string" ? sql$1.liter(this._val) : this._val,
        sql$1.raw(this._orderType),
        nullOrder ? sql$1.raw(nullOrder) : sql$1.empty
      ], " ");
    }
  };
};
const desc = (val, nullOrder) => {
  return orderTerm("DESC", val, nullOrder);
};
const asc = (val, nullOrder) => {
  return orderTerm("ASC", val, nullOrder);
};
function orderBy(...orderTerm2) {
  return {
    ...this,
    _orderByValues: [...this._orderByValues, ...orderTerm2]
  };
}
function withoutOrder() {
  return {
    ...this,
    _orderByValue: void 0
  };
}
const cteTerm = (args) => {
  return {
    type: TokenType.CTE,
    _recursive: args.recursive,
    _values: [
      {
        table: args.table,
        columns: args.columns,
        select: args.select
      }
    ],
    toSql() {
      return sql$1.join([
        sql$1`WITH`,
        this._recursive ? sql$1`RECURSIVE` : null,
        sql$1.join(this._values.map((v) => sql$1`${sql$1.liter(v.table)}(${sql$1.join(v.columns.map(sql$1.liter))}) AS (${v.select})`))
      ].filter((b) => b), " ");
    }
  };
};
const cteTermState = (state, args) => {
  var _a, _b;
  if (((_a = state._cteValue) == null ? void 0 : _a._recursive) === true && args.recursive === false) {
    throw new Error("WITH is already recursive");
  }
  if (((_b = state._cteValue) == null ? void 0 : _b._recursive) === false && args.recursive === true) {
    throw new Error("WITH is not recursive");
  }
  return {
    ...state,
    _cteValue: state._cteValue ? {
      ...state._cteValue,
      values: [...state._cteValue._values, {}]
    } : cteTerm({
      table: args.table,
      columns: args.columns,
      recursive: args.recursive,
      select: sql$1.isSql(args.select) ? buildRawSql(args.select) : args.select
    })
  };
};
function With(args) {
  return cteTermState(this, { ...args, recursive: false });
}
function withRecursive(args) {
  return cteTermState(this, { ...args, recursive: true });
}
function withoutWith() {
  return { ...this, cteValue: void 0 };
}
const returning = (...args) => {
  return {
    type: TokenType.Returning,
    _values: args.flatMap((arg) => {
      if (sql$1.isSql(arg) || isToken(arg)) {
        return { _toSelect: toToken(arg) };
      } else if (typeof arg === "string") {
        return { _toSelect: arg };
      } else {
        return Object.entries(arg).map(([columnOrAs, aliasOrQuery]) => {
          return typeof aliasOrQuery === "string" ? { _toSelect: columnOrAs, _alias: aliasOrQuery } : { _toSelect: toToken(aliasOrQuery), _alias: columnOrAs };
        });
      }
    }),
    toSql() {
      return this._values.length > 0 ? sql$1`RETURNING ${sql$1.join(this._values.map((val) => {
        if (val._toSelect === "*") {
          return sql$1`*`;
        } else {
          return val._alias ? alias(val._toSelect, val._alias) : val._toSelect;
        }
      }))}` : sql$1.empty;
    }
  };
};
function returningForState(...args) {
  return {
    ...this,
    _returningValue: {
      ...this._returningValue,
      _values: [...this._returningValue._values, ...returning(...args)._values]
    }
  };
}
function withoutReturningForState() {
  return {
    ...this,
    _returningValue: returning()
  };
}
const constructWhere = function(state, andOrOr, values2) {
  const finalValues = state._whereValue ? [state._whereValue, ...conditionValuesToToken(values2)] : conditionValuesToToken(values2);
  if (finalValues.length > 1) {
    return {
      ...state,
      _whereValue: andOrOr === "and" ? and(...finalValues) : or(...finalValues)
    };
  } else {
    return { ...state, _whereValue: finalValues[0] };
  }
};
function where(...values2) {
  return constructWhere(this, "and", values2);
}
function orWhere(...values2) {
  return constructWhere(this, "or", values2);
}
const deleteFrom = (tbl) => {
  return {
    type: TokenType.Delete,
    _deleteTable: typeof tbl === "string" ? sql$1.table(tbl) : tbl,
    _returningValue: returning(),
    with: With,
    withoutWith,
    withRecursive,
    where,
    orWhere,
    returning: returningForState,
    withoutReturning: withoutReturningForState,
    toSql() {
      return sql$1.join([
        this._cteValue ? this._cteValue : null,
        sql$1`DELETE FROM ${this._deleteTable}`,
        this._whereValue ? sql$1`WHERE ${this._whereValue}` : null,
        this._returningValue
      ].filter((v) => v), " ");
    }
  };
};
function orAbort() {
  return { ...this, _orReplaceValue: "ABORT" };
}
function orFail() {
  return { ...this, _orReplaceValue: "FAIL" };
}
function orIgnore() {
  return { ...this, _orReplaceValue: "IGNORE" };
}
function orReplace() {
  return { ...this, _orReplaceValue: "REPLACE" };
}
function orRollback() {
  return { ...this, _orReplaceValue: "ROLLBACK" };
}
const buildInitialLimitOffsetState = () => {
  return {
    type: TokenType.LimitOffsetTerm,
    toSql() {
      return this._limitValue ? sql$1.join([
        this._limitValue ? sql$1`LIMIT ${wrapParentheses(this._limitValue)}` : null,
        this._offsetValue && this._limitValue ? sql$1`OFFSET ${wrapParentheses(this._offsetValue)}` : null
      ].filter((v) => v), " ") : sql$1.empty;
    }
  };
};
function limit(val) {
  return {
    ...this,
    _limitOffsetValue: { ...this._limitOffsetValue, _limitValue: toToken(val) }
  };
}
function withoutLimit() {
  return {
    ...this,
    _limitOffsetValue: { ...this._limitOffsetValue, _limitValue: void 0 }
  };
}
function offset(val) {
  return {
    ...this,
    _limitOffsetValue: {
      ...this._limitOffsetValue,
      _offsetValue: toToken(val)
    }
  };
}
function withoutOffset() {
  return {
    ...this,
    _limitOffsetValue: { ...this._limitOffsetValue, _offsetValue: void 0 }
  };
}
const values = (...vals) => {
  return {
    type: TokenType.Values,
    _values: vals,
    _compoundValues: [],
    _orderByValues: [],
    _limitOffsetValue: buildInitialLimitOffsetState(),
    orderBy,
    withoutOrder,
    union,
    unionAll,
    intersect,
    except,
    withoutCompound,
    limit,
    withoutLimit,
    offset,
    withoutOffset,
    withoutWith,
    withRecursive,
    with: With,
    toSql() {
      return sql$1.join([
        this._cteValue ? this._cteValue : null,
        sql$1`VALUES ${sql$1.join(this._values.map((val) => sql$1`(${sql$1.join(val)})`))}`,
        this._compoundValues.length > 0 ? sql$1.join(this._compoundValues, " ") : null,
        this._orderByValues.length > 0 ? sql$1.join([sql$1`ORDER BY`, sql$1.join(this._orderByValues)], " ") : null,
        this._limitOffsetValue.toSql().isEmpty ? null : this._limitOffsetValue
      ].filter((v) => v), " ");
    }
  };
};
const isValues = (val) => {
  return val !== null && typeof val === "object" && val.type === TokenType.Values;
};
const makeCompounds = (state, type, values2) => {
  return {
    ...state,
    _compoundValues: [
      ...state._compoundValues,
      ...values2.map((val) => {
        const token = toToken(val);
        return {
          type: TokenType.OrderTerm,
          _compoundType: type,
          _value: isSelect(token) ? token.withoutWith().withoutLimit().withoutOrder().withoutOffset() : isValues(token) ? token.withoutWith().withoutLimit().withoutOrder().withoutOffset() : token,
          toSql() {
            return sql$1`${sql$1.raw(this._compoundType)} ${this._value}`;
          }
        };
      })
    ]
  };
};
function union(...values2) {
  return makeCompounds(this, "UNION", values2);
}
function unionAll(...values2) {
  return makeCompounds(this, "UNION ALL", values2);
}
function intersect(...values2) {
  return makeCompounds(this, "INTERSECT", values2);
}
function except(...values2) {
  return makeCompounds(this, "EXCEPT", values2);
}
function withoutCompound() {
  return { ...this, _compoundValues: [] };
}
function from(...values2) {
  return {
    ...this,
    _fromValues: [
      ...this._fromValues,
      ...values2.map((v) => {
        if (typeof v === "string") {
          return sql$1.table(v);
        } else if (isToken(v) || sql$1.isSql(v) || sql$1.isTable(v)) {
          return toToken(wrapParentheses(v));
        } else {
          return Object.entries(v).map(([k, v2]) => ({
            select: typeof v2 === "string" ? sql$1.table(v2) : toToken(wrapParentheses(v2)),
            alias: k
          }));
        }
      }).flat()
    ]
  };
}
const fromToSql = (state) => {
  return state._fromValues.length > 0 ? sql$1.join(state._fromValues.map((v) => isToken(v) || sql$1.isTable(v) ? v : alias(v.select, v.alias))) : null;
};
const isSelect = (val) => {
  return val !== null && typeof val === "object" && val.type === TokenType.Select;
};
const selectArgsToValues = (args) => {
  if (args === null || args === void 0 || args.length === 0)
    return [{ toSelect: "*" }];
  return args.flatMap((arg, i) => {
    if (arg === "*" && i === 0)
      return { toSelect: "*" };
    if (typeof arg === "string")
      return { toSelect: arg };
    if (isToken(arg) || sql$1.isSql(arg))
      return { toSelect: toToken(arg) };
    return Object.entries(arg).map(([columnOrAs, aliasOrQuery]) => typeof aliasOrQuery === "string" ? { toSelect: columnOrAs, alias: aliasOrQuery } : { toSelect: toToken(aliasOrQuery), alias: columnOrAs });
  });
};
const select = (...selectArgs) => {
  return {
    type: TokenType.Select,
    _fromValues: [],
    _selectValues: selectArgsToValues(selectArgs),
    _distinctValue: false,
    _groupByValues: [],
    _compoundValues: [],
    _orderByValues: [],
    _joinValues: [],
    _limitOffsetValue: buildInitialLimitOffsetState(),
    select(...selectArgs2) {
      return {
        ...this,
        _selectValues: [
          ...this._selectValues,
          ...selectArgsToValues(selectArgs2)
        ]
      };
    },
    distinct(val) {
      return {
        ...this,
        _distinctValue: val
      };
    },
    from,
    where,
    orWhere,
    limit,
    offset,
    withoutLimit,
    withoutOffset,
    groupBy(...values2) {
      return {
        ...this,
        _groupByValues: values2.map((val) => typeof val === "string" ? val : toToken(val))
      };
    },
    having(val) {
      return { ...this, _havingValue: toToken(val) };
    },
    orderBy,
    withoutOrder,
    with: With,
    withoutWith,
    withRecursive,
    union,
    unionAll,
    intersect,
    except,
    withoutCompound,
    withoutJoin,
    join,
    joinCross,
    joinNatural,
    joinLeft,
    joinLeftOuter,
    joinLeftNatural,
    joinLeftNaturalOuter,
    joinRight,
    joinRightOuter,
    joinRightNatural,
    joinRightNaturalOuter,
    joinFull,
    joinFullOuter,
    joinFullNatural,
    joinFullNaturalOuter,
    joinInner,
    joinInnerNatural,
    toSql() {
      return sql$1.join([
        this._cteValue ? this._cteValue : null,
        sql$1`SELECT`,
        this._distinctValue ? sql$1`DISTINCT` : null,
        sql$1.join(this._selectValues.map((val) => {
          if (val.toSelect === "*") {
            return sql$1`*`;
          } else if (typeof val.toSelect === "string") {
            return sql$1.liter(val.toSelect);
          } else {
            return val.alias ? alias(val.toSelect, val.alias) : val.toSelect;
          }
        })),
        this._fromValues.length > 0 || this._joinValues.length > 0 ? sql$1`FROM` : null,
        fromToSql(this),
        this._joinValues.length > 0 ? sql$1.join(this._joinValues.map((expr) => expr.toSql()), " ") : null,
        this._whereValue ? sql$1`WHERE ${this._whereValue}` : null,
        this._groupByValues.length > 0 ? sql$1`GROUP BY ${sql$1.join(this._groupByValues.map((val) => typeof val === "string" ? sql$1.liter(val) : val))}` : null,
        this._groupByValues.length > 0 && this._havingValue ? sql$1`HAVING ${this._havingValue}` : null,
        this._compoundValues.length > 0 ? sql$1.join(this._compoundValues, " ") : null,
        this._orderByValues.length > 0 ? sql$1.join([sql$1`ORDER BY`, sql$1.join(this._orderByValues)], " ") : null,
        this._limitOffsetValue.toSql().isEmpty ? null : this._limitOffsetValue
      ].filter((v) => v), " ");
    }
  };
};
const mapRecordArg = (arg) => {
  return (Array.isArray(arg) ? arg : [arg]).map((it) => Object.entries(it).map(([columnName, value]) => {
    return {
      columnName,
      value: sql$1.isSql(value) && !isToken(value) ? buildRawSql(value) : value
    };
  }));
};
const applyInsertArg = (state, arg) => {
  if (state._toInsertValue && (isSelect(state._toInsertValue) || isValues(state._toInsertValue))) {
    throw new Error("Insert value is already state. If you want to change insert values user resetInsert() before.");
  }
  if (isSelect(arg) || isValues(arg)) {
    return { ...state, _toInsertValue: arg };
  }
  return {
    ...state,
    _toInsertValue: Array.isArray(state._toInsertValue) ? [...state._toInsertValue, ...mapRecordArg(arg)] : mapRecordArg(arg)
  };
};
const insert = (insertArg) => {
  return {
    type: TokenType.Insert,
    _returningValue: returning(),
    _columnNames: [],
    _toInsertValue: isSelect(insertArg) || isValues(insertArg) ? insertArg : mapRecordArg(insertArg),
    with: With,
    withRecursive,
    withoutWith,
    orAbort,
    orFail,
    orIgnore,
    orReplace,
    orRollback,
    returning: returningForState,
    withoutReturning: withoutReturningForState,
    setColumnNames(names) {
      return { ...this, _columnNames: names };
    },
    withoutColumnNames() {
      return { ...this, _columnNames: [] };
    },
    insert(arg) {
      return applyInsertArg(this, arg);
    },
    withoutInsert() {
      return { ...this, _toInsertValue: void 0 };
    },
    into(val) {
      return {
        ...this,
        _intoTable: typeof val === "string" ? sql$1.table(val) : val
      };
    },
    withoutInto() {
      return { ...this, _intoTable: void 0 };
    },
    toSql() {
      if (!this._toInsertValue) {
        throw new Error("Insert values are not set");
      }
      if (!this._intoTable) {
        throw new Error("Into table is not set");
      }
      const columns = this._columnNames.length > 0 ? this._columnNames : Array.isArray(this._toInsertValue) ? this._toInsertValue[0].map(({ columnName }) => columnName) : [];
      return sql$1.join([
        this._cteValue ? this._cteValue : null,
        sql$1`INSERT`,
        this._orReplaceValue ? sql$1`OR ${sql$1.raw(this._orReplaceValue)}` : null,
        sql$1`INTO`,
        this._intoTable,
        columns.length > 0 ? sql$1`(${sql$1.join(columns.map((c) => sql$1.liter(c)))})` : null,
        isValues(this._toInsertValue) || isSelect(this._toInsertValue) ? this._toInsertValue : sql$1`VALUES ${sql$1.join(this._toInsertValue.map((toInsertColumns) => {
          const toInsert = Array(toInsertColumns.length);
          for (const { columnName, value } of toInsertColumns) {
            const index = columns.indexOf(columnName);
            if (index === -1) {
              throw new Error(`Column ${columnName} is not present at columns set: ${columns}. Make sure that you set all columns with setColumnNames() or each insert objects have the same keys present. Tried to insert: ${JSON.stringify(toInsertColumns)}`);
            }
            toInsert[index] = value;
          }
          return sql$1`(${sql$1.join(toInsert)})`;
        }))}`,
        this._returningValue
      ].filter((v) => v), " ");
    }
  };
};
const update = (tbl) => {
  return {
    type: TokenType.Update,
    _updateTable: typeof tbl === "string" ? sql$1.table(tbl) : tbl,
    _setValues: [],
    _fromValues: [],
    _joinValues: [],
    _returningValue: returning(),
    with: With,
    withoutWith,
    withRecursive,
    from,
    where,
    orWhere,
    returning: returningForState,
    withoutReturning: withoutReturningForState,
    orAbort,
    orFail,
    orIgnore,
    orReplace,
    orRollback,
    withoutJoin,
    join,
    joinCross,
    joinNatural,
    joinLeft,
    joinLeftOuter,
    joinLeftNatural,
    joinLeftNaturalOuter,
    joinRight,
    joinRightOuter,
    joinRightNatural,
    joinRightNaturalOuter,
    joinFull,
    joinFullOuter,
    joinFullNatural,
    joinFullNaturalOuter,
    joinInner,
    joinInnerNatural,
    set(...args) {
      const vals = args.flatMap((m) => {
        if (isToken(m)) {
          return m;
        } else if (sql$1.isSql(m)) {
          return buildRawSql(m);
        } else {
          return Object.entries(m).map(([key, val]) => {
            return {
              columnName: key,
              toSet: !isToken(val) && sql$1.isSql(val) ? buildRawSql(val) : val
            };
          });
        }
      });
      return { ...this, _setValues: [...this._setValues, ...vals] };
    },
    toSql() {
      return sql$1.join([
        this._cteValue ? this._cteValue : null,
        sql$1`UPDATE`,
        this._orReplaceValue ? sql$1`OR ${sql$1.raw(this._orReplaceValue)}` : null,
        this._updateTable,
        sql$1`SET`,
        sql$1.join(this._setValues.map((val) => isToken(val) ? val : sql$1`${sql$1.liter(val.columnName)} = ${wrapParentheses(val.toSet)}`)),
        this._fromValues.length > 0 || this._joinValues.length > 0 ? sql$1`FROM` : null,
        fromToSql(this),
        this._joinValues.length > 0 ? sql$1.join(this._joinValues.map((expr) => expr.toSql()), " ") : null,
        this._whereValue ? sql$1`WHERE ${this._whereValue}` : null,
        this._returningValue
      ].filter((v) => v), " ");
    }
  };
};
const not = (expr) => {
  return {
    _operator: "NOT",
    type: TokenType.Unary,
    _expr: expr,
    toSql() {
      return sql$1`NOT (${this._expr})`;
    }
  };
};
export { In, alias, and, asc, buildRawSql, conditionValuesToToken, deleteFrom, desc, eq, eq$, gt, gt$, gtEq, gtEq$, in$, insert, isBinaryOperator, isSelect, isValues, join, joinCross, joinFull, joinFullNatural, joinFullNaturalOuter, joinFullOuter, joinInner, joinInnerNatural, joinLeft, joinLeftNatural, joinLeftNaturalOuter, joinLeftOuter, joinNatural, joinRight, joinRightNatural, joinRightNaturalOuter, joinRightOuter, like, like$, lt, lt$, ltEq, ltEq$, not, notEq, notEq$, notIn, notIn$, notLike, notLike$, or, select, toToken, update, values, withoutJoin, wrapParentheses };
//# sourceMappingURL=index.es.js.map
